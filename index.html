<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FitQuest</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
    <style>
        body { font-family: 'VT323', monospace; background-color: #1a202c; color: #e2e8f0; margin: 0; padding: 0; display: flex; flex-direction: column; min-height: 100vh; overflow-x: hidden; }
        .font-vt323 { font-family: 'VT323', monospace; }
        .btn-retro { background-color: #2563eb; color: white; font-weight: bold; padding: 0.75rem 1rem; border-radius: 0.375rem; border: 2px solid #1e40af; box-shadow: 4px 4px 0 0 rgba(0,0,0,0.5); transition: all 0.1s ease-in-out; cursor: pointer; }
        .btn-retro:hover { background-color: #1d4ed8; }
        .btn-retro:active { box-shadow: none; transform: translateX(4px) translateY(4px); }
        .btn-retro-purple { background-color: #9333ea; color: white; font-weight: bold; padding: 0.75rem 1rem; border-radius: 0.375rem; border: 2px solid #6b21a8; box-shadow: 4px 4px 0 0 rgba(0,0,0,0.5); transition: all 0.1s ease-in-out; cursor: pointer; }
        .btn-retro-purple:hover { background-color: #7e22ce; }
        .btn-retro-purple:active { box-shadow: none; transform: translateX(4px) translateY(4px); }
        .btn-retro-green { background-color: #16a34a; color: white; font-weight: bold; padding: 0.75rem 1rem; border-radius: 0.375rem; border: 2px solid #15803d; box-shadow: 4px 4px 0 0 rgba(0,0,0,0.5); transition: all 0.1s ease-in-out; cursor: pointer; }
        .btn-retro-green:hover { background-color: #14713c; }
        .btn-retro-green:active { box-shadow: none; transform: translateX(4px) translateY(4px); }
        .btn-retro-red { background-color: #dc2626; color: white; font-weight: bold; padding: 0.75rem 1rem; border-radius: 0.375rem; border: 2px solid #b91c1c; box-shadow: 4px 4px 0 0 rgba(0,0,0,0.5); transition: all 0.1s ease-in-out; cursor: pointer; }
        .btn-retro-red:hover { background-color: #c01b1b; }
        .btn-retro-red:active { box-shadow: none; transform: translateX(4px) translateY(4px); }
        .card-retro { background-color: #2d3748; padding: 1.5rem; border-radius: 0.5rem; border: 4px solid #a78bfa; box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1), 0 4px 6px -2px rgba(0,0,0,0.05); color: white; }
        .input-retro, .select-retro { box-shadow: inset 0 2px 4px 0 rgba(0,0,0,0.1); -webkit-appearance: none; -moz-appearance: none; appearance: none; border: 2px solid #2563eb; border-radius: 0.25rem; width: 100%; padding: 0.5rem 0.75rem; line-height: 1.25; outline: none; transition: all 0.1s ease-in-out; color: #dfdfdf; background-color: #131313; }
        .input-retro:focus, .select-retro:focus { ring: 2px; ring-color: #a78bfa; border-color: #a78bfa; }
        .select-retro option { color: #dfdfdf; background-color: #131313; }
        .table-retro { min-width: 100%; background-color: #4a5568; border-radius: 0.5rem; border: 2px solid #2563eb; }
        .table-retro th { padding: 0.5rem 1rem; text-align: left; font-size: 0.875rem; font-weight: 600; color: #fcd34d; border-bottom: 2px solid #2563eb; }
        .table-retro td { padding: 0.75rem 1rem; font-size: 0.875rem; border-bottom: 1px solid #4a5568; color: #dfdfdf; }
        .table-retro tbody tr:last-child td { border-bottom: 0; }
        .btn-icon { font-size: 1.25rem; padding: 0.25rem; border-radius: 9999px; background-color: transparent; color: white; border: none; cursor: pointer; transition: background-color 0.2s ease-in-out; }
        .btn-icon:hover { background-color: #4a5568; }
        .spinner { border: 4px solid rgba(255, 255, 255, 0.3); border-radius: 50%; border-top: 4px solid #fff; width: 20px; height: 20px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .xp-bar-container { position: relative; width: 100%; height: 24px; background-color: #333; border: 2px solid #a0a0a0; border-radius: 4px; overflow: hidden; display: flex; align-items: center; justify-content: center; box-shadow: inset 0 0 5px rgba(0,0,0,0.5); }
        .xp-bar-fill { height: 100%; background: linear-gradient(to right, #16a34a, #15803d); transition: width 0.5s ease-in-out, background 0.5s ease-in-out; position: absolute; left: 0; top: 0; border-radius: 2px; animation: xp-glow 1.5s infinite alternate; }
        @keyframes xp-glow { from { box-shadow: 0 0 5px #16a34a; } to { box-shadow: 0 0 15px #15803d; } }
        .xp-bar-text { position: absolute; color: #1a202c; font-size: 0.85rem; font-weight: bold; z-index: 10; text-shadow: 0 0 2px white, 0 0 2px white, 0 0 2px white; }
        .notification-container { position: fixed; z-index: 1000; pointer-events: none; display: flex; flex-direction: column; gap: 10px; }
        .notification { padding: 1rem; border-radius: 0.5rem; box-shadow: 0 4px 6px rgba(0,0,0,0.3); opacity: 0; transition: opacity 0.5s ease-out, transform 0.5s ease-out; font-family: 'VT323', monospace; display: flex; align-items: center; gap: 0.5rem; min-width: 250px; max-width: 90%; }
        .notification-container-bottom-right { bottom: 20px; right: 20px; align-items: flex-end; }
        .notification.general, .notification.tip { transform: translateX(100%); background-color: #2563eb; color: white; border: 2px solid #1e40af; text-align: right; border-top-right-radius: 0; border-bottom-right-radius: 0; }
        .notification.general.error { background-color: #dc2626; border-color: #b91c1c; }
        .notification.general.warning { background-color: #d97706; border-color: #9a3412; }
        .notification.general.success { background-color: #16a34a; border-color: #15803d; }
        .notification.general.chrono { background-color: #9333ea; border-color: #6b21a8; }
        .notification.tip { background-color: #059669; border-color: #065F46; }
        .notification.general.show, .notification.tip.show { transform: translateX(0); opacity: 1; }
        @media (max-width: 640px) {
            .notification-container-bottom-right { left: 50%; transform: translateX(-50%); right: auto; width: 100%; align-items: center; top: auto; bottom: 20px; flex-direction: column-reverse; }
            .notification { width: 90%; margin: 0 auto; border-radius: 0.5rem; text-align: center; flex-direction: column; gap: 0.25rem; }
            .notification.general, .notification.tip { transform: translateX(0) !important; border-radius: 0.5rem; }
            .nav-scroll-container { overflow-x: auto; -webkit-overflow-scrolling: touch; scrollbar-width: none; -ms-overflow-style: none; }
            .nav-scroll-container::-webkit-scrollbar { display: none; }
            .nav-items-wrapper { display: flex; flex-wrap: nowrap; padding-bottom: 5px; }
            .nav-item { flex-shrink: 0; min-width: 80px; padding: 0.5rem 0.75rem; margin: 0 0.25rem; }
            .main-content-area { padding-bottom: 6rem; }
        }

        /* Styles for the range input (volume slider) */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px; /* Explicit height */
            background: #4a5568; /* Dark grey track */
            border-radius: 5px;
            outline: none;
            cursor: pointer;
            transition: background 0.2s ease-in-out;
        }

        /* Webkit (Chrome, Safari, Edge) track styling */
        input[type="range"]::-webkit-slider-runnable-track {
            width: 100%;
            height: 8px;
            background: #4a5568; /* Dark grey track */
            border-radius: 5px;
            border: none; /* Ensure no default border */
        }

        /* Style for the slider thumb (the draggable part) for Webkit browsers */
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #fcd34d; /* Yellow thumb */
            border-radius: 50%;
            cursor: pointer;
            margin-top: -6px; /* Adjust vertical position to center on the track */
            box-shadow: 0 0 2px rgba(0,0,0,.6);
        }

        /* Style for the slider thumb for Firefox */
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #fcd34d;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 2px rgba(0,0,0,.6);
        }

        /* Style for the slider track for Firefox */
        input[type="range"]::-moz-range-track {
            background: #4a5568;
            border-radius: 5px;
            height: 8px;
        }

        /* Style for the slider track for Internet Explorer */
        input[type="range"]::-ms-track {
            background: #4a5568;
            border-radius: 5px;
            height: 8px;
            color: transparent;
        }

        input[type="range"]::-ms-thumb {
            width: 20px;
            height: 20px;
            background: #fcd34d;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 2px rgba(0,0,0,.6);
        }
    </style>
</head>
<body class="font-vt323 text-white bg-gray-900 min-h-screen flex flex-col">
    <div id="loading-screen" class="fixed inset-0 flex flex-col items-center justify-center bg-gray-900 font-vt323 text-white z-[999]">
        <div class="text-4xl sm:text-5xl text-yellow-300 mb-8 animate-bounce">FitQuest</div>
        <div class="w-64 sm:w-80 h-8 bg-gray-700 border-4 border-yellow-500 rounded-lg overflow-hidden relative">
            <div id="loading-progress-bar" class="h-full bg-green-500 transition-all duration-500 ease-linear" style="width: 0%;"></div>
            <div id="loading-progress-text" class="absolute inset-0 flex items-center justify-center text-lg font-bold text-gray-900">0% CHARGEMENT...</div>
        </div>
        <div id="loading-message" class="mt-8 p-3 rounded-md hidden"></div>
        <p id="audio-inactive-message" class="text-gray-400 text-sm sm:text-base mt-4 text-center hidden">AUDIO DÉSACTIVÉ. ACTIVEZ LE SON VIA LES OPTIONS POUR LES EFFETS AUDIO ET LA SYNTHÈSE VOCALE.</p>
    </div>
    <div id="app-container" class="min-h-screen flex flex-col hidden">
        <header class="bg-gradient-to-r from-blue-700 to-indigo-800 text-yellow-300 p-5 shadow-md border-b-4 border-purple-500 rounded-b-lg">
            <div class="flex items-center justify-center relative">
                <button id="home-button" class="absolute left-0 top-1/2 -translate-y-1/2 p-2 rounded-full hover:bg-blue-600 transition-colors duration-200" title="Retour à l'accueil">
                    <i data-lucide="home" class="text-yellow-300 text-3xl"></i>
                </button>
                <h1 class="text-4xl sm:text-5xl lg:text-6xl font-bold text-center tracking-widest leading-tight flex-1">FITQUEST</h1>
            </div>
            <p class="text-center text-lg sm:text-xl mt-2 opacity-90">TON PROGRAMME PERSONNALISÉ</p>
            <p class="text-center text-sm sm:text-base mt-1 opacity-80 text-gray-300">GÉNÉRÉ PAR POXEL, TON IA PERSONNELLE</p>
            <p id="user-id-display" class="text-center text-xs sm:text-sm mt-2 opacity-80 text-gray-300 hidden">ID UTILISATEUR: <span id="user-id-value" class="font-mono break-all"></span></p>
            <div class="flex items-center justify-center my-4 px-4">
                <i data-lucide="zap" class="text-yellow-400 text-3xl sm:text-4xl mr-2"></i>
                <div class="flex-1 xp-bar-container">
                    <div id="xp-bar-fill" class="xp-bar-fill" style="width: 0%;"></div>
                    <span id="xp-bar-text" class="xp-bar-text">LVL 0 : 0/100 XP</span>
                </div>
            </div>
            <div class="mt-4 p-3 bg-gray-700 rounded-md border-2 border-blue-700">
                <h3 class="text-lg sm:text-xl font-bold text-yellow-300 mb-2">TON PROFIL ET STATS VITALES :</h3>
                <div class="flex flex-col sm:flex-row sm:items-end gap-3 justify-center">
                    <div class="flex-1 w-full sm:w-auto">
                        <label for="userHeight" class="block text-gray-200 text-sm font-bold mb-1">TAILLE (CM) :</label>
                        <input type="number" id="userHeight" class="input-retro" placeholder="EX: 175" />
                    </div>
                    <div class="flex-1 w-full sm:w-auto">
                        <label for="userWeight" class="block text-gray-200 text-sm font-bold mb-1">POIDS (KG) :</label>
                        <input type="number" id="userWeight" class="input-retro" placeholder="EX: 70" />
                    </div>
                    <button id="save-profile-btn" class="btn-retro-green sm:w-auto w-full px-5 py-2">ENREGISTRER</button>
                </div>
                <div id="imc-display" class="mt-3 text-center text-lg text-white hidden">
                    <p>TON IMC : <span id="imc-value" class="font-bold text-yellow-300"></span></p>
                    <p>CATÉGORIE : <span id="imc-category" class="font-bold text-blue-400"></span></p>
                    <p>PROTÉINES ESTIMÉES : <span id="protein-needs" class="font-bold text-yellow-300"></span></p>
                    <div class="text-xs text-gray-400 mt-2">
                        <p>**IMC INF. À 16.5 :** INSUFFISANCE PONDÉRALE (DÉNUTRITION SÉVÈRE)</p>
                        <p>**IMC 16.5 À 18.4 :** INSUFFISANCE PONDÉRALE</p>
                        <p>**IMC 18.5 À 24.9 :** POIDS NORMAL</p>
                        <p>**IMC 25 À 26.9 :** SURPOIDS (PRÉ-OBÉSITÉ)</p>
                        <p>**IMC 27 À 29.9 :** SURPOIDS (OBÉSITÉ MODÉRÉE)</p>
                        <p>**IMC 30 À 34.9 :** OBÉSITÉ CLASSE I</p>
                        <p>**IMC 35 À 39.9 :** OBÉSITÉ CLASSE II (SÉVÈRE)</p>
                        <p>**IMC SUP. OU ÉGAL À 40 :** OBÉSITÉ CLASSE III (MORBIDE OU MASSIVE)</p>
                        <p class="mt-2">**BESOINS EN PROTÉINES :** ESTIMATION POUR LA RÉCUPÉRATION MUSCULAIRE ET LE MAINTIEN DE LA MASSE CORPORELLE, CLÉ POUR TON ACTIVITÉ PHYSIQUE.</p>
                    </div>
                </div>
            </div>
        </header>
        <nav class="bg-gray-800 shadow-xl py-3 px-2 sm:px-4 border-y-4 border-blue-700 rounded-b-lg mb-4 mx-2">
            <div class="nav-scroll-container">
                <div class="nav-items-wrapper">
                    <button class="nav-item inline-flex flex-col items-center justify-center p-2 rounded-lg transition-all duration-100 text-gray-200 hover:bg-gray-700 hover:text-yellow-300 border-2 border-gray-700 shadow-[4px_4px_0_0_rgba(0,0,0,0.5)] active:shadow-none active:translate-x-1 active:translate-y-1" data-page="daily_plan"><i data-lucide="calendar" class="text-xl" style="width:24px; height:24px;"></i><span class="text-sm mt-1">PLANNING</span></button>
                    <button class="nav-item inline-flex flex-col items-center justify-center p-2 rounded-lg transition-all duration-100 text-gray-200 hover:bg-gray-700 hover:text-yellow-300 border-2 border-gray-700 shadow-[4px_4px_0_0_rgba(0,0,0,0.5)] active:shadow-none active:translate-x-1 active:translate-y-1" data-page="workout"><i data-lucide="dumbbell" class="text-xl" style="width:24px; height:24px;"></i><span class="text-sm mt-1">SPORT</span></button>
                    <button class="nav-item inline-flex flex-col items-center justify-center p-2 rounded-lg transition-all duration-100 text-gray-200 hover:bg-gray-700 hover:text-yellow-300 border-2 border-gray-700 shadow-[4px_4px_0_0_rgba(0,0,0,0.5)] active:shadow-none active:translate-x-1 active:translate-y-1" data-page="recipes"><i data-lucide="utensils" class="text-xl" style="width:24px; height:24px;"></i><span class="text-sm mt-1">RECETTES</span></button>
                    <button class="nav-item inline-flex flex-col items-center justify-center p-2 rounded-lg transition-all duration-100 text-gray-200 hover:bg-gray-700 hover:text-yellow-300 border-2 border-gray-700 shadow-[4px_4px_0_0_rgba(0,0,0,0.5)] active:shadow-none active:translate-x-1 active:translate-y-1" data-page="chrono"><i data-lucide="timer" class="text-xl" style="width:24px; height:24px;"></i><span class="text-sm mt-1">CHRONO</span></button>
                    <button class="nav-item inline-flex flex-col items-center justify-center p-2 rounded-lg transition-all duration-100 text-gray-200 hover:bg-gray-700 hover:text-yellow-300 border-2 border-gray-700 shadow-[4px_4px_0_0_rgba(0,0,0,0.5)] active:shadow-none active:translate-x-1 active:translate-y-1" data-page="progress"><i data-lucide="line-chart" class="text-xl" style="width:24px; height:24px;"></i><span class="text-sm mt-1">ÉVOLUTION</span></button>
                    <button class="nav-item inline-flex flex-col items-center justify-center p-2 rounded-lg transition-all duration-100 text-gray-200 hover:bg-gray-700 hover:text-yellow-300 border-2 border-gray-700 shadow-[4px_4px_0_0_rgba(0,0,0,0.5)] active:shadow-none active:translate-x-1 active:translate-y-1" data-page="trophies"><i data-lucide="trophy" class="text-xl" style="width:24px; height:24px;"></i><span class="text-sm mt-1">TROPHÉES</span></button>
                    <button class="nav-item inline-flex flex-col items-center justify-center p-2 rounded-lg transition-all duration-100 text-gray-200 hover:bg-gray-700 hover:text-yellow-300 border-2 border-gray-700 shadow-[4px_4px_0_0_rgba(0,0,0,0.5)] active:shadow-none active:translate-x-1 active:translate-y-1" data-page="options"><i data-lucide="settings" class="text-xl" style="width:24px; height:24px;"></i><span class="text-sm mt-1">OPTIONS</span></button>
                </div>
            </div>
        </nav>
        <main id="main-content" class="flex-1 p-4 sm:p-6 main-content-area max-w-full mx-auto"></main>
        <footer class="fixed bottom-0 left-0 right-0 bg-gray-800 shadow-lg p-3 sm:hidden border-t-4 border-blue-700 text-center text-xs text-gray-400">FitQuest - 2023</footer>
    </div>
    <div id="global-modals-container"></div>
    <div id="notification-container-bottom-right" class="notification-container notification-container-bottom-right flex-col-reverse"></div>

    <script>
        // Fonction pour rendre les icônes Lucide
        function renderLucideIcons() { lucide.createIcons(); }

        // Variables d'état globales de l'application
        let currentPage = 'daily_plan', isLoadingApp = true, loadingProgress = 0;
        let weeklyMealPlan = null, userProfile = { height: '', weight: '', imc: null, imcCategory: '', proteinNeeds: 'N/A', currentXP: 0, earnedTrophies: [], hideExerciseHistory: false, apiKey: '', likedMeals: [] };
        let workoutLogs = [], weightHistory = [], intervalSequences = [], shifts = [];
        let workoutProgram = {}, previousLevel = 0, isAudioActive = true, masterVolume = 1;
        let trophySoundPlayer, levelUpPlayer, majorLevelUpPlayer, beepPlayer, startSoundPlayer, synth;
        let chronoIntervals = [], chronoCurrentTime = 0, chronoCurrentIntervalIndex = -1, isChronoRunning = false, isChronoPaused = false, enableChronoPreCountdown = true, chronoPreCountdownDuration = 10, chronoIntervalTimerRef = null;
        let weightChartInstance = null, exerciseChartInstance = null, userId = 'local_user';
        let editingIntervalIndex = -1;
        let regeneratingMeal = null;

        // Liste de tous les trophées disponibles et leurs conditions
        const allTrophies = [
            { id: 't001', name: 'PREMIER PAS', description: 'Atteindre le Niveau 1. Le voyage commence !', levelRequired: 1 },
            { id: 't002', name: 'NOVICE EN FORME', description: 'Atteindre le Niveau 2. Vous prenez le rythme.', levelRequired: 2 },
            { id: 't003', name: 'INITIÉ DU FIT', description: 'Atteindre le Niveau 3. Les efforts paient.', levelRequired: 3 },
            { id: 't004', name: 'FORME CROISSANTE', description: 'Atteindre le Niveau 4. De mieux en mieux !', levelRequired: 4 },
            { id: 't005', name: 'DÉBUTANT AVANCÉ', description: 'Atteindre le Niveau 5. Vous n\'êtes plus un débutant.', levelRequired: 5 },
            { id: 't006', name: 'CONSTANCE MÉRITÉE', description: 'Atteindre le Niveau 6. La régularité, c\'est la clé.', levelRequired: 6 },
            { id: 't007', name: 'ÉLAN DU PROGRÈS', description: 'Atteindre le Niveau 7. Vous sentez la progression.', levelRequired: 7 },
            { id: 't008', name: 'GAINS ASSURÉS', description: 'Atteindre le Niveau 8. Les muscles se dessinent.', levelRequired: 8 },
            { id: 't009', name: 'AVANCÉE RAPIDE', description: 'Atteindre le Niveau 9. Vous brûlez les étapes.', levelRequired: 9 },
            { id: 't010', name: 'DIXIÈME ÉTAPE', description: 'Atteindre le Niveau 10. Un jalon important !', levelRequired: 10 },
            { id: 't011', name: 'MAÎTRE INTERMÉDIAIRE', description: 'Atteindre le Niveau 11. Le fitness devient une habitude.', levelRequired: 11 },
            { id: 't012', name: 'FORCE ÉMERGENTE', description: 'Atteindre le Niveau 12. Vos limites sont repoussées.', levelRequired: 12 },
            { id: 't013', name: 'ENDURANCE ACCRUE', description: 'Atteindre le Niveau 13. Le cardio n\'a plus de secret.', levelRequired: 13 },
            { id: 't014', name: 'EXCELLENCE EN VUE', description: 'Atteindre le Niveau 14. La performance est à portée.', levelRequired: 14 },
            { id: 't015', name: 'DEMI-MAÎTRE', description: 'Atteindre le Niveau 15. Vous êtes sur la bonne voie.', levelRequired: 15 },
            { id: 't016', name: 'DISCIPLINE DE FER', description: 'Atteindre le Niveau 16. Votre engagement est fort.', levelRequired: 16 },
            { id: 't017', name: 'ÉNERGIE DÉCUPLÉE', description: 'Atteindre le Niveau 17. Sentez cette vitalité !', levelRequired: 17 },
            { id: 't018', name: 'HARMONIE CORPS/ESPRIT', description: 'Atteindre le Niveau 18. L\'équilibre est parfait.', levelRequired: 18 },
            { id: 't019', name: 'FORME OPTIMALE', description: 'Atteindre le Niveau 19. Vous rayonnez de santé.', levelRequired: 19 },
            { id: 't020', name: 'DEUXIÈME DIZAINE', description: 'Atteindre le Niveau 20. Double décennie de fitness !', levelRequired: 20 },
            { id: 't021', name: 'EXPERT EN DEVENIR', description: 'Atteindre le Niveau 21. La maîtrise approche.', levelRequired: 21 },
            { id: 't022', name: 'PUISSANCE RÉVÉLÉE', description: 'Atteindre le Niveau 22. Une force insoupçonnée.', levelRequired: 22 },
            { id: 't023', name: 'AGILITÉ MAXIMALE', description: 'Atteindre le Niveau 23. Votre corps est un temple agile.', levelRequired: 23 },
            { id: 't024', name: 'RÉSISTANCE INÉGALÉE', description: 'Atteindre le Niveau 24. Rien ne vous arrête.', levelRequired: 24 },
            { id: 't025', name: 'QUART DE SIÈCLE', description: 'Atteindre le Niveau 25. Vous êtes une machine !', levelRequired: 25 },
            { id: 't026', name: 'PERFECTION EN MARCHE', description: 'Atteindre le Niveau 26. Chaque pas est un succès.', levelRequired: 26 },
            { id: 't027', name: 'FORME INCROYABLE', description: 'Atteindre le Niveau 27. Admirez votre progression !', levelRequired: 27 },
            { id: 't028', name: 'DÉTERMINATION ACÉRÉE', description: 'Atteindre le Niveau 28. Votre volonté est sans faille.', levelRequired: 28 },
            { id: 't029', name: 'INÉPUISABLE', description: 'Atteindre le Niveau 29. L\'énergie vous habite.', levelRequired: 29 },
            { id: 't030', name: 'LE TREINTIÈME', description: 'Atteindre le Niveau 30. Un cap monumental !', levelRequired: 30 },
            { id: 't031', name: 'MAÎTRE ABSOLU', description: 'Atteindre le Niveau 31. Vous êtes une référence.', levelRequired: 31 },
            { id: 't032', name: 'EXPERT LÉGENDAIRE', description: 'Atteindre le Niveau 32. Votre réputation vous précède.', levelRequired: 32 },
            { id: 't033', name: 'OLYMPIEN EN HERBE', description: 'Atteindre le Niveau 33. Digne des plus grands athlètes.', levelRequired: 33 },
            { id: 't034', name: 'CHAMPION INCROYABLE', description: 'Atteindre le Niveau 34. Votre esprit est indomptable.', levelRequired: 34 },
            { id: 't035', name: 'LE PRODIGE', description: 'Atteindre le Niveau 35. Vos prouesses sont inégalées.', levelRequired: 35 },
            { id: 't036', name: 'FORCE DE LA NATURE', description: 'Atteindre le Niveau 36. Vous êtes imparable.', levelRequired: 36 },
            { id: 't037', name: 'FORME DIVINE', description: 'Atteindre le Niveau 37. Votre corps est une œuvre d\'art.', levelRequired: 37 },
            { id: 't038', name: 'CONNAISSANCE SUPRÊME', description: 'Atteindre le Niveau 38. Votre savoir est immense.', levelRequired: 38 },
            { id: 't039', name: 'RÉALISATION PARFAITE', description: 'Atteindre le Niveau 39. Tout est sous contrôle.', levelRequired: 39 },
            { id: 't040', name: 'QUARANTIÈME HORIZON', description: 'Atteindre le Niveau 40. Le ciel est votre limite !', levelRequired: 40 },
            { id: 't041', name: 'LÉGENDE VIVANTE', description: 'Atteindre le Niveau 41. On parlera de vous.', levelRequired: 41 },
            { id: 't042', name: 'INSPIRATION ULTIME', description: 'Atteindre le Niveau 42. Vous inspirez les foules.', levelRequired: 42 },
            { id: 't043', name: 'DÉFI RELEVÉ', description: 'Atteindre le Niveau 43. Chaque obstacle est un tremplin.', levelRequired: 43 },
            { id: 't044', name: 'SUMMUM DE LA FORME', description: 'Atteindre le Niveau 44. Vous êtes au sommet.', levelRequired: 44 },
            { id: 't045', name: 'LE MAÎTRE CULMINANT', description: 'Atteindre le Niveau 45. La perfection incarnée.', levelRequired: 45 },
            { id: 't046', name: 'IMPARABLE', description: 'Atteindre le Niveau 46. Vous êtes invincible !', levelRequired: 46 },
            { id: 't047', name: 'VOLONTÉ DE DIAMANT', description: 'Atteindre le Niveau 47. Votre détermination est inébranlable.', levelRequired: 47 },
            { id: 't048', name: 'ÉCLAT ÉTERNEL', description: 'Atteindre le Niveau 48. Votre aura brille.', levelRequired: 48 },
            { id: 't049', name: 'CONNAISSANCE ABSOLUE', description: 'Atteindre le Niveau 49. Le savoir vous guide.', levelRequired: 49 },
            { id: 't050', name: 'LE CINQUANTIÈME', description: 'Atteindre le Niveau 50. Une performance extraordinaire !', levelRequired: 50 },
            { id: 't051', name: 'GRAND MAÎTRE', description: 'Atteindre le Niveau 51. Vous êtes au-delà de l\'excellence.', levelRequired: 51 },
            { id: 't052', name: 'ARCHITECTE DU CORPS', description: 'Atteindre le Niveau 52. Vous sculptez votre destin.', levelRequired: 52 },
            { id: 't053', name: 'ARTISAN DE LA SANTÉ', description: 'Atteindre le Niveau 53. Votre bien-être est une œuvre.', levelRequired: 53 },
            { id: 't054', name: 'GUERRIER DE LA FORME', description: 'Atteindre le Niveau 54. Combattez pour votre meilleure version.', levelRequired: 54 },
            { id: 't055', name: 'CONQUÉRANT DU PHYSIQUE', description: 'Atteindre le Niveau 55. Chaque jour est une victoire.', levelRequired: 55 },
            { id: 't056', name: 'PIONNIER DU BIEN-ÊTRE', description: 'Atteindre le Niveau 56. Vous ouvrez la voie.', levelRequired: 56 },
            { id: 't057', name: 'PILIER DE LA VITALITÉ', description: 'Atteindre le Niveau 57. Votre énergie est inépuisable.', levelRequired: 57 },
            { id: 't058', name: 'SYNTHÈSE PARFAITE', description: 'Atteindre le Niveau 58. L\'harmonie est atteinte.', levelRequired: 58 },
            { id: 't059', name: 'PERFORMANCE ULTIME', description: 'Atteindre le Niveau 59. Vous défiez les limites.', levelRequired: 59 },
            { id: 't060', name: 'LE SOIXANTIÈME', description: 'Atteindre le Niveau 60. Incroyable persévérance !', levelRequired: 60 },
            { id: 't061', name: 'LÉGENDAIRE INDOMPTABLE', description: 'Atteindre le Niveau 61. Votre nom résonne.', levelRequired: 61 },
            { id: 't062', name: 'MYTHIQUE', description: 'Atteindre le Niveau 62. Votre parcours est une épopée.', levelRequired: 62 },
            { id: 't063', name: 'CHRONIQUE VIVANTE', description: 'Atteindre le Niveau 63. Chaque jour écrit l\'histoire.', levelRequired: 63 },
            { id: 't064', name: 'PATRON DES RECORDS', description: 'Atteindre le Niveau 64. Les records s\'inclinent.', levelRequired: 64 },
            { id: 't065', name: 'LE NÉMÉSIS DE LA FAIBLESSE', description: 'Atteindre le Niveau 65. Plus rien ne vous arrête.', levelRequired: 65 },
            { id: 't066', name: 'VOLONTÉ D\'ACIER', description: 'Atteindre le Niveau 66. Votre détermination est inébranlable.', levelRequired: 66 },
            { id: 't067', name: 'MÉTÉORE DE LA FORME', description: 'Atteindre le Niveau 67. Votre progression est fulgurante.', levelRequired: 67 },
            { id: 't068', name: 'AU-DELÀ DES LIMITES', description: 'Atteindre le Niveau 68. Vous transcendez tout.', levelRequired: 68 },
            { id: 't069', name: 'VISIONNAIRE DU FITNESS', description: 'Atteindre le Niveau 69. Votre vision est claire.', levelRequired: 69 },
            { id: 't070', name: 'LE SOIXANTE-DIXIÈME', description: 'Atteindre le Niveau 70. Une ascension sans fin !', levelRequired: 70 },
            { id: 't071', name: 'IMMORTEL DE LA FORME', description: 'Atteindre le Niveau 71. Votre dévouement est éternel.', levelRequired: 71 },
            { id: 't072', name: 'INVICTUS', description: 'Atteindre le Niveau 72. Vous êtes invaincu.', levelRequired: 72 },
            { id: 't073', name: 'MAJESTÉ DU PHYSIQUE', description: 'Atteindre le Niveau 73. Votre présence est imposante.', levelRequired: 73 },
            { id: 't074', name: 'SOUVERAIN DE LA SANTÉ', description: 'Atteindre le Niveau 74. Vous régnez sur votre bien-être.', levelRequired: 74 },
            { id: 't075', name: 'FORCE COLISEUM', description: 'Atteindre le Niveau 75. Digne d\'une arène antique.', levelRequired: 75 },
            { id: 't076', name: 'MYSTÈRE DE LA RÉUSSITE', description: 'Atteindre le Niveau 76. Votre succès est fascinant.', levelRequired: 76 },
            { id: 't077', name: 'PERFECTION DE L\'ÊTRE', description: 'Atteindre le Niveau 77. Corps et âme alignés.', levelRequired: 77 },
            { id: 't078', name: 'AURORE DE LA GRANDEUR', description: 'Atteindre le Niveau 78. Chaque jour est un nouveau chef-d\'œuvre.', levelRequired: 78 },
            { id: 't079', name: 'COURONNE ÉTERNELLE', description: 'Atteindre le Niveau 79. Votre legs perdurera.', levelRequired: 79 },
            { id: 't080', name: 'LE QUATRE-VINGTIÈME', description: 'Atteindre le Niveau 80. Une légende se construit !', levelRequired: 80 },
            { id: 't081', name: 'DIEU DU FITNESS', description: 'Atteindre le Niveau 81. Votre puissance est divine.', levelRequired: 81 },
            { id: 't082', name: 'TITAN DE LA FORME', description: 'Atteindre le Niveau 82. Une force colossale.', levelRequired: 82 },
            { id: 't083', name: 'HÉROS ABSOLU', description: 'Atteindre le Niveau 83. Vous êtes l\'incarnation du triomphe.', levelRequired: 83 },
            { id: 't084', name: 'DÉFIANT LES MORTELS', description: 'Atteindre le Niveau 84. Plus rien ne vous est impossible.', levelRequired: 84 },
            { id: 't085', name: 'LE PHÉNIX DE LA SANTÉ', description: 'Atteindre le Niveau 85. Vous renaissez de vos efforts.', levelRequired: 85 },
            { id: 't086', name: 'CONSTELLATION DE MUSCLES', description: 'Atteindre le Niveau 86. Chaque muscle brille.', levelRequired: 86 },
            { id: 't087', name: 'L\'AURORE BORÉALE', description: 'Atteindre le Niveau 87. Votre beauté est naturelle.', levelRequired: 87 },
            { id: 't088', name: 'LA FULGURANCE', description: 'Atteindre le Niveau 88. Votre vitesse est inégalée.', levelRequired: 88 },
            { id: 't089', name: 'L\'INCONNU', description: 'Atteindre le Niveau 89. Le monde vous attend.', levelRequired: 89 },
            { id: 't090', name: 'LE NONANTIÈME', description: 'Atteindre le Niveau 90. À l\'aube de l\'immortalité !', levelRequired: 90 },
            { id: 't091', name: 'L\'ASCENSION', description: 'Atteindre le Niveau 91. Vous touchez les étoiles.', levelRequired: 91 },
            { id: 't092', name: 'LA CONQUÊTE FINALE', description: 'Atteindre le Niveau 92. La victoire est proche.', levelRequired: 92 },
            { id: 't093', name: 'LA PERFECTION ATTEINTE', description: 'Atteindre le Niveau 93. Chaque aspect est maîtrisé.', levelRequired: 93 },
            { id: 't094', name: 'LE ZÉNITH', description: 'Atteindre le Niveau 94. Vous êtes au sommet du monde.', levelRequired: 94 },
            { id: 't095', name: 'LE MYSTÈRE ÉCLAIRCI', description: 'Atteindre le Niveau 95. Les secrets sont révélés.', levelRequired: 95 },
            { id: 't096', name: 'LE DESTIN ACCOMPLI', description: 'Atteindre le Niveau 96. Votre destinée est scellée.', levelRequired: 96 },
            { id: 't097', name: 'L\'APOTHÉOSE', description: 'Atteindre le Niveau 97. Vous êtes glorifié.', levelRequired: 97 },
            { id: 't098', name: 'L\'HÉRITAGE', description: 'Atteindre le Niveau 98. Votre histoire sera contée.', levelRequired: 98 },
            { id: 't099', name: 'L\'INFINI', description: 'Atteindre le Niveau 99. Les possibilités sont sans fin.', levelRequired: 99 },
            { id: 't100', name: 'MAÎTRE ULTIME DE POXEL', description: 'Atteindre le Niveau 100. Félicitations, Poxel vous couronne !', levelRequired: 100 },
            { id: 't101', name: 'AU-DELÀ DE LA CENTAINE I', description: 'Atteindre le Niveau 101. Une force continue.', levelRequired: 101 },
            { id: 't102', name: 'AU-DELÀ DE LA CENTAINE II', description: 'Atteindre le Niveau 102. La puissance croît.', levelRequired: 102 },
            { id: 't103', name: 'AU-DELÀ DE LA CENTAINE III', description: 'Atteindre le Niveau 103. L\'énergie pure.', levelRequired: 103 },
            { id: 't104', name: 'AU-DELÀ DE LA CENTAINE IV', description: 'Atteindre le Niveau 104. La maîtrise s\'étend.', levelRequired: 104 },
            { id: 't105', name: 'AU-DELÀ DE LA CENTAINE V', description: 'Atteindre le Niveau 105. Les profondeurs de la forme.', levelRequired: 105 },
            { id: 't106', name: 'AU-DELÀ DE LA CENTAINE VI', description: 'Atteindre le Niveau 106. La discipline absolue.', levelRequired: 106 },
            { id: 't107', name: 'AU-DELÀ DE LA CENTAINE VII', description: 'Atteindre le Niveau 107. Le corps résiste à tout.', levelRequired: 107 },
            { id: 't108', name: 'AU-DELÀ DE LA CENTAINE VIII', description: 'Atteindre le Niveau 108. L\'esprit ne faiblit pas.', levelRequired: 108 },
            { id: 't109', name: 'AU-DELÀ DE LA CENTAINE IX', description: 'Atteindre le Niveau 109. La sagesse du guerrier.', levelRequired: 109 },
            { id: 't110', name: 'AU-DELÀ DE LA CENTAINE X', description: 'Atteindre le Niveau 110. Une décennie de plus de puissance !', levelRequired: 110 },
        ];

        // Routines de sommeil adaptées aux types de poste
        const sleepRoutines = {
            '6h-18h': { name: "ROUTINE JOUR (6H-18H)", details: [ "COUCHER : 22H00 - 23H00.", "RÉVEIL : 05H00 - 06H00.", "ASSURER 7-8H DE SOMMEIL DE QUALITÉ. ÉVITER LES ÉCRANS AVANT LE COUCHER." ] },
            '7h-18h': { name: "ROUTINE JOUR (7H-18H)", details: [ "COUCHER : 22H00 - 22H30.", "RÉVEIL : 06H00 - 06H15.", "OBJECTIF 7-8H DE SOMMEIL. PRIVILÉGIER UN RITUEL DE DÉTENTE PRÉ-SOMMEIL." ] },
            '18h-6h': { name: "ROUTINE NUIT (18H-6H)", details: [ "SOMMEIL PRINCIPAL APRÈS LE POSTE : 07H00 - 14H00/15H00 (7-8H).", "SIESTE PRÉ-POSTE (OPTIONNEL) : 17H00 - 17H45 (45 MIN) POUR BOOSTER LA VIGILANCE.", "UTILISER DES RIDEAUX OCCULTANTS ET UN MASQUE DE SOMMEIL POUR OPTIMISER LE REPOS EN JOURNÉE." ] },
            'repos': { name: "JOUR DE REPOS (RÉCUPÉRATION)", details: [ "MAINTENIR UN HORAIRE DE SOMMEIL PROCHE DES JOURS DE TRAVAIL POUR NE PAS PERTURBER LE RYTHME CIRCADIEN.", "COUCHER : VERS 23H00.", "RÉVEIL : VERS 08H00-09H00.", "POSSIBILITÉ DE SIÈSTE COURTE (20-30 MIN) EN DÉBUT D'APRÈS-MIDI SI NÉCESSAIRE." ] },
            'repos_sport': { name: "JOUR DE REPOS (SPORT)", details: [ "COUCHER : VERS 22H30-23H30.", "RÉVEIL : VERS 07H00-08H00.", "SOMMEIL OPTIMAL POUR LA RÉCUPÉRATION MUSCULAIRE. ÉVITER LES EXCITANTS APRÈS L'ENTRAÎNEMENT." ] }
        };

        // Structure par defaut du programme d'entrainement
        const defaultWorkoutProgramStructure = {
            phase1: {
                name: "PHASE 1 : PROGRAMME INITIAL (POUR LES 4 À 6 PREMIÈRES SEMAINES)",
                sessions: {
                    main: {
                        name: "SÉANCE TYPE : RENFORCEMENT MUSCULAIRE (FULL BODY)",
                        exercises: [
                            { name: "SQUAT (POIDS DU CORPS OU HALTÈRE GOBLET)", desc: "4 SÉRIES DE 10-15 RÉPÉTITIONS. CONSIGNE : DESCENDS COMME SI TU VOULAIS T'ASSEOIR SUR UNE CHAISE, EN GARDANT LE DOS DROIT. TES GENOUX NE DOIVENT PAS DÉPASSER TES POINTES DE PIEDS. POIDS SUGGÉRÉ (HALTÈRE) : COMMENCE AU POIDS DU CORPS. SI FACILE, UTILISE UN HALTÈRE DE 4-10 KG.", type: "legs" },
                            { name: "POMPES (PUSH-UPS)", desc: "3-4 SÉRIES DE MAX DE RÉPÉTITIONS (FAIS LE MAXIMUM DE RÉPÉTITIONS POSSIBLES AVEC UNE BONNE FORME). CONSIGNE : GARDE LE CORPS DROIT (PLANCHE). DESCENDS TA POITRINE VERS LE SOL ET POUSSE. PROGRESSION : COMMENCE SUR LES GENOUX OU CONTRE UN MUR/BANC. QUAND TU PEUX FAIRE 10-12 RÉPÉTITIONS SUR LES GENOUX FACILEMENT, ESSAIE SUR LES PIEDS AVEC LES MAINS SUR UN BANC/STEP, PUIS AU SOL.", type: "chest" },
                            { name: "LAT PULLDOWN (POULIE HAUTE)", desc: "3-4 SÉRIES DE 10-15 RÉPÉTITIONS. CONSIGNE MACHINE : ASSIEDS-TOI, SAISIS LA BARRE AVEC UNE PRISE LARGE. TIRE LA BARRE VERS TA POITRINE, EN CONTRACTANT LE DOS. POIDS SUGGÉRÉ MACHINE : COMMENCE AVEC 25-35 KG (AJUSTE PAR PALIERS DE 2.5KG OU 5KG SI DISPONIBLE).", type: "back" },
                            { name: "DÉVELOPPÉ COUCHÉ HALTÈRES OU PEC DECK", desc: "3-4 SÉRIES DE 10-15 RÉPÉTITIONS. CONSIGNE HALTÈRES (SUR BANC) : ALLONGÉ, UN HALTÈRE DANS CHAQUE MAIN AU NIVEAU DE LA POITRINE. POUSSE LES HALTÈRES VERS LE HAUT EN CONTRÔLANT LA DESCENTE. POIDS SUGGÉRÉ HALTÈRES : COMMENCE AVEC 6-10 KG PAR MAIN. CONSIGNE PEC DECK : ASSIEDS-TOI, SAISIS LES POIGNÉES. POUSSE VERS L'AVANT EN CONTRACTANT LA POITRINE. POIDS SUGGÉRÉ PEC DECK : COMMENCE AVEC 15-25 KG (AJUSTE PAR PALIERS DE 2.5KG OU 5KG).", type: "chest" },
                            { name: "FENTES (LUNGES)", desc: "3 SÉRIES DE 8-12 RÉPÉTITIONS PAR JAMBE. CONSIGNE : FAIS UN GRAND PAS EN AVANT, DESCENDS LE GENOU ARRIÈRE VERS LE SOL (SANS LE TOUCHER). GARDE LE CORPS DROIT. REMONTE EN POUSSANT SUR LA JAMBE AVANT. POIDS SUGGÉRÉ : COMMENCE AU POIDS DU CORPS. SI FACILE, UTILISE UN HALTÈRE DE 4-6 KG DANS CHAQUE MAIN.", type: "legs" },
                            { name: "ÉLÉVATIONS LATÉRALES (HALTÈRES)", desc: "3 SÉRIES DE 12-15 RÉPÉTITIONS. CONSIGNE : TIENS UN HALTÈRE LÉGER DANS CHAQUE MAIN, BRAS LE LONG DU CORPS. LÈVE LES BRAS SUR LES CÔTÉS, LÉGÈREMENT FLÉCHIS, JUSQU'À L'HORIZONTAL. POIDS SUGGÉRÉ : COMMENCE AVEC 2-4 KG PAR MAIN.", type: "shoulders" },
                            { name: "PLANCHE (PLANK)", desc: "3 SÉRIES DE 30-60 SECONDES DE MAINTIEN. CONSIGNE : SUR LES AVANT-BRAS ET LES POINTES DE PIEDS (OU SUR LES GENOUX SI TROP DIFFICILE), GARDE TON CORPS DROIT ET CONTRACTÉ COMME UNE PLANCHE. RÉCUPÉRATION : 60 SECONDES ENTRE LES SÉRIES.", type: "core" }
                        ]
                    },
                    cardio: {
                        name: "SÉANCE TYPE : CARDIO (ENDURANCE, FRACTIONNÉ OU MIXTE)",
                        options: [
                            {
                                name: "TAPIS DE COURSE (FRACTIONNÉ)",
                                desc: "RONDE 1 (15 MINUTES) : RÉPÈTE 5 FOIS : 2 MINUTES : MARCHE RAPIDE À 6.0 KM/H, PENTE 2.0. 1 MINUTE : COURSE LÉGÈRE À 8.0 KM/H, PENTE 1.0. RÉCUPÉRATION ACTIVE (5 MINUTES) : MARCHE LENTE À 4.0 KM/H, PENTE 0.0. BOIS UN PEU D'EAU. RONDE 2 (15 MINUTES) : RÉPÈTE 5 FOIS : 2 MINUTES : MARCHE RAPIDE À 6.5 KM/H, PENTE 2.0. 1 MINUTE : COURSE LÉGÈRE À 8.5 KM/H, PENTE 1.0 (OU MARCHE RAPIDE INTENSE SI LA COURSE EST TROP DIFFICILE).",
                                type: "cardio"
                            },
                            {
                                name: "VÉLO STATIONNAIRE OU VÉLO ELLIPTIQUE (SYNCHRO) (FRACTIONNÉ)",
                                desc: "RONDE 1 (20 MINUTES) : RÉPÈTE 5 FOIS : 3 MINUTES : RYTHME MODÉRÉ, NIVEAU 5-7 (SENS UNE LÉGÈRE RÉSISTANCE, TU PEUX PARLER MAIS C'EST UN PEU DIFFICILE). 1 MINUTE : RYTHME PLUS INTENSE, NIVEAU 8-10 (TU ES ESSOUFFLÉ, TU NE PEUX PAS PARLER FACILEMENT). RÉCUPÉRATION ACTIVE (5 MINUTES) : RYTHME TRÈS FACILE, NIVEAU 3-4. BOIS UN PEU D'EAU. RONDE 2 (20 MINUTES) : RÉPÈTE 5 FOIS : 3 MINUTES : RYTHME MODÉRÉ, NIVEAU 6-8. 1 MINUTE : RYTHME PLUS INTENSE, NIVEAU 9-11 (OU LE MAXIMUM QUE TU PEUX SOUTENIR).",
                                type: "cardio"
                            },
                            {
                                name: "CARDIO & FONCTIONNEL MIXTE (MOINS INTENSE QU'UN HIIT)",
                                desc: "PARTIE 1 (20 MINUTES) : 10 MINUTES : TAPIS DE COURSE (MARCHE RAPIDE À 6.0 KM/H, PENTE 2.0) OU VÉLO/ELLIPTIQUE (NIVEAU 6). 10 MINUTES : ALTERNER 2 MINUTES DE MOUNTAIN CLIMBERS (RYTHME MODÉRÉ) ET 2 MINUTES DE JUMPING JACKS (RYTHME MODÉRÉ), RÉPÈTE 2 FOIS. RÉCUPÉRATION ACTIVE (5 MINUTES) : MARCHE LENTE À 4.0 KM/H, PENTE 0.0. BOIS UN PEU D'EAU. PARTIE 2 (15 MINUTES) : 10 MINUTES : TAPIS DE COURSE (MARCHE RAPIDE À 6.5 KM/H, PENTE 2.0) OU VÉLO/ELLIPTIQUE (NIVEAU 7). 5 MINUTES : MONTÉES DE GENOUX RAPIDES (RYTHME MODÉRÉ) OU KETTLEBELL SWING (4-6KG, 15 RÉPÉTITIONS).",
                                type: "cardio"
                            }
                        ]
                    },
                    hiit: {
                        name: "SÉANCE TYPE : HIIT (HIGH-INTENSITY INTERVAL TRAINING)",
                        desc: "DURÉE ESTIMÉE : 30-40 MINUTES. FRÉQUENCE : 1 À 2 FOIS PAR SEMAINE MAXIMUM POUR COMMENCER. ATTENTION : LE HIIT EST INTENSE. ÉCOUTE IMPÉRATIVEMENT TON CORPS. LES JOURS OÙ LA FATIGUE LIÉE À TA SEP EST PLUS PRÉSENTE, REMPLACE CETTE SÉANCE PAR DU CARDIO LÉGER OU DU REPOS ACTIF. CORPS DE SÉANCE (20-25 MINUTES) : STRUCTURE : RÉALISE 3 À 4 TOURS DU CIRCUIT SUIVANT. CHAQUE EXERCICE : 40 SECONDES D'EFFORT MAXIMAL, SUIVIES DE 20 SECONDES DE REPOS TOTAL. ENTRE CHAQUE TOUR COMPLET DU CIRCUIT : 1 MINUTE 30 DE REPOS ACTIF (MARCHE LÉGÈRE, HYDRATATION).",
                        exercises: [
                            { name: "BURPEES (MODIFIÉS)", desc: "DESCENDS EN SQUAT, POSE LES MAINS AU SOL, JETTE LES JAMBES EN ARRIÈRE POUR TE METTRE EN PLANCHE (SANS POMPE SI TU DÉBUTTES), RAMÈNE LES PIEDS ENTRE LES MAINS, RELÈVE-TOI.", type: "hiit" },
                            { name: "MOUNTAIN CLIMBERS", desc: "EN POSITION DE PLANCHE, RAMÈNE ALTERNATIVEMENT LES GENOUX VERS LA POITRINE, COMME SI TU 'COURAIS' SUR PLACE.", type: "hiit" },
                            { name: "JUMPING JACKS", desc: "SAUTE EN ÉCARTANT LES JAMBES ET EN LEVANT LES BRAS AU-DESSUS DE LA TÊTE, PUIS REVIENS EN POSITION INITIALE. (SI LES SAUTS SONT TROP INTENSES, FAIS UN PAS SUR LE CÔTÉ AVEC UN BRAS QUI MONTE, PUIS L'AUTRE).", type: "hiit" },
                            { name: "KETTLEBELL SWING", desc: "MOUVEMENT DE BALANCIER EN POUSSANT LES HANCHES VERS L'AVANT (PAS AVEC LES BRAS !). POIDS SUGGÉRÉ : 6-10 KG.", type: "hiit" },
                            { name: "FENTES SAUTÉES", desc: "SAUTE POUR CHANGER DE JAMBE EN L'AIR ET ATTERRIS EN FENTE AVEC L'AUTRE JAMBE DEVANT. MODIFICATION : SI LES SAUTS SONT TROP INTENSES, FAIS DES FENTES ALTERNÉES CLASSIQUES EN TE RELÈVANT RAPIDEMENT ENTRE CHAQUE.", type: "hiit" },
                            { name: "MONTÉES DE GENOUX RAPIDES", desc: "COURS SUR PLACE EN LEVANT LES GENOUX LE PLUS HAUT POSSIBLE, EN UTILISANT TES BRAS.", type: "hiit" }
                        ]
                    }
                }
            },
            phase2: {
                name: "PHASE 2 : PROGRAMME ALTERNATIF (POUR LES 4 À 6 SEMAINES SUIVANTES)",
                sessions: {
                    main: {
                        name: "SÉANCE TYPE : RENFORCEMENT MUSCULAIRE (FULL BODY) - ALTERNATIVE",
                        exercises: [
                            { name: "SOULEVÉ DE TERRE ROUMAIN (RDL HALTÈRES)", desc: "4 SÉRIES DE 10-15 RÉPÉTITIONS. CONSIGNE : TIENS UN HALTÈRE DANS CHAQUE MAIN, PIEDS LARGEUR DES HANCHES. DESCENDS LES HALTÈRES LE LONG DE TES JAMBES EN POUSSANT LES HANCHES VERS L'ARRIÈRE ET EN GARDANT LE DOS DROIT. POIDS SUGGÉRÉ (HALTÈRES) : COMMENCE AVEC 6-10 KG PAR MAIN.", type: "legs" },
                            { name: "TRACTIONS ASSISTÉES (MACHINE)", desc: "3-4 SÉRIES DE MAX DE RÉPÉTITIONS (AVEC UNE FORME CONTRÔLÉE). CONSIGNE : TIRE TON CORPS VERS LE HAUT JUSQU'À CE QUE TON MENTON DÉPASSE LA BARRE, EN CONTRACTANT LE DOS. ASSISTANCE : UTILISE LA MACHINE AVEC UN POIDS D'ASSISTANCE ÉLEVÉ, OU UN ÉLASTIQUE ÉPAIS. RÉDUIS L'ASSISTANCE AU FIL DES SEMAINES.", type: "back" },
                            { name: "PRESSE À CUISSES (LEG PRESS)", desc: "3-4 SÉRIES DE 10-15 RÉPÉTITIONS. CONSIGNE : POUSSE LA PLATEFORME EN ÉTENDANT LES JAMBES, SANS BLOQUER LES GENOUX. POIDS SUGGÉRÉ MACHINE : COMMENCE AVEC 40-60 KG (AJUSTE PAR PALIERS DE 2.5KG OU 5KG).", type: "legs" },
                            { name: "DÉVELOPPÉ ÉPAULES (SHOULDER PRESS HALTÈRES OU MACHINE)", desc: "3-4 SÉRIES DE 10-15 RÉPÉTITIONS. CONSIGNE HALTÈRES : ASSIS, UN HALTÈRE DANS CHAQUE MAIN AU NIVEAU DES ÉPAULES. POUSSE LES HALTÈRES VERS LE HAUT AU-DESSUS DE TA TÊTE. POIDS SUGGÉRÉ HALTÈRES : COMMENCE AVEC 4-8 KG PAR MAIN. POIDS SUGGÉRÉ MACHINE : COMMENCE AVEC 10-20 KG (AJUSTE PAR PALIERS DE 2.5KG OU 5KG).", type: "shoulders" },
                            { name: "ROWING PENCHÉ (HALTÈRES)", desc: "3 SÉRIES DE 10-15 RÉPÉTITIONS. CONSIGNE : TIENS UN HALTÈRE DANS CHAQUE MAIN, PENCHE LE BUSTE EN AVANT (DOS DROIT, GENOUX LÉGÈREMENT FLÉCHIS). TIRE LES HALTÈRES VERS TA POITRINE EN CONTRACTANT LES OMOPLATES. POIDS SUGGÉRÉ : COMMENCE AVEC 6-10 KG PAR MAIN.", type: "back" },
                            { name: "EXTENSIONS TRICEPS (POULIE HAUTE OU HALTÈRE)", desc: "3 SÉRIES DE 12-15 RÉPÉTITIONS. CONSIGNE POULIE : COUDES COLLÉS AU CORPS. POUSSE LA BARRE VERS LE BAS EN NE BOUGEANT QUE L'AVANT-BRAS. POIDS SUGGÉRÉ POULIE : COMMENCE AVEC 10-15 KG (AJUSTE PAR PALIERS DE 2.5KG OU 5KG). HALTÈRE (DERRIÈRE LA TÊTE) : TIENS UN HALTÈRE AVEC LES DEUX MAINS DERRIÈRE TA TÊTE, POUSSE VERS LE HAUT. POIDS SUGGÉRÉ HALTÈRE : 4-8 KG.", type: "arms" },
                            { name: "CRUNCHS (ABDOMINALS)", desc: "3 SÉRIES DE 15-20 RÉPÉTITIONS. CONSIGNE : LÈVE LES ÉPAULES DU SOL EN CONTRACTANT LES ABDOMINAUX, SANS TIRER SUR LA NUQUE. RÉCUPÉRATION : 30 SECONDES ENTRE LES SÉRIES.", type: "core" }
                        ]
                    },
                    cardio: {
                        name: "SÉANCE TYPE : CARDIO (ENDURANCE, FRACTIONNÉ OU MIXTE) - ALTERNATIVE",
                        options: [
                            {
                                name: "TAPIS DE COURSE (ENDURANCE À PENTE VARIABLE)",
                                desc: "5 MINUTES : MARCHE RAPIDE À 5.5 KM/H, PENTE 2.0. 3 MINUTES : MARCHE RAPIDE À 6.0 KM/H, PENTE 3.0. 2 MINUTES : COURSE LÉGÈRE À 7.5 KM/H, PENTE 1.0. RÉPÈTE CE CYCLE 4-5 FOIS POUR UN TOTAL DE 40-50 MINUTES. VARIANTE : POUR AUGMENTER L'INTENSITÉ, AUGMENTE LÉGÈREMENT LA VITESSE OU LA PENTE À CHAQUE CYCLE SI TU TE SENS BIEN.",
                                type: "cardio"
                            },
                            {
                                name: "RAMEUR (ROWING MACHINE) - INTERVAL TRAINING",
                                desc: "5 MINUTES : ÉCHAUFFEMENT LÉGER (RYTHME LENT, RÉSISTANCE FAIBLE). RONDE 1 (15 MINUTES) : RÉPÈTE 5 FOIS : 2 MINUTES : RYTHME MODÉRÉ, RÉSISTANCE 3-5 (EFFORT SOUTENU MAIS CONFORTABLE). 1 MINUTE : RYTHME INTENSE, RÉSISTANCE 6-7 (TU ES ESSOUFFLÉ, TU NE PEUX PAS PARLER FACILEMENT). RÉCUPÉRATION ACTIVE (5 MINUTES) : RYTHME TRÈS FACILE, RÉSISTANCE 2. BOIS UN PEU D'EAU. RONDE 2 (15 MINUTES) : RÉPÈTE 5 FOIS : 2 MINUTES : RYTHME MODÉRÉ, RÉSISTANCE 4-6. 1 MINUTE : RYTHME PLUS INTENSE, RÉSISTANCE 7-8 (OU LE MAXIMUM QUE TU PEUX SOUTENIR). CONSIGNE : UTILISE 60% DE LA FORCE DES JAMBES, 20% DU TRONC, 20% DES BRAS. POUSSE AVEC LES JAMBES EN PREMIER !",
                                type: "cardio"
                            },
                            {
                                name: "CARDIO & FONCTIONNEL MIXTE (ALTERNATIF)",
                                desc: "PARTIE 1 (20 MINUTES) : 10 MINUTES : RAMEUR (RYTHME MODÉRÉ, RÉSISTANCE 4-5) OU VÉLO ELLIPTIQUE (NIVEAU 6-7). 10 MINUTES : ALTERNER 2 MINUTES DE SQUAT (POIDS DU CORPS) (RYTHME MODÉRÉ) ET 2 MINUTES DE FENTES (LUNGES) ALTERNÉES (RYTHME MODÉRÉ), RÉPÈTE 2 FOIS. RÉCUPÉRATION ACTIVE (5 MINUTES) : RYTHME TRÈS FACILE, RÉSISTANCE 2. PARTIE 2 (15 MINUTES) : 10 MINUTES : TAPIS DE COURSE (COURSE LÉGÈRE À 7.0 KM/H, PENTE 1.0) OU VÉLO (NIVEAU 8). 5 MINUTES : BURPEES (MODIFIÉS) (RYTHME MODÉRÉ) OU CORDE À SAUTER (RYTHME MODÉRÉ).",
                                type: "cardio"
                            }
                        ]
                    },
                    hiit: {
                        name: "SÉANCE TYPE : HIIT (HIGH-INTENSITY INTERVAL TRAINING) - ALTERNATIVE",
                        desc: "DURÉE ESTIMÉE : 30-40 MINUTES. FRÉQUENCE : 1 À 2 FOIS PAR SEMAINE MAXIMUM. ATTENTION : LE HIIT EST INTENSE. ÉCOUTE IMPÉRATIVEMENT TON CORPS. LES JOURS OÙ LA FATIGUE LIÉE À TA SEP EST PLUS PRÉSENTE, REMPLACE CETTE SÉANCE PAR DU CARDIO LÉGER OU DU REPOS ACTIF. CORPS DE SÉANCE (20-25 MINUTES) : STRUCTURE : RÉALISE 3 À 4 TOURS DU CIRCUIT SUIVANT. CHAQUE EXERCICE : 45 SECONDES D'EFFORT INTENSE, SUIVIES DE 15 SECONDES DE REPOS TOTAL. (LÉGÈRE AUGMENTATION DE L'EFFORT/DIMINUTION DU REPOS PAR RAPPORT À LA PREMIÈRE PHASE). ENTRE CHAQUE TOUR COMPLET DU CIRCUIT : 1 MINUTE 15 DE REPOS ACTIF (MARCHE LÉGÈRE, HYDRATATION).",
                        exercises: [
                            { name: "BURPEES (AVEC POMPE)", desc: "FAIS UN BURPEE COMPLET, EN INCLUANT UNE POMPE (SUR LES GENOUX SI BESOIN) LORSQUE TU ES EN POSITION DE PLANCHE.", type: "hiit" },
                            { name: "BOX JUMPS OU STEP-UPS", desc: "SAUTE SUR UNE BOÎTE BASSE (OU UN STEP) ET DESCENDS. SI LES SAUTS SONT UN PROBLÈME : FAIS DES STEP-UPS RAPIDES (MONTE ET DESCENDS DU BANC UNE JAMBE APRÈS L'AUTRE).", type: "hiit" },
                            { name: "CORDE À SAUTER", desc: "SAUTE À LA CORDE. VARIE LES SAUTS (PIEDS JOINTS, ALTERNÉS). SI PAS DE CORDE OU TROP DIFFICILE : FAIS DES SAUTS SUR PLACE LÉGERS OU DES PAS CHASSÉS RAPIDES.", type: "hiit" },
                            { name: "KETTLEBELL GOBLET SQUAT (EXPLOSIF)", desc: "TIENS UN KETTLEBELL DEVANT TA POITRINE. FAIS UN SQUAT COMPLET ET REMONTE DE MANIÈRE EXPLOSIVE. POIDS SUGGÉRÉ : 8-12 KG.", type: "hiit" },
                            { name: "MOUNTAIN CLIMBERS CROISÉS", desc: "EN POSITION DE PLANCHE, RAMÈNE LE GENOU DROIT VERS LE COUDE GAUCHE, PUIS LE GENOU GAUCHE VERS LE COUDE DROIT, EN ALTERNANCE RAPIDE.", type: "hiit" },
                            { name: "SAUTS LATÉRAUX (LATERAL JUMPS)", desc: "SAUTE DE DROITE À GAUCHE RAPIDEMENT AU-DESSUS D'UNE LIGNE IMAGINAIRE OU D'UN PETIT OBJET.", type: "hiit" }
                        ]
                    }
                }
            },
            recovery: {
                name: "JOURNÉE DE RÉCUPÉRATION ACTIVE / FLEXIBILITÉ (OPTIONNEL)",
                desc: "EN PLUS DE TES JOURS DE REPOS COMPLETS, TU PEUX DÉDIER UNE JOURNÉE PAR SEMAINE À UNE ACTIVITÉ DOUCE POUR LA RÉCUPÉRATION ET LA SOUPLESSE.",
                activities: [
                    { name: "MARCHE PROLONGÉE", desc: "DANS UN PARC, EN NATURE, À UN RYTHME AGRÉABLE (45-60 MIN)." },
                    { name: "SÉANCE DE YOGA DOUX OU DE PILATES", desc: "PRIVILÉGIE LES VIDÉOS EN LIGNE POUR DÉBUTANTS AXÉES SUR LA FLEXIBILITÉ ET LE RENFORCEMENT DU TRONC." },
                    { name: "ÉTIREMENTS PROFONDS", desc: "UNE SÉANCE DÉDIÉE DE 20-30 MINUTES POUR ÉTIRER TOUS LES GRANDS GROUPES MUSCULAIRES, EN MAINTENANT LES POSITIONS PLUS LONGTEMPS (30-60 SEC)." },
                    { name: "NATATION LÉGÈRE", desc: "QUELQUES LONGUEURS À RYTHME TRANQUILLE POUR DÉTENDRE LES MUSCLES." }
                ]
            }
        };

        // Fonctions utilitaires pour la persistance des données dans le localStorage
        function saveToLocalStorage(key, data) { try { localStorage.setItem(key, JSON.stringify(data)); console.log(`[LocalStorage] Données sauvegardées pour '${key}'.`); } catch (e) { console.error(`[LocalStorage] Erreur lors de la sauvegarde pour '${key}':`, e); showMessage(`ERREUR: Impossible de sauvegarder ${key}.`, 'error'); } }
        function loadFromLocalStorage(key, defaultValue) { try { const data = localStorage.getItem(key); return data ? JSON.parse(data) : defaultValue; } catch (e) { console.error(`[LocalStorage] Erreur lors du chargement pour '${key}':`, e); showMessage(`ATTENTION: Données corrompues pour ${key}. Chargement par défaut.`, 'warning'); return defaultValue; } }
        function removeFromLocalStorage(key) { try { localStorage.removeItem(key); console.log(`[LocalStorage] Données supprimées pour '${key}'.`); } catch (e) { console.error(`[LocalStorage] Erreur lors de la suppression pour '${key}':`, e); showMessage(`ERREUR: Impossible de supprimer ${key}.`, 'error'); } }

        // Initialisation de l'état global de l'application au démarrage
        function initializeGlobalState() {
            console.log("[INITIALISATION] Chargement de l'état global depuis le localStorage...");
            userProfile = loadFromLocalStorage('userProfile', { height: '', weight: '', imc: null, imcCategory: '', proteinNeeds: 'N/A', currentXP: 0, earnedTrophies: [], hideExerciseHistory: false, apiKey: '', likedMeals: [] });
            if (!Array.isArray(userProfile.likedMeals)) {
                userProfile.likedMeals = [];
                console.warn("[INITIALISATION] likedMeals n'était pas un tableau, réinitialisation.");
            } else {
                userProfile.likedMeals = userProfile.likedMeals.map(meal => {
                    return {
                        id: meal.id || generateUniqueId(),
                        mealType: meal.mealType || null,
                        dayContext: meal.dayContext || { poste: 'unknown', sport: 'unknown' },
                        ...meal
                    };
                });
            }

            weeklyMealPlan = loadFromLocalStorage('weeklyMealPlan', { semaine: [] });
            workoutLogs = loadFromLocalStorage('workoutLogs', []);
            weightHistory = loadFromLocalStorage('weightHistory', []);
            intervalSequences = loadFromLocalStorage('intervalSequences', []);
            shifts = loadFromLocalStorage('shifts', []);
            workoutProgram = loadFromLocalStorage('savedWorkoutProgram', JSON.parse(JSON.stringify(defaultWorkoutProgramStructure)));
            previousLevel = calculateLevelAndXP(userProfile.currentXP).level;
            const savedChronoState = loadFromLocalStorage('chronoState', {});
            chronoIntervals = savedChronoState.intervals || [];
            chronoCurrentTime = savedChronoState.currentTime || 0;
            chronoCurrentIntervalIndex = savedChronoState.currentIntervalIndex !== undefined ? savedChronoState.currentIntervalIndex : -1;
            isChronoRunning = savedChronoState.isRunning || false;
            isChronoPaused = savedChronoState.isPaused || false;
            enableChronoPreCountdown = savedChronoState.enablePreCountdown !== undefined ? savedChronoState.enablePreCountdown : true;
            chronoPreCountdownDuration = savedChronoState.preCountdownDuration || 10;
            if (!Array.isArray(userProfile.earnedTrophies)) { userProfile.earnedTrophies = []; console.warn("[INITIALISATION] earnedTrophies n'était pas un tableau, réinitialisation."); }

            console.log("[INITIALISATION] État global chargé.");
        }

        // Met à jour l'état du chronomètre dans le localStorage
        function updateLocalStorageChronoState() { saveToLocalStorage('chronoState', { intervals: chronoIntervals, currentTime: chronoCurrentTime, currentIntervalIndex: chronoCurrentIntervalIndex, isRunning: isChronoRunning, isPaused: isChronoPaused, enablePreCountdown: enableChronoPreCountdown, preCountdownDuration: chronoPreCountdownDuration }); }

        // Affiche un message de notification à l'utilisateur
        function showMessage(msg, type = 'info') {
            const container = document.getElementById('notification-container-bottom-right');
            const notification = document.createElement('div');
            notification.className = `notification general ${type}`;
            const iconMap = { 'success': '🎉', 'error': '❌', 'warning': '⚠️', 'info': 'ℹ️', 'chrono': '⏱️', 'tip': '💡' };
            notification.innerHTML = `<span class="text-2xl">${iconMap[type] || 'ℹ️'}</span><p class="font-bold text-sm sm:text-base">${String(msg).toUpperCase()}</p>`;
            container.appendChild(notification);
            void notification.offsetWidth;
            notification.classList.add('show');
            const duration = type === 'trophy' ? 12000 : (type === 'tip' ? 20000 : 5000);
            setTimeout(() => { notification.classList.remove('show'); notification.addEventListener('transitionend', () => notification.remove(), { once: true }); }, duration);
        }

        // Affiche une notification de trophée débloqué
        function showTrophyNotification(trophyName, description) {
            const container = document.getElementById('notification-container-bottom-right');
            const notification = document.createElement('div');
            notification.className = 'notification general success';
            notification.innerHTML = `<span class="text-4xl">🏆</span><div><p class="font-bold text-lg sm:text-xl">TROPHÉE DÉBLOQUÉ !</p><p class="text-yellow-300 text-sm sm:text-base">${String(trophyName).toUpperCase()}</p><p class="text-gray-200 text-xs sm:text-sm">${String(description).toUpperCase()}</p></div>`;
            container.appendChild(notification);
            playTrophySound();
            void notification.offsetWidth;
            setTimeout(() => {
                notification.classList.add('show');
            }, 100);
            setTimeout(() => { notification.classList.remove('show'); notification.addEventListener('transitionend', () => notification.remove(), { once: true }); }, 12000);
        }

        // Gestion du contexte audio pour les effets sonores
        let audioContextStartedOnce = false;
        async function initializeAudioContextNonBlocking() {
            if (Tone.context.state === 'running' || audioContextStartedOnce) return;
            try {
                await Tone.start();
                audioContextStartedOnce = true;
                isAudioActive = true;
                Tone.Master.mute = false;
                Tone.Master.volume.value = masterVolume === 0 ? -Infinity : 20 * Math.log10(masterVolume);
                document.getElementById('audio-inactive-message').classList.add('hidden');
            } catch (e) {
                isAudioActive = false;
                Tone.Master.mute = true;
                document.getElementById('audio-inactive-message').classList.remove('hidden');
                document.getElementById('audio-inactive-message').textContent = "AUDIO DÉSACTIVÉ. CLIQUEZ OU APPUYEZ SUR UNE TOUCHE POUR ACTIVER LE SON ET LA SYNTHÈSE VOCALE.";
            }
        }

        // Gère le geste de l'utilisateur pour démarrer l'audio
        function handleUserGestureToStartAudio() { window.removeEventListener('click', handleUserGestureToStartAudio); window.removeEventListener('keydown', handleUserGestureToStartAudio); initializeAudioContextNonBlocking(); }

        // Configure les lecteurs audio pour les sons de l'application
        function setupAudioPlayers() {
            trophySoundPlayer = new Tone.PolySynth(Tone.Synth, { oscillator: { type: "square" }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.3 } }).toDestination();
            levelUpPlayer = new Tone.PolySynth(Tone.Synth, { oscillator: { type: "triangle" }, envelope: { attack: 0.005, decay: 0.05, sustain: 0.1, release: 0.2 } }).toDestination();
            majorLevelUpPlayer = new Tone.PolySynth(Tone.Synth, { oscillator: { type: "sawtooth" }, envelope: { attack: 0.01, decay: 0.3, sustain: 0.2, release: 0.6 }, volume: -6 }).toDestination();
            beepPlayer = new Tone.Oscillator(440, "sine").toDestination();
            startSoundPlayer = new Tone.PolySynth(Tone.Synth).toDestination();
            synth = window.speechSynthesis;
            Tone.Master.volume.value = masterVolume === 0 ? -Infinity : 20 * Math.log10(masterVolume);
            Tone.Master.mute = !isAudioActive;
        }

        // Active ou désactive le son de l'application
        function toggleAudioActive() {
            isAudioActive = !isAudioActive;
            if (isAudioActive) { initializeAudioContextNonBlocking(); showMessage("SON ACTIVÉ !", "success"); }
            else { Tone.Master.mute = true; showMessage("SON DÉSACTIVÉ.", "info"); }
            const mainContent = document.getElementById('main-content');
            renderOptionsView(mainContent);
        }

        // Joue le son de trophée
        function playTrophySound() { if (isAudioActive && Tone.context.state === 'running') { trophySoundPlayer.triggerAttackRelease(["C5", "E5", "G5", "C6"], "8n", Tone.context.currentTime); } }

        // Joue le son de montée de niveau
        function playLevelUpSound(level) {
            if (isAudioActive && Tone.context.state === 'running') {
                const now = Tone.context.currentTime;
                if (level > previousLevel) {
                    if (level % 10 === 0) { majorLevelUpPlayer.triggerAttackRelease(["C4", "E4", "G4", "C5", "E5"], "2n", now); }
                    else { levelUpPlayer.triggerAttackRelease("C4", "16n", now); levelUpPlayer.triggerAttackRelease("E4", "16n", now + 0.1); levelUpPlayer.triggerAttackRelease("G4", "16n", now + 0.2); levelUpPlayer.triggerAttackRelease("C5", "8n", now + 0.3); }
                }
            }
        }

        // Joue un bip sonore
        function playBeep(freq = 4, duration = 0.0) { if (isAudioActive && Tone.context.state === 'running') { beepPlayer.stop(); beepPlayer.start(Tone.context.currentTime); beepPlayer.frequency.setValueAtTime(freq, Tone.context.currentTime); beepPlayer.stop(Tone.context.currentTime + duration); } }

        // Joue un son de démarrage (type Mario Kart)
        function playMarioKartStartSound() {
            if (isAudioActive && Tone.context.state === 'running') {
                const now = Tone.context.currentTime;
                new Tone.MembraneSynth().toDestination().triggerAttackRelease("C5", "16n", now);
                new Tone.MembraneSynth().toDestination().triggerAttackRelease("E5", "16n", now);
                new Tone.MembraneSynth().toDestination().triggerAttackRelease("G5", "16n", now);
                new Tone.Synth().toDestination().triggerAttackRelease("C4", "1n", now );
            }
        }

        // Fait parler l'IA avec la synthèse vocale
        function speak(text) { if (isAudioActive) { if (synth) { synth.cancel(); const utterance = new SpeechSynthesisUtterance(text); utterance.lang = 'fr-FR'; synth.speak(utterance); } } }

        // Génère un identifiant unique
        function generateUniqueId() { return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => { const r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8); return v.toString(16); }); }

        // Formate une date au format YYYY-MM-DD
        function formatDateToYYYYMMDD(date) { if (!(date instanceof Date) || isNaN(date.getTime())) return ''; const year = date.getFullYear(); const month = String(date.getMonth() + 1).padStart(2, '0'); const day = String(date.getDate()).padStart(2, '0'); return `${year}-${month}-${day}`; }

        // Retourne une chaîne de caractères décrivant le contexte du jour (poste et sport)
        function getDayContextString(shiftType, workoutType) {
            let context = "";
            const sType = String(shiftType || ''), wType = String(workoutType || '');
            switch (sType) {
                case '6h-18h': context = "Travail de Jour (6H-18H)"; break;
                case '7h-18h': context = "Travail de Jour (7H-18H)"; break;
                case '18h-6h': context = "Travail de Nuit (18H-6H)"; break;
                case 'repos': context = "Jour de Repos"; break;
                case 'repos_sport': context = "Jour de Repos (SPORT)"; break;
                default: context = "Contexte Inconnu"; break;
            }
            if (wType && wType !== 'aucun') { context += ` - Sport: ${wType.toUpperCase().replace('_', ' ')}`; }
            return context;
        }

        // Retourne une chaîne de caractères décrivant le moment du repas dans le contexte du jour
        function getMealMomentContext(mealType, shiftType, sportType) {
            let moment = "";
            const sType = String(shiftType || ''), spType = String(sportType || '');
            if (mealType === 'petit_dejeuner') { moment = "PETIT-DÉJEUNER"; if (sType === '18h-6h') moment += " POST-NUIT"; else if (spType !== 'aucun') moment += " PRÉ-ENTRAÎNEMENT"; }
            else if (mealType === 'dejeuner') { moment = "DÉJEUNER"; if (sType === '18h-6h') moment += " PENDANT LE POSTE DE NUIT"; else if (spType !== 'aucun') moment += " POST-ENTRAÎNEMENT"; else if (sType.includes('jour')) moment += " JOURNÉE DE TRAVAIL"; }
            else if (mealType === 'diner') { moment = "DÎNER"; if (sType === '18h-6h') moment += " PRÉ-POSTE DE NUIT"; else if (spType !== 'aucun') moment += " POST-ENTRAÎNEMENT"; else if (sType.includes('jour')) moment += " APRÈS JOURNÉE DE TRAVAIL"; }
            else if (mealType === 'collation_matin') { moment = "COLLAT. MATIN"; }
            else if (mealType === 'collation_apresmidi') { moment = "COLLAT. APRÈS-MIDI"; }
            else if (mealType === 'collation_unique') { if (sType === '18h-6h') moment = "COLLAT. PENDANT POSTE DE NUIT"; else if (sType === '7h-18h') moment = "COLLAT. APRÈS-MIDI"; else if (spType !== 'aucun') moment = "COLLAT. POST-SPORT"; else if (sType.includes('repos')) moment = "COLLAT. LÉGÈRE"; }
            return moment;
        }

        // Conseils spécifiques pour les repas en fonction du contexte
        const specificMealAdvice = {
            'petit_dejeuner': { '18h-6h': "CONSEIL : APRÈS UN POSTE DE NUIT, PRIVILÉGIE UN REPAS NUTRITIF POUR FAVORISER LA RÉCUPÉRATION ET UN SOMMEIL DE QUALITÉ. LES PROTÉINES ET GLUCIDES LENTS SONT CLÉS.", 'default': "CONSEIL : UN PETIT-DÉJEUNER ÉQUILIBRÉ EST ESSENTIEL POUR L'ÉNERGIE DU MATIN. VARIE LES SOURCES DE PROTÉINES ET FIBRES." },
            'dejeuner': { '18h-6h': "CONSEIL : PENDANT UN POSTE DE NUIT, OPTE POUR DES PLATS FACILES À DIGÉRER, RICHES EN PROTÉINES ET LÉGUMES POUR MAINTENIR TON ÉNERGIE SANS ALOURDIR.", 'repos_sport': "CONSEIL : APRÈS LE SPORT, RECONSTITUE TES RÉSERVES. CE REPAS DEVRAIT ÊTRE RICHE EN GLUCIDES COMPLEXES POUR L'ÉNERGIE ET EN PROTÉINES POUR LA RÉPARATION MUSCULAIRE.", 'default': "CONSEIL : POUR UN DÉJEUNER OPTIMAL EN JOURNÉE DE TRAVAIL, PRIVILÉGIE UN PLAT ÉQUILIBRÉ QUI APPORTE UNE ÉNERGIE DURABLE SANS CAUSER DE COUP DE BARRE." },
            'diner': { '18h-6h': "CONSEIL : AVANT UN POSTE DE NUIT, CHOISIS UN DÎNER CONSISTANT MAIS FACILE À DIGÉRER POUR TE DONNER L'ÉNERGIE NÉCESSAIRE SANS PERTURBER TON DÉBUT DE SOMMEIL PRÉ-POSTE.", 'repos_sport': "CONSEIL : LE DÎNER APRÈS UNE SÉANCE DE SPORT DOIT COMPLÉTER LA RÉCUPÉRATION. CONCENTRE-TOI SUR LES PROTÉINES POUR LA RÉPARATION ET LES GLUCIDES POUR REFAIRE LE PLEIN.", 'default': "CONSEIL : UN DÎNER LÉGER EST IDÉAL POUR FAVORISER UNE BONNE DIGESTION ET UN SOMMEIL RÉPARATEUR APRÈS UNE JOURNÉE DE TRAVAIL. PRIVILÉGIE LES LÉGUMES ET PROTÉINES MAIGRES." },
            'collation': { '6h-18h_matin': "CONSEIL : CETTE COLLATON MATINALE EST CLÉ POUR MAINTENIR TON ÉNERGIE ET ÉVITER LES BAISSES DE GLYCÉMIE JUSQU'AU DÉJEUNER.", '6h-18h_apresmidi': "CONSEIL : LA COLLATON DE L'APRÈS-MIDI AIDE À GÉRER LA FAIM ET À SOUTENIR TON ÉNERGIE JUSQU'AU DÎNER, SANS ALOURDIR AVANT LA FIN DU POSTE.", '18h-6h_pendant': "CONSEIL : UNE COLLATON PENDANT LA NUIT EST LÉGÈRE ET ÉNERGISANTE POUR MAINTENIR TA VIGILANCE SANS PERTURBER TA DIGESTION.", '7h-18h_apresmidi': "CONSEIL : LA COLLATON DE L'APRÈS-MIDI EST PARFAITE POUR SOUTENIR SON ÉNERGIE LORS DES JOURS DE LONG POSTE OU DE REPOS ACTIF.", 'repos_sport_post': "CONSEIL : UNE COLLATON POST-SPORT EST CRUCIALE POUR UNE RÉCUPÉRATION RAPIDE. PRIVILÉGIE UN MIX DE PROTÉINES ET GLUCIDES.", 'repos_default': "CONSEIL : UNE COLLATON LÉGÈRE EN JOUR DE REPOS PEUT AIDER À GÉRER LA FAIM ET APPORTER DES NUTRIENTS SUPPLÉMENTAIRES." }
        };

        // Calcule les seuils d'XP pour chaque niveau
        function getLevelThresholds(level) {
            if (level === 0) return { current: 0, next: 100 };
            let xp = 0;
            for (let i = 1; i <= level; i++) {
                xp += (i * 50 + 50);
            }
            const prevLevelThreshold = xp - (level * 50 + 50);
            return { current: prevLevelThreshold, next: xp };
        }

        // Calcule le niveau actuel et l'XP restante pour le niveau suivant
        function calculateLevelAndXP(totalXP) {
            let level = 0;
            let xpNeededForCurrentLevel = 0;
            let xpNeededForNextLevel = 100;

            while (totalXP >= xpNeededForNextLevel) {
                level++;
                xpNeededForCurrentLevel = xpNeededForNextLevel;
                xpNeededForNextLevel = Math.round(100 + (level * 50 * (1 + level / 10)));
            }

            const xpProgressInCurrentLevel = totalXP - xpNeededForCurrentLevel;
            const xpForThisLevel = xpNeededForNextLevel - xpNeededForCurrentLevel;
            const xpRemainingForNextLevel = xpForThisLevel - xpProgressInCurrentLevel;

            return { level: level, xpCurrentLevel: xpProgressInCurrentLevel, xpForThisLevel: xpForThisLevel, xpToNextLevel: xpRemainingForNextLevel };
        }

        // Initialise l'application au démarrage
        async function initializeApp() {
            isLoadingApp = true;
            renderLoadingScreen();
            let currentLoadProgress = 0;
            const updateProgress = (target) => {
                const diff = target - currentLoadProgress;
                const step = diff / 10;
                const interval = setInterval(() => {
                    currentLoadProgress += step;
                    if (currentLoadProgress >= target) { clearInterval(interval); }
                    loadingProgress = Math.min(100, Math.floor(currentLoadProgress));
                    document.getElementById('loading-progress-bar').style.width = `${loadingProgress}%`;
                    document.getElementById('loading-progress-text').textContent = `${loadingProgress}% CHARGEMENT...`;
                }, 50);
            };

            try {
                updateProgress(20);
                setupAudioPlayers();
                updateProgress(40);
                initializeGlobalState();
                updateXPBar();
                updateProfileDisplay();
                updateProgress(60);
                userId = 'local_user';
                document.getElementById('user-id-value').textContent = userId;
                document.getElementById('user-id-display').classList.remove('hidden');
                renderPage(currentPage);
                attachEventListeners();
                renderLucideIcons();
                updateProgress(80);
                window.addEventListener('click', handleUserGestureToStartAudio, { once: true });
                window.addEventListener('keydown', handleUserGestureToStartAudio, { once: true });
                initializeAudioContextNonBlocking();
                updateProgress(100);
            } catch (error) { console.error("Échec de l'initialisation de l'application :", error); showMessage(`ERREUR D'INITIALISATION: ${error.message}`, 'error'); }
            finally {
                setTimeout(() => {
                    isLoadingApp = false;
                    document.getElementById('loading-screen').classList.add('hidden');
                    document.getElementById('app-container').classList.remove('hidden');
                    if (!isAudioActive && Tone.context.state !== 'running') { document.getElementById('audio-inactive-message').classList.remove('hidden'); document.getElementById('audio-inactive-message').textContent = "AUDIO DÉSACTIVÉ. CLIQUEZ OU APPUYEZ SUR UNE TOUCHE POUR ACTIVER LE SON ET LA SYNTHÈSE VOCALE."; }
                    else if (isAudioActive && Tone.context.state === 'running') { document.getElementById('audio-inactive-message').classList.add('hidden'); }
                }, 1000);
            }
        }

        // Affiche l'écran de chargement
        function renderLoadingScreen() {
            document.getElementById('loading-progress-bar').style.width = `${loadingProgress}%`;
            document.getElementById('loading-progress-text').textContent = `${loadingProgress}% CHARGEMENT...`;
            const audioInactiveMessage = document.getElementById('audio-inactive-message');
            if (audioInactiveMessage) { audioInactiveMessage.classList.toggle('hidden', isAudioActive || loadingProgress < 100); }
        }

        // Rend la page principale en fonction du nom de la page
        function renderPage(pageName) {
            const mainContent = document.getElementById('main-content');
            mainContent.innerHTML = '';
            if (weightChartInstance) { weightChartInstance.destroy(); weightChartInstance = null; }
            if (exerciseChartInstance) { exerciseChartInstance.destroy(); exerciseChartInstance = null; }

            document.querySelectorAll('.nav-item').forEach(button => {
                const isActive = button.dataset.page === pageName;
                button.classList.toggle('bg-blue-600', isActive);
                button.classList.toggle('text-white', isActive);
                button.classList.toggle('font-semibold', isActive);
                button.classList.toggle('border-blue-800', isActive);
                button.classList.toggle('shadow-inner', isActive);
                button.classList.toggle('text-gray-200', !isActive);
                button.classList.toggle('hover:bg-gray-700', !isActive);
                button.classList.toggle('hover:text-yellow-300', !isActive);
                button.classList.toggle('border-gray-700', !isActive);
            });

            currentPage = pageName;

            switch (pageName) {
                case 'daily_plan': renderDailyPlanView(mainContent); break;
                case 'workout': renderWorkoutView(mainContent); break;
                case 'recipes': renderRecipeView(mainContent); break;
                case 'chrono': renderChronoIntervalleView(mainContent); break;
                case 'progress': renderProgressView(mainContent); break;
                case 'trophies': renderTrophyRoomView(mainContent); break;
                case 'options': renderOptionsView(mainContent); break;
                default: renderDailyPlanView(mainContent); break;
            }
            renderLucideIcons();
        }

        // Met à jour la barre d'expérience (XP) et le niveau de l'utilisateur
        function updateXPBar() {
            const { level, xpCurrentLevel, xpForThisLevel } = calculateLevelAndXP(userProfile.currentXP);
            const progressBar = document.getElementById('xp-bar-fill');
            const progressText = document.getElementById('xp-bar-text');

            const progressPercentage = xpForThisLevel > 0 ? (xpCurrentLevel / xpForThisLevel) * 100 : 0;
            const actualProgress = Math.max(0, Math.min(100, progressPercentage));

            if (level > previousLevel) {
                playLevelUpSound(level);
                showMessage(`FÉLICITATIONS, VOUS AVEZ ATTEINT LE NIVEAU ${level} !`, 'success');
                speak(`Felicitations, vous avez atteint le niveau ${level} !`);
                progressBar.style.transition = 'none';
                progressBar.style.width = '0%';
                void progressBar.offsetWidth;
                setTimeout(() => { progressBar.style.transition = 'width 0.5s ease-in-out, background 0.5s ease-in-out'; progressBar.style.width = `${actualProgress}%`; }, 150);
            } else {
                progressBar.style.transition = 'width 0.5s ease-in-out, background 0.5s ease-in-out';
                progressBar.style.width = `${actualProgress}%`;
            }
            progressText.textContent = `LVL ${level} : ${xpCurrentLevel}/${xpForThisLevel} XP`;
            previousLevel = level;
            checkAndAwardTrophies(level);
        }

        // Vérifie si des trophées ont été gagnés et les attribue
        function checkAndAwardTrophies(currentLevel) {
            let earnedTrophies = userProfile.earnedTrophies || [], newTrophiesEarned = [];
            allTrophies.forEach(trophy => {
                if (currentLevel >= trophy.levelRequired && !earnedTrophies.some(t => t.id === trophy.id)) {
                    newTrophiesEarned.push(trophy);
                    earnedTrophies.push({ id: trophy.id, name: trophy.name, description: trophy.description, levelRequired: trophy.levelRequired, timestamp: new Date().toISOString() });
                }
            });
            if (newTrophiesEarned.length > 0) {
                userProfile.earnedTrophies = earnedTrophies;
                saveToLocalStorage('userProfile', userProfile);
                newTrophiesEarned.forEach(trophy => showTrophyNotification(trophy.name, trophy.description));
                if (currentPage === 'trophies') renderTrophyRoomView(document.getElementById('main-content'));
            }
        }

        // Met à jour l'affichage du profil utilisateur
        function updateProfileDisplay() {
            const heightInput = document.getElementById('userHeight'), weightInput = document.getElementById('userWeight'), imcDisplay = document.getElementById('imc-display'), imcValue = document.getElementById('imc-value'), imcCategory = document.getElementById('imc-category'), proteinNeeds = document.getElementById('protein-needs');
            heightInput.value = userProfile.height;
            weightInput.value = userProfile.weight;
            if (userProfile.imc && userProfile.imcCategory && userProfile.proteinNeeds) {
                imcValue.textContent = userProfile.imc;
                imcCategory.textContent = userProfile.imcCategory;
                proteinNeeds.textContent = `${userProfile.proteinNeeds} G/JOUR`;
                imcDisplay.classList.remove('hidden');
            } else {
                imcDisplay.classList.add('hidden');
            }
        }

        // Gère la sauvegarde du profil utilisateur (taille, poids, IMC)
        async function handleSaveProfile() {
            const height = document.getElementById('userHeight').value, weight = document.getElementById('userWeight').value;
            if (!height || !weight) { showMessage("ERREUR: TAILLE ET POIDS REQUIS POUR L'IMC.", 'error'); return; }
            const currentHeight = parseFloat(height), currentWeight = parseFloat(weight), currentImc = (currentWeight / ( (currentHeight / 100) * (currentHeight / 100) )).toFixed(2);
            let currentImcCategory;
            const imcVal = parseFloat(currentImc);
            const imcCategories = [
                { threshold: 16.5, category: 'INSUFFISANCE PONDÉRALE (DÉNUTRITION SÉVÈRE)' },
                { threshold: 18.5, category: 'INSUFFISANCE PONDÉRALE' },
                { threshold: 25, category: 'POIDS NORMAL' },
                { threshold: 27, category: 'SURPOIDS (PRÉ-OBÉSITÉ)' },
                { threshold: 30, category: 'OBÉSITÉ CLASSE I' },
                { threshold: 35, category: 'OBÉSITÉ CLASSE II (SÉVÈRE)' },
                { threshold: 40, category: 'OBÉSITÉ CLASSE III (MORBIDE OU MASSIVE)' },
                { threshold: Infinity, category: 'OBÉSITÉ CLASSE III (MORBIDE OU MASSIVE)' }
            ];
            for (const cat of imcCategories) { if (imcVal < cat.threshold) { currentImcCategory = cat.category; break; } }
            const proteinMultiplier = 1.6, currentProteinNeeds = (currentWeight * proteinMultiplier).toFixed(0);
            let newXP = userProfile.currentXP;
            const oldWeight = parseFloat(userProfile.weight) || 0, oldImcCategory = userProfile.imcCategory || '';
            if (oldWeight > 0 && currentWeight !== oldWeight) {
                const weightDiff = oldWeight - currentWeight;
                const oldImcIndex = imcCategories.findIndex(c => c.category === oldImcCategory), currentImcIndex = imcCategories.findIndex(c => c.category === currentImcCategory);
                if (currentImcIndex < oldImcIndex) { newXP += 50; showMessage(`XP GAGNÉE: AMÉLIORATION DE L'IMC !`, 'success'); }
                else if (currentImcIndex > oldImcIndex) { newXP = Math.max(0, newXP - 30); showMessage(`XP PERDUE: DÉTÉRIORATION DE L'IMC.`, 'warning'); }
                if (currentImcCategory === 'POIDS NORMAL') {
                    if (!oldImcCategory.includes('POIDS NORMAL')) { newXP += 100; showMessage(`XP GAGNÉE: ENTRÉE DANS LA CATÉGORIE DE POIDS NORMAL !`, 'success'); }
                    else { newXP += 5; showMessage(`XP GAGNÉE: MAINTIEN DANS LA CATÉGORIE DE POIDS NORMAL !`, 'success'); }
                } else if (currentImcCategory.includes('INSUFFISANCE PONDÉRALE') && weightDiff < 0) { newXP += Math.round(Math.abs(weightDiff) * 10); showMessage(`XP GAGNÉE: PRISE DE POIDS VERS LA NORMALITÉ !`, 'success'); }
                else if ((currentImcCategory.includes('SURPOIDS') || currentImcCategory.includes('OBÉSITÉ')) && weightDiff > 0) { newXP += Math.round(weightDiff * 10); showMessage(`XP GAGNÉE: PERTE DE POIDS VERS LA NORMALITÉ !`, 'success'); }
                else if (currentImcCategory.includes('INSUFFISANCE PONDÉRALE') && weightDiff > 0) { newXP = Math.max(0, newXP - Math.round(Math.abs(weightDiff) * 5)); showMessage(`XP PERDUE: PERTE DE POIDS À PARTIR DE LA NORMALITÉ !`, 'warning'); }
                else if ((currentImcCategory.includes('SURPOIDS') || currentImcCategory.includes('OBÉSITÉ')) && weightDiff < 0) { newXP = Math.max(0, newXP - Math.round(Math.abs(weightDiff) * 5)); showMessage(`XP PERDUE: PRISE DE POIDS À PARTIR DE LA NORMALITÉ !`, 'warning'); }
            }
            userProfile = { ...userProfile, height: currentHeight, weight: currentWeight, imc: currentImc, imcCategory: currentImcCategory, proteinNeeds: currentProteinNeeds, currentXP: newXP, updatedAt: new Date().toISOString() };
            saveToLocalStorage('userProfile', userProfile);
            updateProfileDisplay();
            updateXPBar();
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const todayFormatted = formatDateToYYYYMMDD(today);
            const existingEntryIndex = weightHistory.findIndex(entry => formatDateToYYYYMMDD(new Date(entry.date)) === todayFormatted);
            if (existingEntryIndex !== -1) { weightHistory[existingEntryIndex] = { ...weightHistory[existingEntryIndex], weight: currentWeight, imc: currentImc, imcCategory: currentImcCategory, timestamp: new Date().toISOString() }; }
            else { weightHistory.push({ id: generateUniqueId(), date: new Date().toISOString(), weight: currentWeight, imc: currentImc, imcCategory: currentImcCategory, timestamp: new Date().toISOString() }); }
            saveToLocalStorage('weightHistory', weightHistory);
            if (currentPage === 'progress') renderProgressView(document.getElementById('main-content'));
        }

        // Rend la vue du planning quotidien
        function renderDailyPlanView(container) {
            let html = `<div class="card-retro mb-6"><h2 class="text-3xl sm:text-4xl font-bold text-yellow-300 mb-4 text-center">MON PLANNING</h2><div class="mb-6 space-y-4 p-4 rounded-lg border-2 border-blue-700 bg-gray-700"><h3 class="text-xl sm:text-2xl text-yellow-300 mb-3">AJOUTER UN POSTE :</h3><div class="relative"><label for="shiftDate" class="block text-white-200 text-sm font-bold mb-2">DATE DU POSTE :</label><input type="date" id="shiftDate" class="input-retro pr-10" style="color: #ffffff;" value="" /><i data-lucide="calendar" class="absolute right-11 top-12 -translate-y-1/2 text-white pointer-events-none" style="width:15px; height:18px;"></i></div><div><label for="shiftType" class="block text-gray-200 text-sm font-bold mb-2">TYPE DE POSTE :</label><select id="shiftType" class="select-retro"><option value="6h-18h">POSTE JOUR (6H-18H)</option><option value="7h-18h">POSTE JOUR (7H-18H)</option><option value="18h-6h">POSTE NUIT (18H-6H)</option><option value="repos">JOUR DE REPOS</option><option value="repos_sport">JOUR DE REPOS (SPORT)</option></select></div><div><label for="workoutType" class="block text-gray-200 text-sm font-bold mb-2">SÉANCE SPORT PRÉVUE :</label><select id="workoutType" class="select-retro"><option value="aucun">AUCUNE</option><option value="renforcement">RENFORCEMENT MUSCULAIRE</option><option value="cardio">CARDIO</option><option value="hiit">HIIT</option><option value="repos_actif">RÉCUPÉRATION ACTIVE / FLEXIBILITÉ</option></select></div><button id="add-shift-btn" class="btn-retro w-full">AJOUTER POSTE</button></div><h3 class="text-xl sm:text-2xl text-yellow-300 mb-3">TON PLAN POUR LES JOURS PLANIFIÉS :</h3><div id="shifts-list" class="space-y-6"></div></div>`;
            container.innerHTML = html;
            const shiftDateInput = document.getElementById('shiftDate'), shiftTypeSelect = document.getElementById('shiftType'), workoutTypeSelect = document.getElementById('workoutType'), addShiftBtn = document.getElementById('add-shift-btn'), shiftsListDiv = document.getElementById('shifts-list');
            addShiftBtn.onclick = async () => {
                const date = shiftDateInput.value, type = shiftTypeSelect.value, workout = workoutTypeSelect.value;
                if (!date || !type) { showMessage("ERREUR: DATE ET TYPE DE POSTE REQUIS.", 'error'); return; }
                const dateObj = new Date(date);
                dateObj.setHours(0, 0, 0, 0);
                if (shifts.some(s => formatDateToYYYYMMDD(new Date(s.date)) === formatDateToYYYYMMDD(dateObj))) { showMessage("ERREUR: POSTE DÉJÀ ENREGISTRÉ POUR CETTE DATE.", 'error'); return; }
                shifts.push({ id: generateUniqueId(), date: dateObj.toISOString(), type: type, workoutType: workout, createdAt: new Date().toISOString() });
                saveToLocalStorage('shifts', shifts);
                showMessage("SUCCÈS: POSTE AJOUTÉ !", 'success');
                shiftDateInput.value = '';
                workoutTypeSelect.value = 'aucun';
                renderDailyPlanView(container);
            };
            renderShiftsList(shiftsListDiv, shifts);
        }

        // Rend la liste des postes planifiés
        function renderShiftsList(container, shiftsData) {
            container.innerHTML = '';
            if (shiftsData.length === 0) { container.innerHTML = '<p class="text-gray-400">AUCUN POSTE ENREGISTRÉ. AJOUTE TON PREMIER POSTE CI-DESSOUS !</p>'; return; }
            const sortedShifts = [...shiftsData].sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());
            sortedShifts.forEach(shift => {
                const dateObj = new Date(shift.date);
                const dateString = dateObj.toLocaleDateString('fr-FR', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' }).toUpperCase();
                const routine = sleepRoutines[String(shift.type)] || sleepRoutines['repos'];
                const mealForThisDay = weeklyMealPlan?.semaine?.find(d => d.date === formatDateToYYYYMMDD(dateObj));
                const shiftDiv = document.createElement('div');
                shiftDiv.className = "bg-gray-700 p-4 rounded-lg border-4 border-purple-500 shadow-lg";
                shiftDiv.innerHTML = `<div class="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-3"><h4 class="text-lg sm:text-xl font-bold text-yellow-300">${dateString} - POSTE: ${String(shift.type).toUpperCase()}</h4><button class="btn-retro-red text-sm px-3 py-1 mt-2 sm:mt-0 delete-shift-btn" data-id="${shift.id}" data-date="${formatDateToYYYYMMDD(dateObj)}">SUPPRIMER</button></div>${String(shift.workoutType) !== 'aucun' ? `<div class="mb-3 p-2 bg-blue-800 rounded-md border border-purple-400"><p class="text-sm sm:text-base font-medium text-white">SÉANCE SPORT : ${String(shift.workoutType).toUpperCase().replace('_', ' ')} PRÉVUE</p></div>` : ''}<div class="mb-4"><h5 class="font-semibold text-base sm:text-lg text-yellow-300 mb-2">¤ ROUTINE SOMMEIL : ${String(routine.name).toUpperCase()}</h5><ul class="list-disc list-inside text-gray-300 text-sm space-y-1">${routine.details.map(detail => `<li>${String(detail).toUpperCase()}</li>`).join('')}</ul></div><div class="mb-4"><h5 class="font-semibold text-base sm:text-lg text-yellow-300 mb-2">¤ PLAN REPAS SUGGÉRÉ :</h5>${mealForThisDay ? `<ul class="list-disc list-inside text-gray-300 text-sm space-y-1">${mealForThisDay.petit_dejeuner ? `<li>**PETIT-DÉJEUNER :** ${String(mealForThisDay.petit_dejeuner.title || 'TITRE INDISPONIBLE').toUpperCase()}</li>` : ''}${mealForThisDay.dejeuner ? `<li>**DÉJEUNER :** ${String(mealForThisDay.dejeuner.title || 'TITRE INDISPONIBLE').toUpperCase()}</li>` : ''}${mealForThisDay.diner ? `<li>**DÎNER :** ${String(mealForThisDay.diner.title || 'TITRE INDISPONIBLE').toUpperCase()}</li>` : ''}${mealForThisDay.collation_matin ? `<li>**COLLAT. MATIN :** ${String(mealForThisDay.collation_matin.title || 'TITRE INDISPONIBLE').toUpperCase()}</li>` : ''}${mealForThisDay.collation_apresmidi ? `<li>**COLLAT. APRÈS-MIDI :** ${String(mealForThisDay.collation_apresmidi.title || 'TITRE INDISPONIBLE').toUpperCase()}</li>` : ''}${mealForThisDay.collation_unique ? `<li>**COLLAT. UNIQUE :** ${String(mealForThisDay.collation_unique.title || 'TITRE INDISPONIBLE').toUpperCase()}</li>` : ''}</ul>` : `<p class="text-gray-400">PLAN DE REPAS NON DISPONIBLE POUR CE JOUR. GÉNÉREZ UN PLAN HEBDOMADAIRE DANS L'ONGLET "RECETTES".</p>`}</div>`;
                container.appendChild(shiftDiv);
            });
            container.querySelectorAll('.delete-shift-btn').forEach(button => {
                button.onclick = async (event) => {
                    const idToDelete = event.target.dataset.id;
                    const dateToDelete = event.target.dataset.date;
                    if (await showConfirmModal("CONFIRMER LA SUPPRESSION DU POSTE ET DE SON PLAN DE REPAS ASSOCIÉ ?")) {
                        shifts = shifts.filter(s => s.id !== idToDelete);
                        saveToLocalStorage('shifts', shifts);
                        if (weeklyMealPlan && weeklyMealPlan.semaine) {
                            weeklyMealPlan.semaine = weeklyMealPlan.semaine.filter(dayData => dayData.date !== dateToDelete);
                            saveToLocalStorage('weeklyMealPlan', weeklyMealPlan);
                        }
                        showMessage("SUCCÈS: POSTE ET REPAS ASSOCIÉS SUPPRIMÉS !", 'success');
                        renderDailyPlanView(document.getElementById('main-content'));
                        renderRecipeView(document.getElementById('main-content'));
                    }
                };
            });
        }

        // Rend la vue du programme sportif
        function renderWorkoutView(container) {
            let html = `<div class="card-retro mb-6"><h2 class="text-3xl sm:text-4xl font-bold text-yellow-300 mb-4 text-center">PROGRAMME SPORTIF</h2><div class="p-4 rounded-lg border-2 border-purple-500 bg-gray-700"><h3 class="font-semibold text-xl sm:text-2xl mb-3 text-yellow-300">LIGNES DIRECTRICES SPORTIVES :</h3><ul class="list-disc list-inside text-gray-300 text-sm sm:text-base space-y-1"><li>ÉCOUTE TON CORPS : AVEC LA SCLÉROSE EN PLAQUES ET TES HORAIRES DE TRAVAIL, LA FATIGUE PEUT VARIER. SI TU TE SENS MOINS EN FORME, RÉDUIS L'INTENSITÉ, LE NOMBRE DE SÉRIES, OU OPTE POUR UNE SÉANCE PLUS LÉGÈRE OU DU REPOS ACTIF. NE FORCE JAMAIS LA DOULEUR.</li><li>LA FORME AVANT LA CHARGE : CONCENTRE-TOI SUR L'EXÉCUTION CORRECTE DE CHAQUE MOUVEMENT POUR MAXIMISER L'EFFICACITÉ ET PRÉVENIR LES BLESSURES. UNE BONNE TECHNIQUE EST PLUS IMPORTANTE QUE DE SOULEVER LOURD.</li><li>PROGRESSION PROGRESSIVE : L'OBJECTIF EST D'AMÉLIORER TES PERFORMANCES AU FIL DES SEMAINES. LORSQUE TU PEUX RÉALISER FACILEMENT LE MAXIMUM DE RÉPÉTITIONS/SÉRIES AVEC UNE BONNE FORME, AUGMENTE LÉGÈREMENT LA CHARGE (PAR PALIERS DE 2KG POUR LES HALTÈRES, OU 2.5KG/5KG POUR LES MACHINES) OU LE NOMBRE DE RÉPÉTITIONS.</li><li>HYDRATATION : BOIS DE L'EAU RÉGULIÈREMENT AVANT, PENDANT ET APRÈS CHAQUE SÉANCE.</li></ul></div><div class="mb-6 mt-6"><label for="phaseSelect" class="block text-gray-200 text-sm font-bold mb-2">CHOISIR UNE PHASE :</label><select id="phaseSelect" class="select-retro"><option value="phase1">${String(workoutProgram.phase1?.name || 'PHASE 1').toUpperCase()}</option><option value="phase2">${String(workoutProgram.phase2?.name || 'PHASE 2').toUpperCase()}</option></select></div><div id="workout-phase-content" class="space-y-6"></div></div>`;
            container.innerHTML = html;
            const phaseSelect = document.getElementById('phaseSelect'), workoutPhaseContent = document.getElementById('workout-phase-content');
            let selectedPhase = loadFromLocalStorage('selectedWorkoutPhase', 'phase1');
            if (!workoutProgram[selectedPhase]) { selectedPhase = 'phase1'; saveToLocalStorage('selectedWorkoutPhase', selectedPhase); }
            phaseSelect.value = selectedPhase;
            function renderPhaseContent(phase) {
                const currentPhaseData = workoutProgram[phase];
                if (!currentPhaseData || !currentPhaseData.sessions || !currentPhaseData.sessions.main || !currentPhaseData.sessions.cardio || !currentPhaseData.sessions.hiit) { workoutPhaseContent.innerHTML = '<p class="text-gray-400 text-center">CONTENU DE LA PHASE INDISPONIBLE. VEUILLEZ IMPORTER UN PROGRAMME VALIDE ET COMPLET.</p>'; return; }
                const generateExerciseHtml = (ex, index) => `<div class="flex flex-col sm:flex-row sm:items-center justify-between p-3 rounded-md border-2 border-blue-700 bg-gray-800 shadow-md"><div class="flex-1"><p class="font-medium text-gray-100 text-base sm:text-lg">${index + 1}. ${String(ex.name).toUpperCase()}</p><p class="text-sm text-gray-400 italic">${String(ex.desc).toUpperCase()}</p></div><button class="btn-retro-green text-sm px-4 py-2 mt-2 sm:mt-0 log-workout-btn" data-exercise-name="${ex.name}" data-exercise-type="${ex.type}">ENREGISTRER</button></div>`;
                let phaseHtml = `<h3 class="text-xl sm:text-2xl font-bold text-blue-400">${String(currentPhaseData.name).toUpperCase()}</h3><div class="p-4 rounded-lg border-2 border-purple-500 bg-gray-700 mt-4"><h4 class="font-semibold text-xl sm:text-2xl mb-3 text-yellow-300">ÉCHAUFFEMENT (10-15 MIN) :</h4><ul class="list-disc list-inside text-gray-300 text-sm sm:text-base mb-4 space-y-1"><li>**CARDIO LÉGER (5-7 MIN):** TAPIS (MARCHE RAPIDE 5.0 KM/H, PENTE 1.0) OU VÉLO/ELLIPTIQUE (NIVEAU 3-5).</li><li>**MOBILISATIONS ARTICULAIRES DYNAMIQUES (5-8 MIN):** CERCLES DE BRAS, ROTATIONS DU TRONC, FENTES (SANS CHARGE), ROTATIONS DE HANCHES, CERCLES DE CHEVILLES ET DE POIGNETS (10-15 RÉPÉTITIONS DE CHAQUE).</li></ul></div><div class="p-4 rounded-lg border-2 border-purple-500 bg-gray-700 mt-4"><h4 class="font-semibold text-xl sm:text-2xl mb-3 text-yellow-300">${String(currentPhaseData.sessions.main.name).toUpperCase()}</h4><h5 class="font-medium text-lg sm:text-xl mb-2 text-blue-400">CORPS DE SÉANCE (40-50 MINUTES) :</h5><div class="space-y-3">${currentPhaseData.sessions.main.exercises.map(generateExerciseHtml).join('')}</div><h5 class="font-medium text-lg sm:text-xl mt-4 mb-2 text-blue-400">RÉCUPÉRATION (5-10 MIN) :</h5><ul class="list-disc list-inside text-gray-300 text-sm sm:text-base space-y-1"><li>**ÉTIREMENTS DOUX :** MAINTIENS CHAQUE ÉTIREMENT PENDANT 20-30 SECONDES, SANS DOULEUR. CONCENTRE-TOI SUR LES ISCHIO-JAMBIERS, QUADRICÈPES, PECTORAUX, DOS, ÉPAULES ET BRAS.</li></ul></div><div class="p-4 rounded-lg border-2 border-purple-500 bg-gray-700 mt-4"><h4 class="font-semibold text-xl sm:text-2xl mb-3 text-yellow-300">${String(currentPhaseData.sessions.cardio.name).toUpperCase()}</h4><h5 class="font-medium text-lg sm:text-xl mb-2 text-blue-400">CORPS DE SÉANCE (35-45 MINUTES) :</h5><div class="space-y-3">${currentPhaseData.sessions.cardio.options.map(generateExerciseHtml).join('')}</div><h5 class="font-medium text-lg sm:text-xl mt-4 mb-2 text-blue-400">RÉCUPÉRATION (5-10 MIN) :</h5><ul class="list-disc list-inside text-gray-300 text-sm sm:text-base space-y-1"><li>**ÉTIREMENTS DOUX :** MAINTIENS CHAQUE ÉTIREMENT PENDANT 20-30 SECONDES, SANS DOULEUR. CONCENTRE-TOI SUR LES ISCHIO-JAMBIERS, QUADRICÈPES, PECTORAUX, DOS, ÉPAULES ET BRAS.</li></ul></div><div class="p-4 rounded-lg border-2 border-purple-500 bg-gray-700 mt-4"><h4 class="font-semibold text-xl sm:text-2xl mb-3 text-yellow-300">${String(currentPhaseData.sessions.hiit.name).toUpperCase()}</h4><p class="text-sm sm:text-base text-gray-300 mb-4">${String(currentPhaseData.sessions.hiit.desc).toUpperCase()}</p><h5 class="font-medium text-lg sm:text-xl mb-2 text-blue-400">CORPS DE SÉANCE (20-25 MINUTES) :</h5><div class="space-y-3">${currentPhaseData.sessions.hiit.exercises.map(generateExerciseHtml).join('')}</div><h5 class="font-medium text-lg sm:text-xl mt-4 mb-2 text-blue-400">RÉCUPÉRATION (5-10 MIN) :</h5><ul class="list-disc list-inside text-gray-300 text-sm sm:text-base space-y-1"><li>**RETOUR AU CALME :** MARCHE LÉGÈRE ET RESPIRATION PROFONDE.</li><li>**ÉTIREMENTS DOUX :** AXÉS SUR LES MUSCLES PRINCIPAUX SOLLICITÉS.</li></ul></div>`;
                if (workoutProgram.recovery) {
                    phaseHtml += `<div class="p-4 rounded-lg border-2 border-purple-500 bg-gray-700 mt-4"> <h4 class="font-semibold text-xl sm:text-2xl mb-3 text-yellow-300">${String(workoutProgram.recovery.name).toUpperCase()}</h4> <p class="text-sm sm:text-base text-gray-300 mb-4">${String(workoutProgram.recovery.desc).toUpperCase()}</p><ul class="list-disc list-inside text-gray-300 text-sm sm:text-base space-y-1">${workoutProgram.recovery.activities.map(act => `<li>**${String(act.name).toUpperCase()} :** ${String(act.desc).toUpperCase()}</li>`).join('')}</ul></div>`;
                }
                workoutPhaseContent.innerHTML = phaseHtml;
                renderLucideIcons();
                workoutPhaseContent.querySelectorAll('.log-workout-btn').forEach(button => {
                    button.onclick = (event) => {
                        const exerciseName = event.target.dataset.exerciseName;
                        const exerciseType = event.target.dataset.exerciseType;
                        showLogWorkoutModal({ name: exerciseName, type: exerciseType });
                    };
                });
            }
            phaseSelect.onchange = (event) => { selectedPhase = event.target.value; saveToLocalStorage('selectedWorkoutPhase', selectedPhase); renderPhaseContent(selectedPhase); };
            renderPhaseContent(selectedPhase);
        }

        // Affiche la modale pour enregistrer un entraînement
        function showLogWorkoutModal(currentExercise) {
            let modalHtml = `
                <div id="log-workout-modal" class="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center p-4 z-50 font-vt323">
                    <div class="bg-gray-800 p-6 rounded-lg border-4 border-purple-500 shadow-xl w-full max-w-md text-white">
                        <h3 class="text-2xl sm:text-3xl font-bold text-yellow-300 mb-4 text-center">ENREGISTRER L'ENTRAÎNEMENT</h3>
                        <p class="text-lg sm:text-xl mb-4 text-center">${String(currentExercise?.name).toUpperCase()}</p>
                        <div class="space-y-4">
                            <div>
                                <label for="logSets" class="block text-gray-200 text-sm font-bold mb-2">SÉRIES / ROUNDS :</label>
                                <input type="text" id="logSets" class="input-retro" placeholder="EX: 3 ou 5 ROUNDS" />
                            </div>
                            <div>
                                <label for="logReps" class="block text-gray-200 text-sm font-bold mb-2">RÉPÉTITIONS / DURÉE :</label>
                                <input type="text" id="logReps" class="input-retro" placeholder="EX: 12 ou 30 MIN" />
                            </div>
                            <div>
                                <label for="logWeight" class="block text-gray-200 text-sm font-bold mb-2">POIDS (KG, LAISSER VIDE SI NON APPLICABLE) :</label>
                                <input type="number" id="logWeight" class="input-retro" placeholder="EX: 50" />
                            </div>
                            <div>
                                <label for="logFeeling" class="block text-gray-200 text-sm font-bold mb-2">RESSENTI :</label>
                                <select id="logFeeling" class="select-retro">
                                    <option value="excellent">EXCELLENT</option>
                                    <option value="bien">BIEN</option>
                                    <option value="moyen">MOYEN</option>
                                    <option value="difficile">DIFFICILE</option>
                                    <option value="epuise">ÉPUISÉ</option>
                                </select>
                            </div>
                        </div>
                        <div class="flex justify-end space-x-4 mt-6">
                            <button id="cancel-log-btn" class="btn-retro-red">ANNULER</button>
                            <button id="confirm-log-btn" class="btn-retro-green">ENREGISTRER</button>
                        </div>
                    </div>
                </div>
            `;
            document.getElementById('global-modals-container').innerHTML = modalHtml;
            const modal = document.getElementById('log-workout-modal');
            modal.querySelector('#cancel-log-btn').onclick = () => modal.remove();
            modal.querySelector('#confirm-log-btn').onclick = () => {
                const sets = modal.querySelector('#logSets').value;
                const reps = modal.querySelector('#logReps').value;
                const weight = modal.querySelector('#logWeight').value;
                const feeling = modal.querySelector('#logFeeling').value;

                if (!sets || !reps) {
                    showMessage("SÉRIES/ROUNDS ET RÉPÉTITIONS/DURÉE SONT REQUIS.", 'error');
                    return;
                }

                const newLog = {
                    id: generateUniqueId(),
                    date: new Date().toISOString(),
                    exerciseName: currentExercise.name,
                    exerciseType: currentExercise.type,
                    sets: sets,
                    reps: reps,
                    weight: weight ? parseFloat(weight) : null,
                    feeling: feeling
                };
                workoutLogs.push(newLog);
                saveToLocalStorage('workoutLogs', workoutLogs);

                // Gagner de l'XP pour l'entraînement
                let xpGain = 20; // Base XP for logging a workout
                if (feeling === 'excellent') xpGain += 10;
                else if (feeling === 'bien') xpGain += 5;
                userProfile.currentXP += xpGain;
                saveToLocalStorage('userProfile', userProfile);
                updateXPBar();

                showMessage("ENTRAÎNEMENT ENREGISTRÉ ! XP GAGNÉE.", 'success');
                modal.remove();
                if (currentPage === 'progress') renderProgressView(document.getElementById('main-content'));
            };
        }

        // Modale de confirmation générique
        function showConfirmModal(message) {
            return new Promise(resolve => {
                const modalDiv = document.createElement('div');
                modalDiv.id = 'confirm-modal';
                modalDiv.className = 'fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center p-4 z-50 font-vt323';
                modalDiv.innerHTML = `
                    <div class="bg-gray-800 p-6 rounded-lg border-4 border-yellow-500 shadow-xl w-full max-w-sm text-white text-center">
                        <h3 class="text-xl sm:text-2xl font-bold mb-4 text-yellow-300">CONFIRMATION</h3>
                        <p class="text-base sm:text-lg mb-6">${String(message).toUpperCase()}</p>
                        <div class="flex justify-center space-x-4">
                            <button id="confirm-no" class="btn-retro-red">ANNULER</button>
                            <button id="confirm-yes" class="btn-retro-green">CONFIRMER</button>
                        </div>
                    </div>
                `;
                document.getElementById('global-modals-container').appendChild(modalDiv);

                document.getElementById('confirm-yes').onclick = () => {
                    modalDiv.remove();
                    resolve(true);
                };
                document.getElementById('confirm-no').onclick = () => {
                    modalDiv.remove();
                    resolve(false);
                };
            });
        }

        // Fonctions pour la génération de repas par l'IA
        function getMealContextKey(mealType, dayContext) {
            return `${mealType}_${dayContext.poste}_${dayContext.sport}`;
        }

        async function generateInternalMeal(mealType, dayContext, existingMealsToday = [], likedMeal = null, allowMeatFish = true, userProfileData, numPeople) {
            const apiKey = userProfileData.apiKey || "";
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

            const userHeight = userProfileData.height;
            const userWeight = userProfileData.weight;
            const userImc = userProfileData.imc;
            const userImcCategory = userProfileData.imcCategory;
            const userProteinNeeds = userProfileData.proteinNeeds;

            let mealContextDescription = getMealMomentContext(mealType, dayContext.poste, dayContext.sport);
            let sportImpact = "";
            if (dayContext.sport !== 'aucun') {
                sportImpact = "CE JOUR INCLUT UNE SÉANCE DE SPORT. LE REPAS DOIT SOUTENIR LA PERFORMANCE OU LA RÉCUPÉRATION.";
            } else {
                sportImpact = "CE JOUR N'INCLUT PAS DE SÉANCE DE SPORT. LE REPAS DOIT ÊTRE ÉQUILIBRÉ POUR UN JOUR MOINS ACTIF.";
            }

            let posteImpact = "";
            if (dayContext.poste === '18h-6h') {
                posteImpact = "C'EST UN POSTE DE NUIT. L'ALIMENTATION DOIT ÊTRE ADAPTÉE POUR MAINTENIR L'ÉNERGIE ET LA VIGILANCE PENDANT LA NUIT, ET FAVORISER LE REPOS EN JOURNÉE.";
            } else if (dayContext.poste.includes('jour')) {
                posteImpact = "C'EST UN POSTE DE JOUR. L'ALIMENTATION DOIT APPORTER UNE ÉNERGIE DURABLE POUR LA JOURNÉE.";
            } else if (dayContext.poste.includes('repos')) {
                posteImpact = "C'EST UN JOUR DE REPOS. L'ALIMENTATION DOIT FAVORISER LA RÉCUPÉRATION ET LE MAINTIEN.";
            }

            let mealSpecificConstraints = [];
            const adviceKey = mealType.includes('collation') ? `${mealType.replace('_unique', '')}_${dayContext.poste === '18h-6h' ? 'pendant' : (dayContext.sport !== 'aucun' ? 'post' : 'default')}` : dayContext.poste === '18h-6h' ? '18h-6h' : (dayContext.sport !== 'aucun' ? 'repos_sport' : 'default');
            const advice = specificMealAdvice[mealType]?.[adviceKey] || specificMealAdvice[mealType]?.default || "CONSEIL GÉNÉRAL : MANGEZ ÉQUILIBRÉ.";
            mealSpecificConstraints.push(advice);

            if (!allowMeatFish) {
                mealSpecificConstraints.push("EXCLURE TOUTE VIANDE (ROUGE OU BLANCHE) ET POISSON. PRIVILÉGIER LES PROTÉINES VÉGÉTALES (LÉGUMINEUSES, TOFU, TEMPEH, SEITAN, ETC.) OU LES ŒUFS/PRODUITS LAITIERS SI APPLICABLE AU TYPE DE REPAS.");
            }

            if (mealType === 'petit_dejeuner') {
                mealSpecificConstraints.push("DOIT ÊTRE SUCRÉ, EN ÉVITANT LES SAVEURS SALÉES (SAUF SI LES ŒUFS SONT INTÉGRÉS DANS UNE PRÉPARATION SUCRÉE COMME DES CRÊPES/PANCAKES).");
                mealSpecificConstraints.push("LES ŒUFS NE PEUVENT ÊTRE UTILISÉS QUE S'ILS SONT INTÉGRÉS DANS DES PRÉPARATIONS COMME DES CRÊPES, DES PANCAKES OU DES PORRIDGES, PAS COMME PLAT PRINCIPAL (EX: ŒUFS BROUILLÉS, OMELETTE).");
                mealSpecificConstraints.push("PAS DE PÂTES, SEMOULE OU SAUCE TOMATE.");
                mealSpecificConstraints.push("AJOUTEZ UNE TRÈS GRANDE VARIÉTÉ DE PETITS-DÉJEUNERS : TARTINES (MIEL, BEURRE, BEURRE DE CACAHUÈTE), THÉ (AVEC OU SANS LAIT), PORRIDGE, SHAKE DE WHEY (SI CONTEXTE SPORTIF LE PERMET), CÉRÉALES, FRUITS, YAOURTS. ADAPTEZ LES OPTIONS AU TYPE DE SÉANCE (EX: PORRIDGE POUR RENFORCEMENT, SHAKE POUR CARDIO) POUR ÉVITER LES DÉPENSES INUTILES.");
            } else if (mealType.includes('collation')) {
                mealSpecificConstraints.push("DOIT ÊTRE UNE COLLATON LÉGÈRE ET ÉNERGISANTE. PAS UN REPAS COMPLET.");
                mealSpecificConstraints.push("EXEMPLES : FRUITS, YAOURTS, SHAKES PROTÉINÉS, PETITES POIGNÉES D'OLÉAGINEUX, BARRES CÉRÉALES MAISON.");
                mealSpecificConstraints.push("ÉVITEZ LES ALIMENTS TROP GRAS OU TROP SUCRÉS.");
            } else if (mealType === 'dejeuner' || mealType === 'diner') {
                mealSpecificConstraints.push("DOIT ÊTRE UN REPAS COMPLET ET ÉQUILIBRÉ AVEC PROTÉINES, GLUCIDES ET LÉGUMES.");
                mealSpecificConstraints.push("PROPOSEZ UNE TRÈS GRANDE VARIÉTÉ DE RECETTES POUR ÉVITER LA MONOTONIE : SALADES (VERTE, ICEBERG, CRUDITÉS, POMMES DE TERRE, RIZ, PÂTES), GALETTES DE POMMES DE TERRE, RECETTES AVEC DU PAIN (EX: PAIN AVEC FROMAGE, TOASTS PROTÉINÉS, SANDWICHS ÉQUILIBRÉS), BURGERS ET WRAPS (ADAPTÉS AU PROGRAMME NUTRITIONNEL).");
                mealSpecificConstraints.push("ALTERNEZ SYSTÉMATIQUEMENT LES TYPES DE PROTÉINES, GLUCIDES ET LÉGUMES. INCLUEZ FRÉQUEMMENT PÂTES COMPLÈTES, SPAGHETTIS, PÂTES FRAÎCHES, RIZ BASMATI, QUINOA, PATATE DOUCE, SEMOULE COMPLÈTE. LÉGUMES VARIÉS: CONCOMBRE, ARTICHAUT, BROCOLIS, POIVRONS, HARICOTS VERTS, COURGETTES, ÉPINARDS, CAROTTES, CHOU-FLEUR, TOMATES CERISES, LAITUE, RADIS, CHAMPIGNONS, AUBERGINE, OIGNON.");
            }

            let existingMealsPrompt = "";
            if (existingMealsToday.length > 0) {
                existingMealsToday.forEach(meal => {
                    existingMealsPrompt += `- ${meal.title} (${meal.mealType})\n`;
                });
                mealSpecificConstraints.push(`PRENEZ EN COMPTE LES REPAS DÉJÀ GÉNÉRÉS POUR CE JOUR POUR ASSURER LA VARIÉTÉ ET ÉVITER LES DOUBLONS D'INGRÉDIENTS OU DE PRÉPARATIONS. REPAS DÉJÀ PRÉVUS : ${existingMealsPrompt}`);
            }

            if (likedMeal) {
                mealSpecificConstraints.push(`L'UTILISATEUR A AIMÉ LA RECETTE SUIVANTE. UTILISEZ-LA COMME INSPIRATION POUR GÉNÉRER UNE NOUVELLE RECETTE SIMILAIRE, MAIS PAS IDENTIQUE, EN VARIANT LÉGÈREMENT LES INGRÉDIENTS OU LA PRÉPARATION POUR ÉVITER LA MONOTONIE. RECETTE AIMÉE : TITRE: ${likedMeal.title}, DESCRIPTION: ${likedMeal.description_du_plat}, INGRÉDIENTS: ${likedMeal.ingredients_list.join(', ')}.`);
            }

            const prompt = `
                Génère une recette de repas pour ${numPeople} personne(s) au format JSON.
                Le repas est de type : "${mealType}".
                Le contexte du jour est : "${getDayContextString(dayContext.poste, dayContext.sport)}".
                Profil utilisateur : Taille: ${userHeight}cm, Poids: ${userWeight}kg, IMC: ${userImc} (${userImcCategory}), Besoins en protéines: ${userProteinNeeds}g/jour.
                ${sportImpact}
                ${posteImpact}
                CONTRAINTES SPÉCIFIQUES POUR CE REPAS :
                ${mealSpecificConstraints.map(c => `- ${c}`).join('\n')}
                - Toutes les informations (titre, description, ingrédients, étapes de préparation, conseils, notes) doivent être STRICTEMENT EN FRANÇAIS.
                - Les quantités des ingrédients doivent être adaptées pour ${numPeople} personne(s) et clairement indiquées (ex: 150g, 2 pièces, 1 cuillère à soupe).
                - POUR LES REPAS PRINCIPAUX (DÉJEUNER ET DÎNER) : Bien que la variété soit la priorité, si le contexte (type de poste et séance sportive) est identique à un jour précédent, vous pouvez proposer une recette similaire ou réutiliser des ingrédients clés pour optimiser les courses, mais EFFORCEZ-VOUS DE RENDRE CHAQUE RECETTE UNIQUE OU AVEC UNE TOUCHE DIFFÉRENTE.
                - POUR LES COLLATIONS : Proposez une TRÈS GRANDE VARIÉTÉ de collations (fruits, yaourts, shakes, galettes, etc.).
                - POUR LES SALADES : Incluez des salades variées (salade verte, iceberg, salade de crudités, salade de pommes de terre, salade de riz, salade de pâtes, etc.) comme repas complet ou accompagnement.
                - POUR LES RECETTES À BASE DE POMMES DE TERRE OU DE PAIN : Intégrez des recettes comme des galettes de pommes de terre, des toasts protéinés, ou des sandwichs équilibrés si cela correspond au type de repas.

                Format de sortie JSON attendu :
                {
                    "title": "TITRE DU PLAT (EX: POULET GRILLÉ ET LÉGUMES)",
                    "description_du_plat": "DESCRIPTION DÉTAILLÉE DU PLAT.",
                    "ingredients_label": "INGRÉDIENTS (POUR X PERS)",
                    "ingredients_list": ["QUANTITÉ UNITÉ INGRÉDIENT 1", "QUANTITÉ UNITÉ INGRÉDIENT 2", ...],
                    "preparation_steps": ["ÉTAPE 1.", "ÉTAPE 2.", ...],
                    "ma_portion_waeky": "VOTRE PORTION (POUR WAEKY) : DÉTAILLEZ LES QUANTITÉS SPÉCIFIQUES POUR L'UTILISATEUR (EX: 150G POULET, 200G RIZ, PORTION GÉNÉREUSE DE LÉGUMES).",
                    "conseils_reutilisation_economie": "CONSEILS POUR RÉUTILISER LES RESTES OU ÉCONOMISER.",
                    "notes": "NOTES SUPPLÉMENTAIRES OU INFORMATIONS NUTRITIONNELLES."
                }
            `;

            const payload = {
                contents: [{ role: "user", parts: [{ text: prompt }] }],
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: "OBJECT",
                        properties: {
                            "title": { "type": "STRING" },
                            "description_du_plat": { "type": "STRING" },
                            "ingredients_label": { "type": "STRING" },
                            "ingredients_list": { "type": "ARRAY", "items": { "type": "STRING" } },
                            "preparation_steps": { "type": "ARRAY", "items": { "type": "STRING" } },
                            "ma_portion_waeky": { "type": "STRING" },
                            "conseils_reutilisation_economie": { "type": "STRING" },
                            "notes": { "type": "STRING" }
                        },
                        "required": ["title", "description_du_plat", "ingredients_label", "ingredients_list", "preparation_steps", "ma_portion_waeky", "conseils_reutilisation_economie", "notes"]
                    }
                }
            };

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    let errorMessage = `Erreur HTTP: ${response.status}`;
                    if (response.status === 401 || response.status === 403) errorMessage += " - PROBLÈME D'AUTHENTIFICATION API. VÉRIFIEZ L'ACCÈS À L'API GEMINI. (CODE 401/403)";
                    else if (errorText) errorMessage += ` - ${errorText}`;
                    throw new Error(errorMessage);
                }

                const rawResult = await response.text();
                let parsedContent = null;
                try {
                    const result = JSON.parse(rawResult);
                    if (result.candidates && result.candidates.length > 0 && result.candidates[0].content && result.candidates[0].content.parts && result.candidates[0].content.parts.length > 0) {
                        parsedContent = JSON.parse(result.candidates[0].content.parts[0].text);
                    } else {
                        throw new Error("Réponse de l'IA mal formée ou vide.");
                    }
                } catch (parseError) {
                    console.error("Erreur lors de l'analyse du JSON de la réponse LLM ou de la structure des candidats:", parseError);
                    console.error("JSON brut causant l'erreur:", rawResult);
                    const fallbackTitle = `${mealContextDescription.toUpperCase()} SIMPLIFIÉ (ERREUR IA)`, fallbackDesc = `UNE ERREUR S'EST PRODUITE LORS DE LA GÉNÉRATION. VOICI UNE RECETTE DE BASE.`, fallbackIngredients = [`QUANTITÉS À DÉFINIR SELON VOTRE APPÉTIT`, `PROTÉINES VARIÉES`, `GLUCIDES COMPLEXES`, `LÉGUMES DE SAISON`], fallbackPreparation = ["1. PRÉPAREZ LES INGRÉDIENTS. 2. CUISEZ SELON VOS MÉTHODES HABITUELLES."], fallbackPortion = "VOTRE PORTION (POUR WAEKY) : PROTÉINES, GLUCIDES ET LÉGUMES/FRUITS VARIÉS ADAPTÉS. POUR 1 PERSONNE.", fallbackConseils = "AJUSTEZ LES QUANTITÉS SELON VOS BESOINS. ESSAYEZ DE RÉUTILISER LES RESTES.", fallbackNotes = "LA RECETTE A ÉTÉ SIMPLIFIÉE EN RAISON D'UN PROBLÈME DE COMMUNICATION AVEC L'IA. VÉRIFIEZ LE PROMPT OU L'API.";
                    parsedContent = { title: fallbackTitle, description_du_plat: fallbackDesc, ingredients_label: `INGRÉDIENTS (POUR ${numPeople} PERS)`, ingredients_list: fallbackIngredients, preparation_steps: fallbackPreparation, ma_portion_waeky: fallbackPortion, conseils_reutilisation_economie: fallbackConseils, notes: fallbackNotes };
                }

                return {
                    id: generateUniqueId(),
                    title: String(parsedContent.title || '').toUpperCase(),
                    description_du_plat: String(parsedContent.description_du_plat || '').toUpperCase(),
                    ingredients_label: String(parsedContent.ingredients_label || `INGRÉDIENTS (POUR ${numPeople} PERS)`).toUpperCase(),
                    ingredients_list: (parsedContent.ingredients_list || []).map(item => String(item).toUpperCase()),
                    preparation_steps: (parsedContent.preparation_steps || []).map(step => String(step).toUpperCase()),
                    ma_portion_waeky: String(parsedContent.ma_portion_waeky || '').toUpperCase(),
                    conseils_reutilisation_economie: String(parsedContent.conseils_reutilisation_economie || '').toUpperCase(),
                    notes: String(parsedContent.notes || '').toUpperCase(),
                    mealType: mealType,
                    dayContext: dayContext
                };
            } catch (error) {
                console.error("Erreur fatale lors de l'appel LLM ou de l'analyse JSON générale:", error);
                const fallbackTitle = `${mealContextDescription.toUpperCase()} (ERREUR SYSTÈME)`, fallbackDesc = `UNE ERREUR CRITIQUE S'EST PRODUITE. VEUILLEZ RÉESSAYER.`, fallbackIngredients = [`VÉRIFIEZ VOTRE CONNEXION INTERNET`, `CONTACTEZ LE SUPPORT SI LE PROBLÈME PERSISTE`], fallbackPreparation = ["1. ESSAYEZ DE RE-GÉNÉRER LE PLAN.", "2. ASSUREZ-VOUS QUE VOTRE PROFIL EST COMPLET."], fallbackPortion = "INDISPONIBLE EN RAISON D'UNE ERREUR.", fallbackConseils = "AUCUN CONSEIL DISPONIBLE.", fallbackNotes = "ERREUR DE COMMUNICATION MAJEURE AVEC L'IA. VEUILLEZ VÉRIFIER VOTRE CONNEXION.";
                return { id: generateUniqueId(), title: fallbackTitle, description_du_plat: fallbackDesc, ingredients_label: `INGRÉDIENTS (POUR ${numPeople} PERS)`, ingredients_list: fallbackIngredients, preparation_steps: fallbackPreparation, ma_portion_waeky: fallbackPortion, conseils_reutilisation_economie: fallbackConseils, notes: fallbackNotes, mealType: mealType, dayContext: dayContext };
            }
        }

        // Rend la vue des recettes et gère la génération du plan de repas
        function renderRecipeView(container) {
            let numPeople = loadFromLocalStorage('recipeNumPeople', 1), allowMeatFish = loadFromLocalStorage('recipeAllowMeatFish', true);
            let html = `<div class="card-retro mb-6"><h2 class="text-3xl sm:text-4xl font-bold text-yellow-300 mb-4 text-center">PLAN DE REPAS</h2><div class="p-4 rounded-lg border-2 border-blue-700 bg-gray-700 mb-6"><h3 class="text-xl sm:text-2xl text-yellow-300 mb-3">GÉNÉRER MON PLAN DE REPAS :</h3><div class="mb-4"><label for="numPeople" class="block text-gray-200 text-sm font-bold mb-2">POUR COMBIEN DE PERSONNES ?</label><input type="number" id="numPeople" value="${numPeople}" min="1" class="input-retro" /></div><div class="mb-4 flex items-center"><input type="checkbox" id="allowMeatFish" ${allowMeatFish ? 'checked' : ''} class="mr-2 h-4 w-4 text-purple-600 rounded border-gray-300 focus:ring-purple-500" /><label for="allowMeatFish" class="text-gray-200 text-sm font-bold">AUTORISER VIANDE ET POISSON (PLUS ÉCONOMIQUE SANS)</label></div><button id="generate-plan-btn" class="btn-retro-purple w-full flex items-center justify-center"><span id="generate-plan-spinner" class="spinner mr-2 ${regeneratingMeal && !regeneratingMeal.mealType ? '' : 'hidden'}"></span><span id="generate-plan-text">${regeneratingMeal && !regeneratingMeal.mealType ? 'GÉNÉRATION...' : 'GÉNÉRER PLAN DE REPAS'}</span></button><p class="text-xs text-gray-400 mt-2 text-center">LE PLAN SERA GÉNÉRÉ UNIQUEMENT POUR LES JOURS AVEC DES POSTES ENREGISTRÉS DANS L'ONGLET "PLANNING".</p></div><div id="weekly-meal-plan-content"></div></div>`;
            container.innerHTML = html;
            const numPeopleInput = document.getElementById('numPeople'), allowMeatFishCheckbox = document.getElementById('allowMeatFish'), generatePlanBtn = document.getElementById('generate-plan-btn'), generatePlanSpinner = document.getElementById('generate-plan-spinner'), generatePlanText = document.getElementById('generate-plan-text'), weeklyMealPlanContentDiv = document.getElementById('weekly-meal-plan-content');
            numPeople = loadFromLocalStorage('recipeNumPeople', 1);
            allowMeatFish = loadFromLocalStorage('recipeAllowMeatFish', true);
            numPeopleInput.value = numPeople;
            allowMeatFishCheckbox.checked = allowMeatFish;
            numPeopleInput.onchange = (e) => { numPeople = Math.max(1, parseInt(e.target.value) || 1); saveToLocalStorage('recipeNumPeople', numPeople); };
            allowMeatFishCheckbox.onchange = (e) => { allowMeatFish = e.target.checked; saveToLocalStorage('recipeAllowMeatFish', allowMeatFish); };
            if (regeneratingMeal && !regeneratingMeal.mealType) {
                generatePlanBtn.disabled = true;
            } else {
                generatePlanBtn.disabled = false;
            }
            generatePlanBtn.onclick = async () => {
                regeneratingMeal = { dateKey: null, mealType: null };
                renderRecipeView(container);
                generatePlanBtn.disabled = true;
                generatePlanSpinner.classList.remove('hidden');
                generatePlanText.textContent = 'GÉNÉRATION...';
                showMessage("GÉNÉRATION DU PLAN DE REPAS EN COURS... CELA PEUT PRENDRE QUELQUES INSTANTS.", 'info');
                try {
                    if (!userProfile.height || !userProfile.weight) { showMessage("ERREUR: VEUILLEZ REMPLIR VOTRE TAILLE ET VOTRE POIDS DANS LE PROFIL POUR GÉNÉRER DES RECETTES PRÉCISES.", 'error'); return; }
                    const today = new Date();
                    today.setHours(0, 0, 0, 0);
                    const fetchedShifts = (loadFromLocalStorage('shifts', []) || []).filter(s => new Date(s.date).getTime() >= today.getTime());
                    if (fetchedShifts.length === 0) { showMessage("AUCUN POSTE ENREGISTRÉ POUR LES JOURS À VENIR. VEUILLEZ AJOUTER DES POSTES DANS L'ONGLET 'PLANNING' POUR GÉNÉRER UN PLAN DE REPAS.", 'warning'); return; }
                    const newMealPlan = { semaine: [] };
                    const userProfileData = { height: parseFloat(userProfile.height), weight: parseFloat(userProfile.weight), imc: userProfile.imc, imcCategory: userProfile.imcCategory, proteinNeeds: userProfile.proteinNeeds };
                    for (const shift of fetchedShifts) {
                        const day = new Date(shift.date);
                        const dateKey = formatDateToYYYYMMDD(day);
                        const dayContext = { poste: shift.type, sport: shift.workoutType };
                        const mealsForDay = {};
                        const mealOrder = ['petit_dejeuner', 'collation_matin', 'dejeuner', 'collation_apresmidi', 'diner', 'collation_unique'];
                        for (const mealType of mealOrder) {
                            if (mealType.startsWith('collation') && dayContext.sport === 'aucun' && dayContext.poste === 'repos') { continue; }
                            if (mealType === 'collation_matin' && (dayContext.poste === '18h-6h' || dayContext.poste === 'repos') && dayContext.sport === 'aucun') { continue; }
                            if (mealType === 'collation_apresmidi' && dayContext.poste === '18h-6h') { continue; }
                            if (mealType === 'collation_unique' && (dayContext.poste !== '18h-6h' && dayContext.sport === 'aucun' && dayContext.poste !== '7h-18h')) { continue; }
                            if (mealType === 'collation_unique' && dayContext.poste === 'repos' && dayContext.sport === 'aucun') { continue; }
                            const generatedMeal = await generateInternalMeal( mealType, dayContext, Object.values(mealsForDay).filter(m => typeof m === 'object' && m !== null && m.mealType && m.mealType !== mealType), null, allowMeatFish, userProfileData, numPeople );
                            mealsForDay[mealType] = generatedMeal;
                        }
                        newMealPlan.semaine.push({ date: dateKey, dayContext: dayContext, ...mealsForDay });
                    }
                    newMealPlan.semaine.sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());
                    weeklyMealPlan = newMealPlan;
                    saveToLocalStorage('weeklyMealPlan', weeklyMealPlan);
                    showMessage("SUCCÈS: PLAN DE REPAS GÉNÉRÉ ET ENREGISTRÉ !", 'success');
                    speak("Plan de repas généré !");
                    renderRecipeView(container);
                } catch (error) { console.error("Erreur lors de la génération du plan de repas:", error); showMessage(`ERREUR: Échec de la génération du plan. ${error.message}`, 'error'); }
                finally {
                    generatePlanBtn.disabled = false;
                    generatePlanSpinner.classList.add('hidden');
                    generatePlanText.textContent = 'GÉNÉRER PLAN DE REPAS';
                }
            };
            function renderWeeklyMealPlan() {
                if (!weeklyMealPlan || !weeklyMealPlan.semaine || weeklyMealPlan.semaine.length === 0) {
                    weeklyMealPlanContentDiv.innerHTML = ` <p class="text-gray-400 text-center"> AUCUN PLAN DE REPAS GÉNÉRÉ. CLIQUEZ SUR "GÉNÉRER PLAN DE REPAS" CI-DESSUS. </p> `; return;
                }
                let mealsHtml = `<div class="space-y-6"> <h3 class="text-xl sm:text-2xl text-yellow-300 mb-3 text-center">TON PLAN DE REPAS :</h3> `;
                weeklyMealPlan.semaine.forEach((dayData) => {
                    mealsHtml += ` <div class="bg-gray-700 p-4 rounded-lg border-4 border-purple-500 shadow-lg"> <h4 class="text-lg sm:text-xl font-bold text-yellow-300 mb-3"> ${new Date(dayData.date).toLocaleDateString('fr-FR', { weekday: 'long', day: 'numeric', month: 'long' }).toUpperCase()} - ${getDayContextString(dayData.dayContext.poste, dayData.dayContext.sport)} </h4> <div class="space-y-4"> `;
                    const mealOrder = ['petit_dejeuner', 'collation_matin', 'dejeuner', 'collation_apresmidi', 'diner', 'collation_unique'];
                    mealOrder.forEach(mealType => {
                        const meal = dayData[mealType];
                        if (meal) {
                            const momentContext = getMealMomentContext(mealType, dayData.dayContext.poste, dayData.dayContext.sport);
                            const adviceKey = mealType.includes('collation') ? `${mealType.replace('_unique', '')}_${dayData.dayContext.poste === '18h-6h' ? 'pendant' : (dayData.dayContext.sport !== 'aucun' ? 'post' : 'default')}` : dayData.dayContext.poste === '18h-6h' ? '18h-6h' : (dayData.dayContext.sport !== 'aucun' ? 'repos_sport' : 'default');
                            const advice = specificMealAdvice[mealType]?.[adviceKey] || specificMealAdvice[mealType]?.default || "CONSEIL GÉNÉRAL : MANGEZ ÉQUILIBRÉ.";
                            const isRegeneratingCurrentMeal = regeneratingMeal && regeneratingMeal.dateKey === dayData.date && regeneratingMeal.mealType === mealType;
                            const isLiked = userProfile.likedMeals.some(lm => lm.id === meal.id);

                            mealsHtml += `
                                <div class="bg-gray-800 p-3 rounded-md border border-blue-700 shadow-sm">
                                    <div class="flex justify-between items-center cursor-pointer toggle-meal-details" data-meal-id="${meal.id}">
                                        <h5 class="text-lg font-bold text-gray-100">${momentContext} : ${String(meal.title || 'Titre Indisponible').toUpperCase()}</h5>
                                        <div class="flex items-center">
                                            <button class="btn-retro-purple text-xs px-2 py-1 flex items-center justify-center regenerate-meal-btn" data-date="${dayData.date}" data-meal-type="${mealType}" ${isRegeneratingCurrentMeal ? 'disabled' : ''}>
                                                ${isRegeneratingCurrentMeal ? `<span class="spinner w-4 h-4"></span>` : `<i data-lucide="rotate-ccw" style="width:16px; height:16px;"></i>`}
                                                <span class="ml-1 hidden sm:inline">RÉGÉNÉRER</span>
                                            </button>
                                            <button class="text-white ml-2 like-meal-btn" data-meal-id="${meal.id}" data-date="${dayData.date}" data-meal-type="${mealType}" style="color:${isLiked ? '#FCD34D' : 'white'};">
                                                <i data-lucide="${isLiked ? 'heart' : 'heart'}" class="${isLiked ? 'fill-current text-yellow-400' : ''}" style="width:20px; height:20px;"></i>
                                            </button>
                                        </div>
                                    </div>
                                    <div id="meal-content-${meal.id}" class="overflow-hidden transition-all duration-500 ease-in-out max-h-0">
                                        <p class="text-gray-300 text-sm italic mb-2">${String(meal.description_du_plat || 'DESCRIPTION INDISPONIBLE').toUpperCase()}</p>
                                        <p class="text-sm font-medium text-yellow-300">${String(meal.ingredients_label || 'INGRÉDIENTS').toUpperCase()} :</p>
                                        <ul class="list-disc list-inside text-gray-300 text-xs pl-2 space-y-1">${(meal.ingredients_list || []).map(ingredient => `<li>${String(ingredient).toUpperCase()}</li>`).join('')}</ul>
                                        <p class="text-sm font-medium text-yellow-300 mt-2">PRÉPARATION :</p>
                                        <ol class="list-decimal list-inside text-gray-300 text-xs pl-2 space-y-1">${(meal.preparation_steps || []).map(step => `<li>${String(step).toUpperCase()}</li>`).join('')}</ol>
                                        <p class="text-sm font-medium text-yellow-300 mt-2">PORTION WAEKY :</p>
                                        <p class="text-gray-300 text-xs">${String(meal.ma_portion_waeky || 'PORTION INDISPONIBLE').toUpperCase()}</p>
                                        <p class="text-sm font-medium text-yellow-300 mt-2">CONSEILS ÉCONOMIE :</p>
                                        <p class="text-gray-300 text-xs">${String(meal.conseils_reutilisation_economie || 'CONSEILS INDISPONIBLES').toUpperCase()}</p>
                                        <p class="text-blue-200 text-xs mt-3">${advice}</p>
                                    </div>
                                </div>
                            `;
                        }
                    });
                    mealsHtml += `</div></div></div>`;
                });
                mealsHtml += `</div>`;
                weeklyMealPlanContentDiv.innerHTML = mealsHtml;
                renderLucideIcons();
                attachCollapsibleListeners();

                weeklyMealPlanContentDiv.querySelectorAll('.regenerate-meal-btn').forEach(button => {
                    button.onclick = async (event) => {
                        const dateKey = event.currentTarget.dataset.date;
                        const mealType = event.currentTarget.dataset.mealType;
                        const dayDataForRegen = weeklyMealPlan.semaine.find(d => d.date === dateKey);
                        if (!dayDataForRegen || !dayDataForRegen.dayContext) { showMessage("ERREUR: Contexte de jour non trouvé pour la régénération du repas.", 'error'); return; }

                        regeneratingMeal = { dateKey: dateKey, mealType: mealType };
                        renderRecipeView(container); // Re-render to show spinner on the specific button

                        try {
                            const userProfileData = { height: parseFloat(userProfile.height), weight: parseFloat(userProfile.weight), imc: userProfile.imc, imcCategory: userProfile.imcCategory, proteinNeeds: userProfile.proteinNeeds };
                            const regeneratedMeal = await generateInternalMeal(
                                mealType,
                                dayDataForRegen.dayContext,
                                Object.values(dayDataForRegen).filter(m => typeof m === 'object' && m !== null && m.mealType && m.mealType !== mealType), // Pass other meals of the day
                                null, // No liked meal for regeneration
                                allowMeatFish,
                                userProfileData,
                                numPeople
                            );
                            dayDataForRegen[mealType] = regeneratedMeal;
                            saveToLocalStorage('weeklyMealPlan', weeklyMealPlan);
                            showMessage("SUCCÈS: REPAS RÉGÉNÉRÉ !", 'success');
                            speak("Repas régénéré !");
                        } catch (error) {
                            console.error("Erreur lors de la régénération du repas:", error);
                            showMessage(`ERREUR: Échec de la régénération du repas. ${error.message}`, 'error');
                        } finally {
                            regeneratingMeal = null; // Reset regenerating state
                            renderRecipeView(container); // Re-render to remove spinner and update content
                        }
                    };
                });

                weeklyMealPlanContentDiv.querySelectorAll('.like-meal-btn').forEach(button => {
                    button.onclick = (event) => {
                        const mealId = event.currentTarget.dataset.mealId;
                        const dateKey = event.currentTarget.dataset.date;
                        const mealType = event.currentTarget.dataset.mealType;
                        const dayData = weeklyMealPlan.semaine.find(d => d.date === dateKey);
                        const mealToLike = dayData ? dayData[mealType] : null;

                        if (mealToLike) {
                            const existingLikedIndex = userProfile.likedMeals.findIndex(lm => lm.id === mealId);
                            if (existingLikedIndex !== -1) {
                                userProfile.likedMeals.splice(existingLikedIndex, 1);
                                showMessage("RECETTE RETIRÉE DES FAVORIS.", 'info');
                            } else {
                                userProfile.likedMeals.push({ ...mealToLike, likedAt: new Date().toISOString() });
                                showMessage("RECETTE AJOUTÉE AUX FAVORIS !", 'success');
                            }
                            saveToLocalStorage('userProfile', userProfile);
                            renderRecipeView(container); // Re-render to update heart icon
                        }
                    };
                });
            }
            renderWeeklyMealPlan();
        }

        // Gère l'affichage/masquage des détails de repas
        function attachCollapsibleListeners() {
            document.querySelectorAll('.toggle-meal-details').forEach(header => {
                header.onclick = (event) => {
                    // Empêche le clic sur les boutons enfants de déclencher le toggle
                    if (event.target.closest('button')) {
                        return;
                    }
                    const mealId = header.dataset.mealId;
                    const content = document.getElementById(`meal-content-${mealId}`); // Corrected: Use mealId
                    if (content) {
                        if (content.classList.contains('max-h-0')) {
                            content.classList.remove('max-h-0');
                            content.style.maxHeight = content.scrollHeight + "px"; // Définit la hauteur réelle
                        } else {
                            content.style.maxHeight = "0px"; // Réduit à 0 pour l'animation
                            content.classList.add('max-h-0');
                        }
                    }
                };
            });
        }

        // Rend la vue du chronomètre d'intervalle
        function renderChronoIntervalleView(container) {
            let html = `
                <div class="card-retro mb-6">
                    <h2 class="text-3xl sm:text-4xl font-bold text-yellow-300 mb-4 text-center">CHRONOMÈTRE D'INTERVALLES</h2>

                    <!-- Affichage du Chrono -->
                    <div class="bg-gray-800 p-6 rounded-lg border-4 border-blue-700 shadow-xl mb-6 text-center">
                        <p class="text-5xl sm:text-7xl font-bold text-green-400 mb-2" id="chrono-display">PRÊT: 00</p>
                        <p class="text-xl sm:text-2xl text-purple-300" id="chrono-instruction">AJOUTEZ DES INTERVALLES</p>
                    </div>

                    <!-- Contrôles du Chrono -->
                    <div class="grid grid-cols-2 sm:grid-cols-4 gap-4 mb-6">
                        <button id="start-chrono-btn" class="btn-retro-green col-span-2 sm:col-span-1">DÉMARRER</button>
                        <button id="pause-chrono-btn" class="btn-retro-purple col-span-2 sm:col-span-1">PAUSE</button>
                        <button id="reset-chrono-btn" class="btn-retro-red col-span-2 sm:col-span-1">RESET</button>
                        <button id="skip-interval-btn" class="btn-retro col-span-2 sm:col-span-1">PASSER</button>
                    </div>

                    <!-- Paramètres du Chrono -->
                    <div class="bg-gray-700 p-4 rounded-lg border-2 border-yellow-500 mb-6">
                        <h3 class="text-xl sm:text-2xl font-bold text-yellow-300 mb-3">PARAMÈTRES :</h3>
                        <div class="mb-4 flex items-center">
                            <input type="checkbox" id="enable-pre-countdown" ${enableChronoPreCountdown ? 'checked' : ''} class="mr-2 h-4 w-4 text-purple-600 rounded border-gray-300 focus:ring-purple-500" />
                            <label for="enable-pre-countdown" class="text-gray-200 text-sm font-bold">COMPTE À REBOURS PRÉ-CHRONO</label>
                        </div>
                        <div id="pre-countdown-duration-setting" class="${enableChronoPreCountdown ? '' : 'hidden'} mb-4">
                            <label for="chrono-pre-countdown-duration" class="block text-gray-200 text-sm font-bold mb-2">DURÉE PRÉ-COMPTE (SECONDES) :</label>
                            <input type="number" id="chrono-pre-countdown-duration" value="${chronoPreCountdownDuration}" min="1" class="input-retro" />
                        </div>
                    </div>

                    <!-- Ajout/Modification d'Intervalle -->
                    <div class="bg-gray-700 p-4 rounded-lg border-2 border-blue-700 mb-6">
                        <h3 class="text-xl sm:text-2xl text-yellow-300 mb-3">AJOUTER / MODIFIER INTERVALLE :</h3>
                        <div class="mb-4">
                            <label for="new-duration-minutes" class="block text-gray-200 text-sm font-bold mb-2">DURÉE (MINUTES) :</label>
                            <input type="number" id="new-duration-minutes" class="input-retro" placeholder="EX: 1" min="1" />
                        </div>
                        <div class="mb-4">
                            <label for="new-instruction" class="block text-gray-200 text-sm font-bold mb-2">INSTRUCTION :</label>
                            <input type="text" id="new-instruction" class="input-retro" placeholder="EX: COURSE RAPIDE" />
                        </div>
                        <button id="add-update-interval-btn" class="btn-retro w-full">AJOUTER</button>
                        <button id="reset-interval-form-btn" class="btn-retro-red w-full mt-2 hidden">ANNULER MODIFICATION</button>
                    </div>

                    <!-- Liste des Intervalles -->
                    <div class="bg-gray-700 p-4 rounded-lg border-2 border-purple-500 mb-6">
                        <h3 class="text-xl sm:text-2xl text-yellow-300 mb-3">SÉQUENCE D'INTERVALLES :</h3>
                        <div id="intervals-list" class="space-y-2 mb-4">
                            <!-- Les intervalles seront listés ici -->
                        </div>
                        <div class="flex flex-col sm:flex-row gap-4">
                            <input type="text" id="sequenceName" class="input-retro flex-1" placeholder="NOM DE LA SÉQUENCE" />
                            <button id="save-sequence-btn" class="btn-retro-green">SAUVEGARDER</button>
                            <button id="load-sequence-btn" class="btn-retro">CHARGER</button>
                        </div>
                    </div>
                </div>
            `;
            container.innerHTML = html;

            const chronoDisplay = document.getElementById('chrono-display');
            const chronoInstruction = document.getElementById('chrono-instruction');
            const startChronoBtn = document.getElementById('start-chrono-btn');
            const pauseChronoBtn = document.getElementById('pause-chrono-btn');
            const resetChronoBtn = document.getElementById('reset-chrono-btn');
            const skipIntervalBtn = document.getElementById('skip-interval-btn');
            const newDurationMinutesInput = document.getElementById('new-duration-minutes');
            const newInstructionInput = document.getElementById('new-instruction');
            const addUpdateIntervalBtn = document.getElementById('add-update-interval-btn');
            const resetIntervalFormBtn = document.getElementById('reset-interval-form-btn');
            const intervalsListDiv = document.getElementById('intervals-list');
            const enablePreCountdownCheckbox = document.getElementById('enable-pre-countdown');
            const preCountdownDurationSetting = document.getElementById('pre-countdown-duration-setting');
            const chronoPreCountdownDurationInput = document.getElementById('chrono-pre-countdown-duration');
            const saveSequenceBtn = document.getElementById('save-sequence-btn');
            const loadSequenceBtn = document.getElementById('load-sequence-btn');

            // Met à jour l'affichage du chronomètre
            function updateChronoDisplay() {
                const displayTime = chronoCurrentIntervalIndex === -1 ? `PRÊT: ${String(chronoCurrentTime).padStart(2, '0')}` : `${String(Math.floor(chronoCurrentTime / 60)).padStart(2, '0')}:${String(chronoCurrentTime % 60).padStart(2, '0')}`;
                const currentInstruction = chronoCurrentIntervalIndex === -1 ? "PRÉPAREZ-VOUS !" : chronoIntervals[chronoCurrentIntervalIndex]?.instruction || "FINI !";
                chronoDisplay.textContent = displayTime;
                chronoInstruction.textContent = String(currentInstruction).toUpperCase();

                if (isChronoRunning && !isChronoPaused) {
                    startChronoBtn.disabled = true;
                    pauseChronoBtn.disabled = false;
                    resetChronoBtn.disabled = false;
                    skipIntervalBtn.disabled = false;
                    startChronoBtn.classList.remove('btn-retro-green');
                    startChronoBtn.classList.add('bg-gray-500');
                    pauseChronoBtn.classList.remove('bg-gray-500');
                    pauseChronoBtn.classList.add('btn-retro-purple');
                } else if (isChronoPaused) {
                    startChronoBtn.disabled = false;
                    pauseChronoBtn.disabled = true;
                    resetChronoBtn.disabled = false;
                    skipIntervalBtn.disabled = false;
                    startChronoBtn.classList.remove('bg-gray-500');
                    startChronoBtn.classList.add('btn-retro-green');
                    pauseChronoBtn.classList.remove('btn-retro-purple');
                    pauseChronoBtn.classList.add('bg-gray-500');
                } else {
                    startChronoBtn.disabled = false;
                    pauseChronoBtn.disabled = true;
                    resetChronoBtn.disabled = true;
                    skipIntervalBtn.disabled = true;
                    startChronoBtn.classList.remove('bg-gray-500');
                    startChronoBtn.classList.add('btn-retro-green');
                    pauseChronoBtn.classList.remove('btn-retro-purple');
                    pauseChronoBtn.classList.add('bg-gray-500');
                }
            }

            // Boucle principale du chronomètre
            function chronoLoop() {
                if (!isChronoRunning || isChronoPaused) return;

                if (chronoCurrentIntervalIndex === -1) { // Pré-compte à rebours
                    chronoCurrentTime--;
                    if (chronoCurrentTime <= 0) {
                        playMarioKartStartSound();
                        chronoCurrentIntervalIndex = 0;
                        chronoCurrentTime = chronoIntervals[0].duration;
                        speak(String(chronoIntervals[0].instruction).toUpperCase());
                        showMessage(String(chronoIntervals[0].instruction).toUpperCase(), 'chrono');
                    } else if (chronoCurrentTime <= 3 && chronoCurrentTime > 0) {
                        playBeep(660, 0.1);
                    }
                } else { // Intervalles
                    chronoCurrentTime--;
                    if (chronoCurrentTime <= 0) {
                        chronoCurrentIntervalIndex++;
                        if (chronoCurrentIntervalIndex < chronoIntervals.length) {
                            chronoCurrentTime = chronoIntervals[chronoCurrentIntervalIndex].duration;
                            speak(String(chronoIntervals[chronoCurrentIntervalIndex].instruction).toUpperCase());
                            showMessage(String(chronoIntervals[chronoCurrentIntervalIndex].instruction).toUpperCase(), 'chrono');
                        } else {
                            isChronoRunning = false;
                            isChronoPaused = false;
                            chronoCurrentIntervalIndex = -1;
                            chronoCurrentTime = 0;
                            speak("Programme terminé !");
                            showMessage("PROGRAMME TERMINÉ !", 'success');
                            clearInterval(chronoIntervalTimerRef);
                            chronoIntervalTimerRef = null;
                        }
                    } else if (chronoCurrentTime <= 10 && chronoCurrentTime > 0) {
                        playBeep(880, 0.05);
                    }
                }
                updateLocalStorageChronoState();
                updateChronoDisplay();
            }

            // Rend la liste des intervalles
            function renderIntervalsList() {
                let listHtml = '';
                if (chronoIntervals.length === 0) {
                    listHtml = '<p class="text-gray-400">AUCUN INTERVALLE AJOUTÉ.</p>';
                } else {
                    listHtml = `<ul class="space-y-2">`;
                    chronoIntervals.forEach((interval, index) => {
                        listHtml += `
                            <li class="flex flex-col sm:flex-row justify-between items-start sm:items-center bg-[#131313] p-2 rounded-md border border-gray-700">
                                <span class="text-gray-100 text-base sm:text-lg">${Math.floor(interval.duration / 60)}MIN${interval.duration % 60 > 0 ? ` ${interval.duration % 60}S` : ''} - ${String(interval.instruction).toUpperCase()}</span>
                                <div class="flex gap-2 mt-2 sm:mt-0">
                                    <button class="btn-retro-green text-xs px-2 py-1 duplicate-interval-btn" data-index="${index}">DUPLIQUER</button>
                                    <button class="btn-retro-purple text-xs px-2 py-1 edit-interval-btn" data-index="${index}">MODIFIER</button>
                                    <button class="btn-retro-red text-xs px-2 py-1 remove-interval-btn" data-index="${index}">SUPPRIMER</button>
                                </div>
                            </li>
                        `;
                    });
                    listHtml += `</ul>`;
                }
                intervalsListDiv.innerHTML = listHtml;

                intervalsListDiv.querySelectorAll('.remove-interval-btn').forEach(button => {
                    button.onclick = async (event) => {
                        const indexToRemove = parseInt(event.target.dataset.index);
                        if (await showConfirmModal("CONFIRMER LA SUPPRESSION DE L'INTERVALLE ?")) {
                            chronoIntervals.splice(indexToRemove, 1);
                            updateLocalStorageChronoState();
                            showMessage("INTERVALLE SUPPRIMÉE !", 'success');
                            renderIntervalsList();
                            resetIntervalForm();
                        }
                    };
                });

                intervalsListDiv.querySelectorAll('.duplicate-interval-btn').forEach(button => {
                    button.onclick = async (event) => {
                        const indexToDuplicate = parseInt(event.target.dataset.index);
                        const originalInterval = chronoIntervals[indexToDuplicate];
                        if (originalInterval) {
                            chronoIntervals.push({ ...originalInterval });
                            updateLocalStorageChronoState();
                            showMessage("INTERVALLE DUPLIQUÉE !", 'success');
                            renderIntervalsList();
                        }
                    };
                });

                intervalsListDiv.querySelectorAll('.edit-interval-btn').forEach(button => {
                    button.onclick = (event) => {
                        editingIntervalIndex = parseInt(event.target.dataset.index);
                        const intervalToEdit = chronoIntervals[editingIntervalIndex];
                        if (intervalToEdit) {
                            newDurationMinutesInput.value = Math.floor(intervalToEdit.duration / 60);
                            newInstructionInput.value = intervalToEdit.instruction;
                            addUpdateIntervalBtn.textContent = 'METTRE À JOUR';
                            addUpdateIntervalBtn.classList.remove('btn-retro');
                            addUpdateIntervalBtn.classList.add('btn-retro-purple');
                            resetIntervalFormBtn.classList.remove('hidden');
                            showMessage(`MODIFICATION DE L'INTERVALLE ${editingIntervalIndex + 1}.`, 'info');
                        }
                    };
                });
            }

            function resetIntervalForm() {
                newDurationMinutesInput.value = '';
                newInstructionInput.value = '';
                addUpdateIntervalBtn.textContent = 'AJOUTER';
                addUpdateIntervalBtn.classList.remove('btn-retro-purple');
                addUpdateIntervalBtn.classList.add('btn-retro');
                resetIntervalFormBtn.classList.add('hidden');
                editingIntervalIndex = -1;
            }

            addUpdateIntervalBtn.onclick = () => {
                const duration = newDurationMinutesInput.value;
                const instruction = newInstructionInput.value;
                if (duration === '' || instruction.trim() === '') { showMessage("ERREUR: LA DURÉE ET L'INSTRUCTION SONT REQUISES.", 'error'); return; }
                const durationSeconds = parseInt(duration) * 60;

                if (editingIntervalIndex !== -1) {
                    chronoIntervals[editingIntervalIndex] = { duration: durationSeconds, instruction: instruction.trim() };
                    showMessage("INTERVALLE MISE À JOUR !", 'success');
                } else {
                    chronoIntervals.push({ duration: durationSeconds, instruction: instruction.trim() });
                    showMessage("INTERVALLE AJOUTÉE !", 'success');
                }
                updateLocalStorageChronoState();
                renderIntervalsList();
                resetIntervalForm();
            };

            resetIntervalFormBtn.onclick = resetIntervalForm;

            enablePreCountdownCheckbox.onchange = (e) => { enableChronoPreCountdown = e.target.checked; preCountdownDurationSetting.classList.toggle('hidden', !enableChronoPreCountdown); updateLocalStorageChronoState(); };
            chronoPreCountdownDurationInput.onchange = (e) => { chronoPreCountdownDuration = Math.max(1, parseInt(e.target.value) || 1); updateLocalStorageChronoState(); };
            startChronoBtn.onclick = () => {
                if (chronoIntervals.length === 0) { showMessage("ERREUR: AJOUTEZ DES INTERVALLES AVANT DE COMMENCER.", 'error'); return; }
                if (isChronoRunning && !isChronoPaused) return;
                isChronoRunning = true;
                isChronoPaused = false;
                chronoCurrentIntervalIndex = -1;
                if (enableChronoPreCountdown) { chronoCurrentTime = chronoPreCountdownDuration; }
                else { chronoCurrentIntervalIndex = 0; chronoCurrentTime = chronoIntervals[0].duration; speak(String(chronoIntervals[0].instruction).toUpperCase()); showMessage(String(chronoIntervals[0].instruction).toUpperCase(), 'chrono'); }
                updateLocalStorageChronoState();
                updateChronoDisplay();
                showMessage("CHRONO DÉMARRÉ !", 'info');
                if (!chronoIntervalTimerRef) { chronoIntervalTimerRef = setInterval(chronoLoop, 1000); }
            };
            pauseChronoBtn.onclick = () => { isChronoPaused = true; updateLocalStorageChronoState(); updateChronoDisplay(); showMessage("CHRONO EN PAUSE.", 'info'); clearInterval(chronoIntervalTimerRef); chronoIntervalTimerRef = null; };
            resetChronoBtn.onclick = () => {
                isChronoRunning = false;
                isChronoPaused = false;
                chronoCurrentIntervalIndex = -1;
                chronoCurrentTime = 0;
                updateLocalStorageChronoState();
                updateChronoDisplay();
                showMessage("CHRONO RÉINITIALISÉ.", 'success');
                clearInterval(chronoIntervalTimerRef);
                chronoIntervalTimerRef = null;
            };
            skipIntervalBtn.onclick = () => {
                if (!isChronoRunning || chronoCurrentIntervalIndex === -1) { showMessage("LE CHRONO N'EST PAS EN COURS OU EN PHASE DE PRÉ-COMPTE.", 'warning'); return; }
                chronoCurrentIntervalIndex++;
                if (chronoCurrentIntervalIndex < chronoIntervals.length) {
                    chronoCurrentTime = chronoIntervals[chronoCurrentIntervalIndex].duration;
                    speak(String(chronoIntervals[chronoCurrentIntervalIndex].instruction).toUpperCase());
                    showMessage(String(chronoIntervals[chronoCurrentIntervalIndex].instruction).toUpperCase(), 'chrono');
                } else {
                    isChronoRunning = false;
                    isChronoPaused = false;
                    chronoCurrentIntervalIndex = -1;
                    chronoCurrentTime = 0;
                    speak("Programme terminé !");
                    showMessage("PROGRAMME TERMINÉ !", 'success');
                    clearInterval(chronoIntervalTimerRef);
                    chronoIntervalTimerRef = null;
                }
                updateLocalStorageChronoState();
                updateChronoDisplay();
            };

            saveSequenceBtn.onclick = () => {
                const modalDiv = document.createElement('div');
                modalDiv.id = 'save-sequence-modal';
                modalDiv.className = 'fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center p-4 z-50';
                modalDiv.innerHTML = `
                    <div class="bg-gray-800 p-6 rounded-lg border-4 border-purple-500 shadow-xl w-full max-w-md text-white">
                        <h3 class="text-xl sm:text-2xl font-bold mb-4 text-yellow-300">SAUVEGARDER LA SÉQUENCE</h3>
                        <label for="saveSequenceName" class="block text-gray-200 text-sm font-bold mb-2">NOM :</label>
                        <input type="text" id="saveSequenceName" class="input-retro" placeholder="DONNEZ UN NOM À VOTRE SÉQUENCE" value="${document.getElementById('sequenceName').value}" />
                        <div class="flex justify-end space-x-4 mt-6">
                            <button id="cancel-save-sequence-btn" class="btn-retro-red">ANNULER</button>
                            <button id="confirm-save-sequence-btn" class="btn-retro-green">SAUVEGARDER</button>
                        </div>
                    </div>
                `;
                document.getElementById('global-modals-container').appendChild(modalDiv);
                document.getElementById('cancel-save-sequence-btn').onclick = () => modalDiv.remove();
                document.getElementById('confirm-save-sequence-btn').onclick = () => {
                    const name = document.getElementById('saveSequenceName').value;
                    if (!name.trim()) { showMessage("ERREUR: NOM DE LA SÉQUENCE REQUIS.", 'error'); return; }
                    if (chronoIntervals.length === 0) { showMessage("ERREUR: AJOUTEZ DES INTERVALLES AVANT DE SAUVEGARDER.", 'error'); return; }
                    const newSequence = { id: generateUniqueId(), name: name.trim(), intervals: JSON.stringify(chronoIntervals) };
                    intervalSequences.push(newSequence);
                    saveToLocalStorage('intervalSequences', intervalSequences);
                    showMessage("SUCCÈS: SÉQUENCE ENREGISTRÉE !", 'success');
                    modalDiv.remove();
                    document.getElementById('sequenceName').value = '';
                };
            };

            loadSequenceBtn.onclick = () => {
                const modalDiv = document.createElement('div');
                modalDiv.id = 'load-sequence-modal';
                modalDiv.className = 'fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center p-4 z-50';
                let sequencesListHtml = '';
                if (intervalSequences.length === 0) { sequencesListHtml = '<p class="text-gray-400">AUCUNE SÉQUENCE ENREGISTRÉE.</p>'; }
                else {
                    sequencesListHtml = `
                        <ul class="space-y-2 max-h-60 overflow-y-auto pr-2">
                            ${intervalSequences.map(seq => `
                                <li class="flex justify-between items-center bg-gray-700 p-2 rounded-md border border-gray-600">
                                    <span class="text-gray-100 text-base sm:text-lg">${String(seq.name).toUpperCase()}</span>
                                    <div>
                                        <button class="btn-retro-green text-xs px-2 py-1 mr-2 load-sequence-item-btn" data-id="${seq.id}">CHARGER</button>
                                        <button class="btn-retro-red text-xs px-2 py-1 delete-sequence-item-btn" data-id="${seq.id}">SUPPRIMER</button>
                                    </div>
                                </li>
                            `).join('')}
                        </ul>
                    `;
                }
                modalDiv.innerHTML = `
                    <div class="bg-gray-800 p-6 rounded-lg border-4 border-purple-500 shadow-xl w-full max-w-sm text-white">
                        <h3 class="text-xl sm:text-2xl font-bold mb-4 text-yellow-300">CHARGER LA SÉQUENCE</h3>
                        ${sequencesListHtml}
                        <div class="flex justify-end mt-6">
                            <button id="close-load-sequence-btn" class="btn-retro-red">FERMER</button>
                        </div>
                    </div>
                `;
                document.getElementById('global-modals-container').appendChild(modalDiv);
                document.getElementById('close-load-sequence-btn').onclick = () => modalDiv.remove();
                modalDiv.querySelectorAll('.load-sequence-item-btn').forEach(button => {
                    button.onclick = (event) => {
                        const idToLoad = event.target.dataset.id;
                        const sequence = intervalSequences.find(s => s.id === idToLoad);
                        if (sequence) {
                            chronoIntervals = JSON.parse(sequence.intervals);
                            updateLocalStorageChronoState();
                            showMessage(`SUCCÈS: SÉQUENCE "${String(sequence.name).toUpperCase()}" CHARGÉE !`, 'success');
                            modalDiv.remove();
                            isChronoRunning = false;
                            isChronoPaused = false;
                            chronoCurrentIntervalIndex = -1;
                            chronoCurrentTime = 0;
                            updateChronoDisplay();
                            renderIntervalsList();
                        } else {
                            showMessage("ERREUR: SÉQUENCE INTROUVABLE.", 'error');
                        }
                    };
                });
                modalDiv.querySelectorAll('.delete-sequence-item-btn').forEach(button => {
                    button.onclick = async (event) => {
                        const idToDelete = event.target.dataset.id;
                        const isConfirmed = await showConfirmModal("CONFIRMER LA SUPPRESSION DE LA SÉQUENCE ?");
                        if (isConfirmed) {
                            intervalSequences = intervalSequences.filter(s => s.id !== idToDelete);
                            saveToLocalStorage('intervalSequences', intervalSequences);
                            showMessage("SUCCÈS: SÉQUENCE SUPPRIMÉE !", 'success');
                            modalDiv.remove();
                            loadSequenceBtn.click();
                        }
                    };
                });
            };

            renderIntervalsList();
            updateChronoDisplay();
            if (isChronoRunning && !isChronoPaused) {
                if (!chronoIntervalTimerRef) { chronoIntervalTimerRef = setInterval(chronoLoop, 1000); }
            }
        }

        // Rend la vue de progression
        function renderProgressView(container) {
            let selectedExerciseForChart = loadFromLocalStorage('selectedExerciseForChart', 'SÉLECTIONNER UN EXERCICE');
            let selectedExerciseMetrics = loadFromLocalStorage('selectedExerciseMetrics', ['Volume']);
            const hideExerciseHistory = userProfile.hideExerciseHistory;

            let html = `
                <div class="card-retro mb-6">
                    <h2 class="text-3xl sm:text-4xl font-bold text-yellow-300 mb-4 text-center">MA PROGRESSION</h2>

                    <!-- Graphique de poids -->
                    <div class="p-4 rounded-lg border-2 border-blue-700 bg-gray-700 mb-6">
                        <h3 class="text-xl sm:text-2xl font-bold text-yellow-300 mb-3">HISTORIQUE DE POIDS :</h3>
                        <div style="width: 100%; max-width: 800px; margin: 0 auto;">
                            <canvas id="weight-chart"></canvas>
                        </div>
                        <p id="weight-chart-message" class="text-gray-400 text-center mt-2 hidden">AUCUN HISTORIQUE DE POIDS ENCORE.</p>
                    </div>

                    <!-- Graphique de progression par exercice -->
                    <div class="p-4 rounded-lg border-2 border-purple-500 bg-gray-700 mb-6">
                        <h3 class="text-xl sm:text-2xl font-bold text-yellow-300 mb-3">PROGRESSION PAR EXERCICE :</h3>
                        <label for="exerciseSelectChart" class="block text-gray-200 text-sm font-bold mb-2">CHOISIR UN EXERCICE :</label>
                        <select id="exerciseSelectChart" class="select-retro mb-4">
                            <option value="SÉLECTIONNER UN EXERCICE">SÉLECTIONNER UN EXERCICE</option>
                            <!-- Les noms d'exercices uniques seront renseignés ici -->
                        </select>
                        <div class="mb-4">
                            <h4 class="text-base sm:text-lg font-bold text-gray-200 mb-2">MÉTRIQUES À AFFICHER :</h4>
                            <div id="metric-checkboxes" class="flex flex-wrap gap-x-4 gap-y-2">
                                <!-- Les cases à cocher seront rendues ici -->
                            </div>
                        </div>
                        <div style="width: 100%; max-width: 800px; margin: 0 auto;">
                            <canvas id="exercise-chart"></canvas>
                        </div>
                        <p id="exercise-chart-message" class="text-gray-400 text-center mt-2 hidden">SÉLECTIONNEZ UN EXERCICE ET AU MOINS UNE MÉTRIQUE POUR VOIR LE GRAPHIQUE DE PROGRESSION.</p>
                    </div>

                    <!-- Historique des entraînements (déplacé dans Options) -->
                    <div id="workout-logs-section" class="${hideExerciseHistory ? 'hidden' : ''}">
                        <h3 class="text-xl sm:text-2xl font-bold text-yellow-300 mb-3">HISTORIQUE DES ENTRAÎNEMENTS :</h3>
                        <div id="workout-logs-list" class="space-y-4">
                            <!-- Les journaux d'entraînement seront rendus ici -->
                        </div>
                    </div>
                </div>
            `;
            container.innerHTML = html;

            const weightChartCanvas = document.getElementById('weight-chart');
            const weightChartMessage = document.getElementById('weight-chart-message');
            const exerciseSelectChart = document.getElementById('exerciseSelectChart');
            const metricCheckboxes = document.getElementById('metric-checkboxes');
            const exerciseChartCanvas = document.getElementById('exercise-chart');
            const exerciseChartMessage = document.getElementById('exercise-chart-message');
            const workoutLogsListDiv = document.getElementById('workout-logs-list');
            const workoutLogsSection = document.getElementById('workout-logs-section'); // Section to hide/show

            // Rend le graphique de poids
            function renderWeightChart() {
                if (weightChartInstance) { weightChartInstance.destroy(); }
                if (weightHistory.length === 0) { weightChartMessage.classList.remove('hidden'); weightChartCanvas.classList.add('hidden'); return; }
                weightChartMessage.classList.add('hidden');
                weightChartCanvas.classList.remove('hidden');

                const labels = weightHistory.map(entry => new Date(entry.date).toLocaleDateString('fr-FR', { day: '2-digit', month: '2-digit' }));
                const weights = weightHistory.map(entry => entry.weight);
                const imcs = weightHistory.map(entry => entry.imc);

                const ctx = weightChartCanvas.getContext('2d');
                weightChartInstance = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [
                            {
                                label: 'POIDS (KG)',
                                data: weights,
                                borderColor: '#FCD34D',
                                backgroundColor: 'rgba(252, 211, 77, 0.2)',
                                borderWidth: 2,
                                fill: false,
                                tension: 0.3,
                                pointBackgroundColor: '#FCD34D',
                                pointBorderColor: '#fff',
                                pointBorderWidth: 1,
                                pointRadius: 5
                            },
                            {
                                label: 'IMC',
                                data: imcs,
                                borderColor: '#8B5CF6',
                                backgroundColor: 'rgba(139, 92, 246, 0.2)',
                                borderWidth: 2,
                                fill: false,
                                tension: 0.3,
                                yAxisID: 'y1',
                                pointBackgroundColor: '#8B5CF6',
                                pointBorderColor: '#fff',
                                pointBorderWidth: 1,
                                pointRadius: 5
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false,
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: 'HISTORIQUE POIDS ET IMC',
                                color: '#E2E8F0',
                                font: { family: 'VT323', size: 20 }
                            },
                            tooltip: {
                                callbacks: {
                                    title: function(context) { return `DATE: ${context[0].label}`; },
                                    label: function(context) {
                                        let label = context.dataset.label || '';
                                        if (label) { label += ': '; }
                                        if (context.parsed.y !== null) { label += context.parsed.y; if (context.dataset.label === 'POIDS (KG)') label += ' KG'; }
                                        return label;
                                    }
                                },
                                titleFont: { family: 'VT323', size: 14 },
                                bodyFont: { family: 'VT323', size: 12 },
                                backgroundColor: 'rgba(45, 55, 72, 0.9)',
                                borderColor: '#A78BFA',
                                borderWidth: 1,
                                borderRadius: 6
                            }
                        },
                        scales: {
                            x: {
                                title: { display: true, text: 'DATE', color: '#E2E8F0', font: { family: 'VT323', size: 16 } },
                                ticks: { color: '#CBD5E0', font: { family: 'VT323', size: 12 } },
                                grid: { color: 'rgba(255, 255, 255, 0.1)' }
                            },
                            y: {
                                title: { display: true, text: 'POIDS (KG)', color: '#E2E8F0', font: { family: 'VT323', size: 16 } },
                                ticks: { color: '#CBD5E0', font: { family: 'VT323', size: 12 } },
                                grid: { color: 'rgba(255, 255, 255, 0.1)' }
                            },
                            y1: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                title: { display: true, text: 'IMC', color: '#E2E8F0', font: { family: 'VT323', size: 16 } },
                                ticks: { color: '#CBD5E0', font: { family: 'VT323', size: 12 } },
                                grid: { drawOnChartArea: false }
                            }
                        }
                    }
                });
            }

            // Remplit la liste déroulante des exercices
            const uniqueExerciseNames = ['SÉLECTIONNER UN EXERCICE', ...new Set(workoutLogs.map(log => log.exerciseName))].sort();
            exerciseSelectChart.innerHTML = uniqueExerciseNames.map(name => `<option value="${name}" ${name === selectedExerciseForChart ? 'selected' : ''}>${name}</option>` ).join('');

            // Rend les cases à cocher des métriques
            const metrics = ['Répétitions/Durée', 'Séries/Rounds', 'Poids', 'Volume'];
            metricCheckboxes.innerHTML = metrics.map(metric => `
                <label class="flex items-center text-gray-300 text-sm sm:text-base">
                    <input type="checkbox" data-metric="${metric}" ${selectedExerciseMetrics.includes(metric) ? 'checked' : ''} class="mr-2 h-4 w-4 text-purple-600 rounded border-gray-300 focus:ring-purple-500" />
                    ${metric.toUpperCase()}
                </label>
            `).join('');

            // Écouteur d'événements pour la sélection d'exercice
            exerciseSelectChart.onchange = (e) => { selectedExerciseForChart = e.target.value; saveToLocalStorage('selectedExerciseForChart', selectedExerciseForChart); renderExerciseChart(); };

            // Écouteur d'événements pour les cases à cocher des métriques
            metricCheckboxes.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
                checkbox.onchange = (e) => {
                    const metric = e.target.dataset.metric;
                    if (e.target.checked) { if (!selectedExerciseMetrics.includes(metric)) { selectedExerciseMetrics.push(metric); } }
                    else { selectedExerciseMetrics = selectedExerciseMetrics.filter(m => m !== metric); }
                    saveToLocalStorage('selectedExerciseMetrics', selectedExerciseMetrics);
                    renderExerciseChart();
                };
            });

            // Rend le graphique d'exercices
            function renderExerciseChart() {
                if (exerciseChartInstance) { exerciseChartInstance.destroy(); }
                if (!selectedExerciseForChart || selectedExerciseForChart === 'SÉLECTIONNER UN EXERCICE' || selectedExerciseMetrics.length === 0) {
                    exerciseChartMessage.classList.remove('hidden'); exerciseChartCanvas.classList.add('hidden'); return;
                }
                const filteredLogs = workoutLogs
                    .filter(log => log.exerciseName === selectedExerciseForChart)
                    .sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());
                if (filteredLogs.length === 0) {
                    exerciseChartMessage.textContent = `AUCUNE DONNÉE POUR "${selectedExerciseForChart.toUpperCase()}".`;
                    exerciseChartMessage.classList.remove('hidden'); exerciseChartCanvas.classList.add('hidden'); return;
                }
                exerciseChartMessage.classList.add('hidden');
                exerciseChartCanvas.classList.remove('hidden');

                const labels = filteredLogs.map(log => new Date(log.date).toLocaleDateString('fr-FR', { day: '2-digit', month: '2-digit' }));
                const datasets = [];
                const colors = ['#FCD34D', '#A78BFA', '#10B981', '#EF4444'];

                selectedExerciseMetrics.forEach((metric, index) => {
                    let data = [];
                    let label = metric.toUpperCase();
                    let yAxisID = `y${index}`;

                    if (metric === 'Volume') {
                        data = filteredLogs.map(log => {
                            const sets = parseFloat(String(log.sets)) || 0;
                            let reps = parseFloat(String(log.reps)) || 0;
                            const weight = parseFloat(String(log.weight)) || 0;
                            if (String(log.reps).toUpperCase().includes('MIN')) {
                                const match = String(log.reps).match(/(\d+(\.\d+)?)\s*MIN/i);
                                if (match) reps = parseFloat(match[1]) * 60;
                            } else if (String(log.reps).toUpperCase().includes('SEC')) {
                                const match = String(log.reps).match(/(\d+(\.\d+)?)\s*SEC/i);
                                if (match) reps = parseFloat(match[1]);
                            }
                            return (sets * reps * (weight > 0 ? weight : 1));
                        });
                        label = 'VOLUME (KG OU UNITÉ TEMPS)';
                    } else if (metric === 'Poids') {
                        data = filteredLogs.map(log => log.weight);
                        label = 'POIDS (KG)';
                    } else if (metric === 'Séries/Rounds') {
                        data = filteredLogs.map(log => parseFloat(String(log.sets)) || 0);
                        label = 'SÉRIES / ROUNDS';
                    } else if (metric === 'Répétitions/Durée') {
                        data = filteredLogs.map(log => {
                            let reps = parseFloat(String(log.reps)) || 0;
                            if (String(log.reps).toUpperCase().includes('MIN')) {
                                const match = String(log.reps).match(/(\d+(\.\d+)?)\s*MIN/i);
                                if (match) reps = parseFloat(match[1]);
                            } else if (String(log.reps).toUpperCase().includes('SEC')) {
                                const match = String(log.reps).match(/(\d+(\.\d+)?)\s*SEC/i);
                                if (match) reps = parseFloat(match[1]);
                            }
                            return reps;
                        });
                        label = 'RÉPÉTITIONS / DURÉE';
                    }

                    datasets.push({
                        label: label,
                        data: data,
                        borderColor: colors[index % colors.length],
                        backgroundColor: Chart.helpers.color(colors[index % colors.length]).alpha(0.2).rgbString(),
                        borderWidth: 2,
                        fill: false,
                        tension: 0.3,
                        pointBackgroundColor: colors[index % colors.length],
                        pointBorderColor: '#fff',
                        pointBorderWidth: 1,
                        pointRadius: 5,
                        yAxisID: yAxisID
                    });
                });

                const ctx = exerciseChartCanvas.getContext('2d');
                exerciseChartInstance = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false,
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: `PROGRESSION POUR ${selectedExerciseForChart.toUpperCase()}`,
                                color: '#E2E8F0',
                                font: { family: 'VT323', size: 20 }
                            },
                            tooltip: {
                                callbacks: {
                                    title: function(context) { return `DATE: ${context[0].label}`; },
                                    label: function(context) {
                                        let label = context.dataset.label || '';
                                        if (label) { label += ': '; }
                                        if (context.parsed.y !== null) {
                                            label += context.parsed.y;
                                            if (context.dataset.label === 'POIDS (KG)') label += ' KG';
                                            else if (context.dataset.label.includes('DURÉE') || context.dataset.label.includes('VOLUME') && !context.dataset.label.includes('KG')) label += ' s';
                                        }
                                        return label;
                                    }
                                },
                                titleFont: { family: 'VT323', size: 14 },
                                bodyFont: { family: 'VT323', size: 12 },
                                backgroundColor: 'rgba(45, 55, 72, 0.9)',
                                borderColor: '#A78BFA',
                                borderWidth: 1,
                                borderRadius: 6
                            }
                        },
                        scales: {
                            x: {
                                title: { display: true, text: 'DATE', color: '#E2E8F0', font: { family: 'VT323', size: 16 } },
                                ticks: { color: '#CBD5E0', font: { family: 'VT323', size: 12 } },
                                grid: { color: 'rgba(255, 255, 255, 0.1)' }
                            },
                            y: {
                                title: { display: true, text: datasets[0]?.label || 'VALEUR', color: '#E2E8F0', font: { family: 'VT323', size: 16 } },
                                ticks: { color: '#CBD5E0', font: { family: 'VT323', size: 12 } },
                                grid: { color: 'rgba(255, 255, 255, 0.1)' }
                            },
                            ...(selectedExerciseMetrics.length > 1 && {
                                y1: {
                                    type: 'linear',
                                    position: 'right',
                                    grid: { drawOnChartArea: false },
                                    ticks: { color: '#CBD5E0', font: { family: 'VT323', size: 12 } },
                                    title: { display: true, text: datasets[1]?.label || 'VALEUR', color: '#E2E8F0', font: { family: 'VT323', size: 16 } }
                                },
                                y2: {
                                    type: 'linear',
                                    position: 'right',
                                    grid: { drawOnChartArea: false },
                                    ticks: { color: '#CBD5E0', font: { family: 'VT323', size: 12 } },
                                    title: { display: true, text: datasets[2]?.label || 'VALEUR', color: '#E2E8F0', font: { family: 'VT323', size: 16 } }
                                },
                                y3: {
                                    type: 'linear',
                                    position: 'right',
                                    grid: { drawOnChartArea: false },
                                    ticks: { color: '#CBD5E0', font: { family: 'VT323', size: 12 } },
                                    title: { display: true, text: datasets[3]?.label || 'VALEUR', color: '#E2E8F0', font: { family: 'VT323', size: 16 } }
                                }
                            })
                        }
                    }
                });
            }

            renderWeightChart();
            renderExerciseChart();
        }

        // Rend la vue des trophées
        function renderTrophyRoomView(container) {
            let html = `
                <div class="card-retro mb-6">
                    <h2 class="text-3xl sm:text-4xl font-bold text-yellow-300 mb-4 text-center">MES TROPHÉES</h2>
                    <div id="trophies-list" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
                        <!-- Les trophées seront rendus ici -->
                    </div>
                    <p id="no-trophies-message" class="text-gray-400 text-center mt-4 hidden">AUCUN TROPHÉE DÉBLOQUÉ POUR L'INSTANT. CONTINUEZ À VOUS ENTRAÎNER POUR EN GAGNER !</p>
                </div>
            `;
            container.innerHTML = html;
            const trophiesListDiv = document.getElementById('trophies-list');
            const noTrophiesMessage = document.getElementById('no-trophies-message');

            if (userProfile.earnedTrophies.length === 0) {
                noTrophiesMessage.classList.remove('hidden');
                return;
            }

            const sortedTrophies = [...userProfile.earnedTrophies].sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());

            trophiesListDiv.innerHTML = sortedTrophies.map(trophy => `
                <div class="bg-gray-700 p-4 rounded-lg border-2 border-purple-500 shadow-lg text-center">
                    <span class="text-5xl mb-2 block">🏆</span>
                    <h3 class="text-xl font-bold text-yellow-300 mb-2">${String(trophy.name).toUpperCase()}</h3>
                    <p class="text-gray-300 text-sm">${String(trophy.description).toUpperCase()}</p>
                    <p class="text-gray-400 text-xs mt-2">DÉBLOQUÉ LE: ${new Date(trophy.timestamp).toLocaleDateString('fr-FR')}</p>
                </div>
            `).join('');
            noTrophiesMessage.classList.add('hidden');
        }

        // Rend la vue des options
        function renderOptionsView(container) {
            let html = `
                <div class="card-retro mb-6">
                    <h2 class="text-3xl sm:text-4xl font-bold text-yellow-300 mb-4 text-center">OPTIONS</h2>

                    <!-- Section Audio -->
                    <div class="p-4 rounded-lg border-2 border-blue-700 bg-gray-700 mb-6">
                        <h3 class="text-xl sm:text-2xl font-bold text-yellow-300 mb-3">AUDIO :</h3>
                        <div class="flex items-center justify-between mb-4">
                            <label for="audio-toggle" class="text-gray-200 text-base sm:text-lg font-bold">ACTIVER LE SON :</label>
                            <button id="audio-toggle" class="btn-retro ${isAudioActive ? 'btn-retro-green' : 'btn-retro-red'} px-4 py-2">
                                ${isAudioActive ? 'ACTIVÉ' : 'DÉSACTIVÉ'}
                            </button>
                        </div>
                        <div class="mb-4">
                            <label for="master-volume" class="block text-gray-200 text-base sm:text-lg font-bold mb-2">VOLUME PRINCIPAL :</label>
                            <input type="range" id="master-volume" min="0" max="1" step="0.01" value="${masterVolume}" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                            <p class="text-center text-sm text-gray-400 mt-1">VALEUR: <span id="volume-value">${Math.round(masterVolume * 100)}%</span></p>
                        </div>
                    </div>

                    <!-- Section Gestion des Données -->
                    <div class="p-4 rounded-lg border-2 border-purple-500 bg-gray-700 mb-6">
                        <h3 class="text-xl sm:text-2xl font-bold text-yellow-300 mb-3">GESTION DES DONNÉES :</h3>
                        <button id="export-data-btn" class="btn-retro w-full mb-4">EXPORTER TOUTES LES DONNÉES</button>
                        <input type="file" id="import-data-input" class="hidden" accept="application/json" />
                        <button id="import-data-btn" class="btn-retro-purple w-full mb-4">IMPORTER DES DONNÉES</button>
                        <button id="reset-app-btn" class="btn-retro-red w-full">RÉINITIALISER L'APPLICATION</button>
                    </div>

                    <!-- Section Historique des entraînements -->
                    <div class="p-4 rounded-lg border-2 border-blue-700 bg-gray-700 mb-6">
                        <h3 class="text-xl sm:text-2xl font-bold text-yellow-300 mb-3">HISTORIQUE DES ENTRAÎNEMENTS :</h3>
                        <div class="flex items-center justify-between mb-4">
                            <label for="hide-exercise-history-toggle" class="text-gray-200 text-base sm:text-lg font-bold">CACHER L'HISTORIQUE :</label>
                            <button id="hide-exercise-history-toggle" class="btn-retro ${userProfile.hideExerciseHistory ? 'btn-retro-red' : 'btn-retro-green'} px-4 py-2">
                                ${userProfile.hideExerciseHistory ? 'CACHÉ' : 'AFFICHÉ'}
                            </button>
                        </div>
                        <div id="workout-logs-list-options" class="space-y-4 ${userProfile.hideExerciseHistory ? 'hidden' : ''}">
                            ${workoutLogs.length === 0 ? '<p class="text-gray-400">AUCUN ENTRAÎNEMENT ENREGISTRÉ.</p>' :
                                workoutLogs.map(log => `
                                <div class="bg-gray-800 p-3 rounded-md border border-gray-600 shadow-sm flex flex-col sm:flex-row justify-between items-start sm:items-center">
                                    <div>
                                        <p class="text-gray-100 text-base sm:text-lg font-bold">${String(log.exerciseName).toUpperCase()}</p>
                                        <p class="text-gray-300 text-sm">DATE: ${new Date(log.date).toLocaleDateString('fr-FR')}</p>
                                        <p class="text-gray-300 text-sm">SÉRIES: ${log.sets} / RÉP: ${log.reps} ${log.weight ? `/ POIDS: ${log.weight} KG` : ''}</p>
                                        <p class="text-gray-300 text-sm">RESSENTI: ${String(log.feeling).toUpperCase()}</p>
                                    </div>
                                    <button class="btn-retro-red text-xs px-2 py-1 mt-2 sm:mt-0 delete-workout-log-btn" data-id="${log.id}">SUPPRIMER</button>
                                </div>
                                `).join('')
                            }
                        </div>
                    </div>

                    <!-- Section API Key -->
                    <div class="p-4 rounded-lg border-2 border-yellow-500 bg-gray-700">
                        <h3 class="text-xl sm:text-2xl font-bold text-yellow-300 mb-3">CLÉ API (POUR L'IA) :</h3>
                        <label for="api-key-input" class="block text-gray-200 text-sm font-bold mb-2">VOTRE CLÉ API GEMINI :</label>
                        <input type="password" id="api-key-input" class="input-retro mb-4" placeholder="ENTREZ VOTRE CLÉ API ICI" value="${userProfile.apiKey || ''}" />
                        <button id="save-api-key-btn" class="btn-retro-green w-full">ENREGISTRER CLÉ API</button>
                        <p class="text-xs text-gray-400 mt-2">NÉCESSAIRE POUR LA GÉNÉRATION DE RECETTES ET DE PROGRAMMES D'ENTRAÎNEMENT PAR L'IA.</p>
                    </div>
                </div>
            `;
            container.innerHTML = html;

            const audioToggleBtn = document.getElementById('audio-toggle');
            const masterVolumeSlider = document.getElementById('master-volume');
            const volumeValueDisplay = document.getElementById('volume-value');
            const exportDataBtn = document.getElementById('export-data-btn');
            const importDataInput = document.getElementById('import-data-input');
            const importDataBtn = document.getElementById('import-data-btn');
            const resetAppBtn = document.getElementById('reset-app-btn');
            const hideExerciseHistoryToggle = document.getElementById('hide-exercise-history-toggle');
            const workoutLogsListOptions = document.getElementById('workout-logs-list-options');
            const apiKeyInput = document.getElementById('api-key-input');
            const saveApiKeyBtn = document.getElementById('save-api-key-btn');

            // Initialisation de l'affichage du volume
            volumeValueDisplay.textContent = `${Math.round(masterVolume * 100)}%`;

            // Gestion du volume
            masterVolumeSlider.oninput = (e) => {
                masterVolume = parseFloat(e.target.value);
                Tone.Master.volume.value = masterVolume === 0 ? -Infinity : 20 * Math.log10(masterVolume);
                volumeValueDisplay.textContent = `${Math.round(masterVolume * 100)}%`;
                saveToLocalStorage('masterVolume', masterVolume);
            };

            // Toggle audio
            audioToggleBtn.onclick = toggleAudioActive;

            // Exportation des données
            exportDataBtn.onclick = () => {
                const data = {
                    userProfile: userProfile,
                    weeklyMealPlan: weeklyMealPlan,
                    workoutLogs: workoutLogs,
                    weightHistory: weightHistory,
                    intervalSequences: intervalSequences,
                    shifts: shifts,
                    savedWorkoutProgram: workoutProgram,
                    chronoState: {
                        intervals: chronoIntervals,
                        currentTime: chronoCurrentTime,
                        currentIntervalIndex: chronoCurrentIntervalIndex,
                        isRunning: isChronoRunning,
                        isPaused: isChronoPaused,
                        enablePreCountdown: enableChronoPreCountdown,
                        preCountdownDuration: chronoPreCountdownDuration
                    }
                };
                const dataStr = JSON.stringify(data, null, 2);
                const blob = new Blob([dataStr], { type: "application/json" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `fitquest_data_${formatDateToYYYYMMDD(new Date())}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showMessage("DONNÉES EXPORTÉES AVEC SUCCÈS !", 'success');
            };

            // Importation des données
            importDataBtn.onclick = () => { importDataInput.click(); };
            importDataInput.onchange = async (event) => {
                const file = event.target.files[0];
                if (!file) { return; }
                if (await showConfirmModal("IMPORTER DES DONNÉES ÉCRASERA LES DONNÉES ACTUELLES. CONTINUER ?")) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const importedData = JSON.parse(e.target.result);
                            userProfile = importedData.userProfile || userProfile;
                            weeklyMealPlan = importedData.weeklyMealPlan || weeklyMealPlan;
                            workoutLogs = importedData.workoutLogs || workoutLogs;
                            weightHistory = importedData.weightHistory || weightHistory;
                            intervalSequences = importedData.intervalSequences || intervalSequences;
                            shifts = importedData.shifts || shifts;
                            workoutProgram = importedData.savedWorkoutProgram || workoutProgram;
                            const importedChronoState = importedData.chronoState || {};
                            chronoIntervals = importedChronoState.intervals || [];
                            chronoCurrentTime = importedChronoState.currentTime || 0;
                            chronoCurrentIntervalIndex = importedChronoState.currentIntervalIndex !== undefined ? importedChronoState.currentIntervalIndex : -1;
                            isChronoRunning = importedChronoState.isRunning || false;
                            isChronoPaused = importedChronoState.isPaused || false;
                            enableChronoPreCountdown = importedChronoState.enablePreCountdown !== undefined ? importedChronoState.enablePreCountdown : true;
                            chronoPreCountdownDuration = importedChronoState.preCountdownDuration || 10;

                            saveToLocalStorage('userProfile', userProfile);
                            saveToLocalStorage('weeklyMealPlan', weeklyMealPlan);
                            saveToLocalStorage('workoutLogs', workoutLogs);
                            saveToLocalStorage('weightHistory', weightHistory);
                            saveToLocalStorage('intervalSequences', intervalSequences);
                            saveToLocalStorage('shifts', shifts);
                            saveToLocalStorage('savedWorkoutProgram', workoutProgram);
                            updateLocalStorageChronoState(); // Save imported chrono state

                            showMessage("DONNÉES IMPORTÉES AVEC SUCCÈS ! L'APPLICATION VA SE RECHARGER.", 'success');
                            setTimeout(() => location.reload(), 2000);
                        } catch (error) {
                            console.error("Erreur lors de l'importation des données:", error);
                            showMessage("ERREUR: FICHIER DE DONNÉES INVALIDE.", 'error');
                        }
                    };
                    reader.readAsText(file);
                }
            };

            // Réinitialisation de l'application
            resetAppBtn.onclick = async () => {
                if (await showConfirmModal("CETTE ACTION SUPPRIMERA TOUTES VOS DONNÉES. ÊTES-VOUS SÛR ?")) {
                    localStorage.clear();
                    showMessage("APPLICATION RÉINITIALISÉE ! RECHARGEMENT...", 'success');
                    setTimeout(() => location.reload(), 2000);
                }
            };

            // Toggle historique des entraînements
            hideExerciseHistoryToggle.onclick = () => {
                userProfile.hideExerciseHistory = !userProfile.hideExerciseHistory;
                saveToLocalStorage('userProfile', userProfile);
                renderOptionsView(container); // Re-render options view to update toggle button and list visibility
                if (currentPage === 'progress') renderProgressView(document.getElementById('main-content')); // Also update progress view if on it
            };

            // Gestion de la clé API
            saveApiKeyBtn.onclick = () => {
                userProfile.apiKey = apiKeyInput.value.trim();
                saveToLocalStorage('userProfile', userProfile);
                showMessage("CLÉ API ENREGISTRÉE !", 'success');
            };

            // Rendu de l'historique des entraînements (dans les options)
            const deleteWorkoutLogButtons = workoutLogsListOptions.querySelectorAll('.delete-workout-log-btn');
            deleteWorkoutLogButtons.forEach(button => {
                button.onclick = async (event) => {
                    const logId = event.target.dataset.id;
                    if (await showConfirmModal("CONFIRMER LA SUPPRESSION DE CET ENTRAÎNEMENT ?")) {
                        workoutLogs = workoutLogs.filter(log => log.id !== logId);
                        saveToLocalStorage('workoutLogs', workoutLogs);
                        showMessage("ENTRAÎNEMENT SUPPRIMÉ !", 'success');
                        renderOptionsView(container);
                        if (currentPage === 'progress') renderProgressView(document.getElementById('main-content'));
                    }
                };
            });
        }

        // Attache les écouteurs d'événements initiaux
        function attachEventListeners() {
            document.querySelectorAll('.nav-item').forEach(button => {
                button.onclick = (event) => {
                    const page = event.currentTarget.dataset.page;
                    renderPage(page);
                };
            });
            document.getElementById('home-button').onclick = () => renderPage('daily_plan');
            document.getElementById('save-profile-btn').onclick = handleSaveProfile;
        }

        // Chargement initial de l'application
        window.onload = initializeApp;
    </script>
</body>
</html>
