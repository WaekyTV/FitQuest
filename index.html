<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FitQuest</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
    <style>
        body { font-family: 'VT323', monospace; background-color: #1a202c; color: #e2e8f0; margin: 0; padding: 0; display: flex; flex-direction: column; min-height: 100vh; overflow-x: hidden; }
        .font-vt323 { font-family: 'VT323', monospace; }
        .btn-retro { background-color: #2563eb; color: white; font-weight: bold; padding: 0.75rem 1rem; border-radius: 0.375rem; border: 2px solid #1e40af; box-shadow: 4px 4px 0 0 rgba(0,0,0,0.5); transition: all 0.1s ease-in-out; cursor: pointer; }
        .btn-retro:hover { background-color: #1d4ed8; }
        .btn-retro:active { box-shadow: none; transform: translateX(4px) translateY(4px); }
        .btn-retro-purple { background-color: #9333ea; color: white; font-weight: bold; padding: 0.75rem 1rem; border-radius: 0.375rem; border: 2px solid #6b21a8; box-shadow: 4px 4px 0 0 rgba(0,0,0,0.5); transition: all 0.1s ease-in-out; cursor: pointer; }
        .btn-retro-purple:hover { background-color: #7e22ce; }
        .btn-retro-purple:active { box-shadow: none; transform: translateX(4px) translateY(4px); }
        .btn-retro-green { background-color: #16a34a; color: white; font-weight: bold; padding: 0.75rem 1rem; border-radius: 0.375rem; border: 2px solid #15803d; box-shadow: 4px 4px 0 0 rgba(0,0,0,0.5); transition: all 0.1s ease-in-out; cursor: pointer; }
        .btn-retro-green:hover { background-color: #14713c; }
        .btn-retro-green:active { box-shadow: none; transform: translateX(4px) translateY(4px); }
        .btn-retro-red { background-color: #dc2626; color: white; font-weight: bold; padding: 0.75rem 1rem; border-radius: 0.375rem; border: 2px solid #b91c1c; box-shadow: 4px 4px 0 0 rgba(0,0,0,0.5); transition: all 0.1s ease-in-out; cursor: pointer; }
        .btn-retro-red:hover { background-color: #c01b1b; }
        .btn-retro-red:active { box-shadow: none; transform: translateX(4px) translateY(4px); }
        .card-retro { background-color: #2d3748; padding: 1.5rem; border-radius: 0.5rem; border: 4px solid #a78bfa; box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1), 0 4px 6px -2px rgba(0,0,0,0.05); color: white; }
        .input-retro, .select-retro { box-shadow: inset 0 2px 4px 0 rgba(0,0,0,0.1); -webkit-appearance: none; -moz-appearance: none; appearance: none; border: 2px solid #2563eb; border-radius: 0.25rem; width: 100%; padding: 0.5rem 0.75rem; line-height: 1.25; outline: none; transition: all 0.1s ease-in-out; color: #dfdfdf; background-color: #131313; }
        .input-retro:focus, .select-retro:focus { ring: 2px; ring-color: #a78bfa; border-color: #a78bfa; }
        .select-retro option { color: #dfdfdf; background-color: #131313; }
        .table-retro { min-width: 100%; background-color: #4a5568; border-radius: 0.5rem; border: 2px solid #2563eb; }
        .table-retro th { padding: 0.5rem 1rem; text-align: left; font-size: 0.875rem; font-weight: 600; color: #fcd34d; border-bottom: 2px solid #2563eb; }
        .table-retro td { padding: 0.75rem 1rem; font-size: 0.875rem; border-bottom: 1px solid #4a5568; color: #dfdfdf; }
        .table-retro tbody tr:last-child td { border-bottom: 0; }
        .btn-icon { font-size: 1.25rem; padding: 0.25rem; border-radius: 9999px; background-color: transparent; color: white; border: none; cursor: pointer; transition: background-color 0.2s ease-in-out; }
        .btn-icon:hover { background-color: #4a5568; }
        .spinner { border: 4px solid rgba(255, 255, 255, 0.3); border-radius: 50%; border-top: 4px solid #fff; width: 20px; height: 20px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .xp-bar-container { position: relative; width: 100%; height: 24px; background-color: #333; border: 2px solid #a0a0a0; border-radius: 4px; overflow: hidden; display: flex; align-items: center; justify-content: center; box-shadow: inset 0 0 5px rgba(0,0,0,0.5); }
        .xp-bar-fill { height: 100%; background: linear-gradient(to right, #16a34a, #15803d); transition: width 0.5s ease-in-out, background 0.5s ease-in-out; position: absolute; left: 0; top: 0; border-radius: 2px; animation: xp-glow 1.5s infinite alternate; }
        @keyframes xp-glow { from { box-shadow: 0 0 5px #16a34a; } to { box-shadow: 0 0 15px #15803d; } }
        .xp-bar-text { position: absolute; color: #1a202c; font-size: 0.85rem; font-weight: bold; z-index: 10; text-shadow: 0 0 2px white, 0 0 2px white, 0 0 2px white; }
        .notification-container { position: fixed; z-index: 1000; pointer-events: none; display: flex; flex-direction: column; gap: 10px; }
        .notification { padding: 1rem; border-radius: 0.5rem; box-shadow: 0 4px 6px rgba(0,0,0,0.3); opacity: 0; transition: opacity 0.5s ease-out, transform 0.5s ease-out; font-family: 'VT323', monospace; display: flex; align-items: center; gap: 0.5rem; min-width: 250px; max-width: 90%; }
        .notification-container-bottom-right { bottom: 20px; right: 20px; align-items: flex-end; }
        .notification.general, .notification.tip { transform: translateX(100%); background-color: #2563eb; color: white; border: 2px solid #1e40af; text-align: right; border-top-right-radius: 0; border-bottom-right-radius: 0; }
        .notification.general.error { background-color: #dc2626; border-color: #b91c1c; }
        .notification.general.warning { background-color: #d97706; border-color: #9a3412; }
        .notification.general.success { background-color: #16a34a; border-color: #15803d; }
        .notification.general.chrono { background-color: #9333ea; border-color: #6b21a8; }
        .notification.tip { background-color: #059669; border-color: #065F46; }
        .notification.general.show, .notification.tip.show { transform: translateX(0); opacity: 1; }
        @media (max-width: 640px) {
            .notification-container-bottom-right { left: 50%; transform: translateX(-50%); right: auto; width: 100%; align-items: center; top: auto; bottom: 20px; flex-direction: column-reverse; }
            .notification { width: 90%; margin: 0 auto; border-radius: 0.5rem; text-align: center; flex-direction: column; gap: 0.25rem; }
            .notification.general, .notification.tip { transform: translateX(0) !important; border-radius: 0.5rem; }
            .nav-scroll-container { overflow-x: auto; -webkit-overflow-scrolling: touch; scrollbar-width: none; -ms-overflow-style: none; }
            .nav-scroll-container::-webkit-scrollbar { display: none; }
            .nav-items-wrapper { display: flex; flex-wrap: nowrap; padding-bottom: 5px; }
            .nav-item { flex-shrink: 0; min-width: 80px; padding: 0.5rem 0.75rem; margin: 0 0.25rem; }
            .main-content-area { padding-bottom: 6rem; }
        }
    </style>
</head>
<body class="font-vt323 text-white bg-gray-900 min-h-screen flex flex-col">
    <div id="loading-screen" class="fixed inset-0 flex flex-col items-center justify-center bg-gray-900 font-vt323 text-white z-[999]">
        <div class="text-4xl sm:text-5xl text-yellow-300 mb-8 animate-bounce">FitQuest</div>
        <div class="w-64 sm:w-80 h-8 bg-gray-700 border-4 border-yellow-500 rounded-lg overflow-hidden relative">
            <div id="loading-progress-bar" class="h-full bg-green-500 transition-all duration-500 ease-linear" style="width: 0%;"></div>
            <div id="loading-progress-text" class="absolute inset-0 flex items-center justify-center text-lg font-bold text-gray-900">0% CHARGEMENT...</div>
        </div>
        <div id="loading-message" class="mt-8 p-3 rounded-md hidden"></div>
        <p id="audio-inactive-message" class="text-gray-400 text-sm sm:text-base mt-4 text-center hidden">AUDIO DESACTIVE. ACTIVEZ LE SON VIA LES OPTIONS POUR LES EFFETS AUDIO ET LA SYNTHESE VOCALE.</p>
    </div>
    <div id="app-container" class="min-h-screen flex flex-col hidden">
        <header class="bg-gradient-to-r from-blue-700 to-indigo-800 text-yellow-300 p-5 shadow-md border-b-4 border-purple-500 rounded-b-lg">
            <div class="flex items-center justify-center relative">
                <button id="home-button" class="absolute left-0 top-1/2 -translate-y-1/2 p-2 rounded-full hover:bg-blue-600 transition-colors duration-200" title="Retour Ã  l'accueil">
                    <i data-lucide="home" class="text-yellow-300 text-3xl"></i>
                </button>
                <h1 class="text-4xl sm:text-5xl lg:text-6xl font-bold text-center tracking-widest leading-tight flex-1">FITQUEST</h1>
            </div>
            <p class="text-center text-lg sm:text-xl mt-2 opacity-90">TON PROGRAMME PERSONNALISE</p>
            <p class="text-center text-sm sm:text-base mt-1 opacity-80 text-gray-300">GENERE PAR POXEL, TON IA PERSONNELLE</p>
            <p id="user-id-display" class="text-center text-xs sm:text-sm mt-2 opacity-80 text-gray-300 hidden">ID UTILISATEUR: <span id="user-id-value" class="font-mono break-all"></span></p>
            <div class="flex items-center justify-center my-4 px-4">
                <i data-lucide="zap" class="text-yellow-400 text-3xl sm:text-4xl mr-2"></i>
                <div class="flex-1 xp-bar-container">
                    <div id="xp-bar-fill" class="xp-bar-fill" style="width: 0%;"></div>
                    <span id="xp-bar-text" class="xp-bar-text">LVL 0 : 0/100 XP</span>
                </div>
            </div>
            <div class="mt-4 p-3 bg-gray-700 rounded-md border-2 border-blue-700">
                <h3 class="text-lg sm:text-xl font-bold text-yellow-300 mb-2">TON PROFIL ET STATS VITALES :</h3>
                <div class="flex flex-col sm:flex-row sm:items-end gap-3 justify-center">
                    <div class="flex-1 w-full sm:w-auto">
                        <label for="userHeight" class="block text-gray-200 text-sm font-bold mb-1">TAILLE (CM) :</label>
                        <input type="number" id="userHeight" class="input-retro" placeholder="EX: 175" />
                    </div>
                    <div class="flex-1 w-full sm:w-auto">
                        <label for="userWeight" class="block text-gray-200 text-sm font-bold mb-1">POIDS (KG) :</label>
                        <input type="number" id="userWeight" class="input-retro" placeholder="EX: 70" />
                    </div>
                    <button id="save-profile-btn" class="btn-retro-green sm:w-auto w-full px-5 py-2">ENREGISTRER</button>
                </div>
                <div id="imc-display" class="mt-3 text-center text-lg text-white hidden">
                    <p>TON IMC : <span id="imc-value" class="font-bold text-yellow-300"></span></p>
                    <p>CATEGORIE : <span id="imc-category" class="font-bold text-blue-400"></span></p>
                    <p>PROTEINES ESTIMEES : <span id="protein-needs" class="font-bold text-yellow-300"></span></p>
                    <div class="text-xs text-gray-400 mt-2">
                        <p>**IMC INF. A 16.5 :** INSUFFISANCE PONDERALE (DENUTRITION SEVERE)</p>
                        <p>**IMC 16.5 A 18.4 :** INSUFFISANCE PONDERALE</p>
                        <p>**IMC 25 A 26.9 :** SURPOIDS (PRE-OBESITE)</p>
                        <p>**IMC 27 A 29.9 :** OBESITE CLASSE I</p>
                        <p>**IMC 30 A 34.9 :** OBESITE CLASSE II (SEVERE)</p>
                        <p>**IMC 35 A 39.9 :** OBESITE CLASSE II (SEVERE)</p>
                        <p>**IMC SUP. OU EGAL A 40 :** OBESITE CLASSE III (MORBIDE OU MASSIVE)</p>
                        <p class="mt-2">**BESOINS EN PROTEINES :** ESTIMATION POUR LA RECUPERATION MUSCULAIRE ET LE MAINTIEN DE LA MASSE CORPORELLE, CLE POUR TON ACTIVITE PHYSIQUE.</p>
                    </div>
                </div>
            </div>
        </header>
        <nav class="bg-gray-800 shadow-xl py-3 px-2 sm:px-4 border-y-4 border-blue-700 rounded-b-lg mb-4 mx-2">
            <div class="nav-scroll-container">
                <div class="nav-items-wrapper">
                    <button class="nav-item inline-flex flex-col items-center justify-center p-2 rounded-lg transition-all duration-100 text-gray-200 hover:bg-gray-700 hover:text-yellow-300 border-2 border-gray-700 shadow-[4px_4px_0_0_rgba(0,0,0,0.5)] active:shadow-none active:translate-x-1 active:translate-y-1" data-page="daily_plan"><i data-lucide="calendar" class="text-xl" style="width:24px; height:24px;"></i><span class="text-sm mt-1">PLANNING</span></button>
                    <button class="nav-item inline-flex flex-col items-center justify-center p-2 rounded-lg transition-all duration-100 text-gray-200 hover:bg-gray-700 hover:text-yellow-300 border-2 border-gray-700 shadow-[4px_4px_0_0_rgba(0,0,0,0.5)] active:shadow-none active:translate-x-1 active:translate-y-1" data-page="workout"><i data-lucide="dumbbell" class="text-xl" style="width:24px; height:24px;"></i><span class="text-sm mt-1">SPORT</span></button>
                    <button class="nav-item inline-flex flex-col items-center justify-center p-2 rounded-lg transition-all duration-100 text-gray-200 hover:bg-gray-700 hover:text-yellow-300 border-2 border-gray-700 shadow-[4px_4px_0_0_rgba(0,0,0,0.5)] active:shadow-none active:translate-x-1 active:translate-y-1" data-page="recipes"><i data-lucide="utensils" class="text-xl" style="width:24px; height:24px;"></i><span class="text-sm mt-1">RECETTES</span></button>
                    <button class="nav-item inline-flex flex-col items-center justify-center p-2 rounded-lg transition-all duration-100 text-gray-200 hover:bg-gray-700 hover:text-yellow-300 border-2 border-gray-700 shadow-[4px_4px_0_0_rgba(0,0,0,0.5)] active:shadow-none active:translate-x-1 active:translate-y-1" data-page="chrono"><i data-lucide="timer" class="text-xl" style="width:24px; height:24px;"></i><span class="text-sm mt-1">CHRONO</span></button>
                    <button class="nav-item inline-flex flex-col items-center justify-center p-2 rounded-lg transition-all duration-100 text-gray-200 hover:bg-gray-700 hover:text-yellow-300 border-2 border-gray-700 shadow-[4px_4px_0_0_rgba(0,0,0,0.5)] active:shadow-none active:translate-x-1 active:translate-y-1" data-page="progress"><i data-lucide="line-chart" class="text-xl" style="width:24px; height:24px;"></i><span class="text-sm mt-1">EVOLUTION</span></button>
                    <button class="nav-item inline-flex flex-col items-center justify-center p-2 rounded-lg transition-all duration-100 text-gray-200 hover:bg-gray-700 hover:text-yellow-300 border-2 border-gray-700 shadow-[4px_4px_0_0_rgba(0,0,0,0.5)] active:shadow-none active:translate-x-1 active:translate-y-1" data-page="trophies"><i data-lucide="trophy" class="text-xl" style="width:24px; height:24px;"></i><span class="text-sm mt-1">TROPHEES</span></button>
                    <button class="nav-item inline-flex flex-col items-center justify-center p-2 rounded-lg transition-all duration-100 text-gray-200 hover:bg-gray-700 hover:text-yellow-300 border-2 border-gray-700 shadow-[4px_4px_0_0_rgba(0,0,0,0.5)] active:shadow-none active:translate-x-1 active:translate-y-1" data-page="options"><i data-lucide="settings" class="text-xl" style="width:24px; height:24px;"></i><span class="text-sm mt-1">OPTIONS</span></button>
                </div>
            </div>
        </nav>
        <main id="main-content" class="flex-1 p-4 sm:p-6 main-content-area max-w-full mx-auto"></main>
        <footer class="fixed bottom-0 left-0 right-0 bg-gray-800 shadow-lg p-3 sm:hidden border-t-4 border-blue-700 text-center text-xs text-gray-400">FitQuest - 2023</footer>
    </div>
    <div id="global-modals-container"></div>
    <div id="notification-container-bottom-right" class="notification-container notification-container-bottom-right flex-col-reverse"></div>
    <script>
        // Fonction pour rendre les icÃ´nes Lucide (utilisÃ©e pour les icÃ´nes de navigation)
        function renderLucideIcons() { lucide.createIcons(); }

        // Variables d'Ã©tat globales de l'application
        let currentPage = 'daily_plan', isLoadingApp = true, loadingProgress = 0, messageQueue = [], currentDisplayedMessage = '', currentDisplayedMessageType = '', messageDisplayTimeoutRef = null;
        let weeklyMealPlan = null, userProfile = { height: '', weight: '', imc: null, imcCategory: '', proteinNeeds: 'N/A', currentXP: 0, earnedTrophies: [], hideExerciseHistory: false, apiKey: '', likedMeals: [] };
        let workoutLogs = [], weightHistory = [], intervalSequences = [], shifts = [];
        let workoutProgram = {}, previousLevel = 0, isAudioActive = true, masterVolume = 0.5;
        let trophySoundPlayer, levelUpPlayer, majorLevelUpPlayer, beepPlayer, startSoundPlayer, loadingSoundLoop, synth;
        let chronoIntervals = [], chronoCurrentTime = 0, chronoCurrentIntervalIndex = -1, isChronoRunning = false, isChronoPaused = false, enableChronoPreCountdown = true, chronoPreCountdownDuration = 10, chronoIntervalTimerRef = null;
        let weightChartInstance = null, exerciseChartInstance = null, userId = 'local_user';
        let editingIntervalIndex = -1; // New variable to track the index of the interval being edited
        let regeneratingMeal = null; // Global variable to track meal regeneration status

        // Cache global pour les petits-dÃ©jeuners et collations gÃ©nÃ©rÃ©s par contexte (type de poste)
        let contextualMealCache = new Map(); // Key: "mealType_poste", Value: meal object

        // Liste de tous les trophÃ©es disponibles et leurs conditions
        const allTrophies = [ { id: 't001', name: 'PREMIER PAS', description: 'Atteindre le Niveau 1. Le voyage commence !', levelRequired: 1 }, { id: 't002', name: 'NOVICE EN FORME', description: 'Atteindre le Niveau 2. Vous prenez le rythme.', levelRequired: 2 }, { id: 't003', name: 'INITIE DU FIT', description: 'Atteindre le Niveau 3. Les efforts paient.', levelRequired: 3 }, { id: 't004', name: 'FORME CROISSANTE', description: 'Atteindre le Niveau 4. De mieux en mieux !', levelRequired: 4 }, { id: 't005', name: 'DEBUTANT AVANCE', description: 'Atteindre le Niveau 5. Vous n\'etes plus un debutant.', levelRequired: 5 }, { id: 't006', name: 'CONSTANCE MERITEE', description: 'Atteindre le Niveau 6. La regularite, c\'est la cle.', levelRequired: 6 }, { id: 't007', name: 'ELAN DU PROGRES', description: 'Atteindre le Niveau 7. Vous sentez la progression.', levelRequired: 7 }, { id: 't008', name: 'GAINS ASSURES', description: 'Atteindre le Niveau 8. Les muscles se dessinent.', levelRequired: 8 }, { id: 't009', name: 'AVANCEE RAPIDE', description: 'Atteindre le Niveau 9. Vous brulez les etapes.', levelRequired: 9 }, { id: 't010', name: 'DIXIEME ETAPE', description: 'Atteindre le Niveau 10. Un jalon important !', levelRequired: 10 }, { id: 't011', name: 'MAITRE INTERMEDIAIRE', description: 'Atteindre le Niveau 11. Le fitness devient une habitude.', levelRequired: 11 }, { id: 't012', name: 'FORCE EMERGENTE', description: 'Atteindre le Niveau 12. Vos limites sont repoussees.', levelRequired: 12 }, { id: 't013', name: 'ENDURANCE ACCRUE', description: 'Atteindre le Niveau 13. Le cardio n\'a plus de secret.', levelRequired: 13 }, { id: 't014', name: 'EXCELLENCE EN VUE', description: 'Atteindre le Niveau 14. La performance est a portee.', levelRequired: 14 }, { id: 't015', name: 'DEMI-MAITRE', description: 'Atteindre le Niveau 15. Vous etes sur la bonne voie.', levelRequired: 15 }, { id: 't016', name: 'DISCIPLINE DE FER', description: 'Atteindre le Niveau 16. Votre engagement est fort.', levelRequired: 16 }, { id: 't017', name: 'ENERGIE DECUPLEE', description: 'Atteindre le Niveau 17. Sentez cette vitalite !', levelRequired: 17 }, { id: 't018', name: 'HARMONIE CORPS/ESPRIT', description: 'Atteindre le Niveau 18. L\'equilibre est parfait.', levelRequired: 18 }, { id: 't019', name: 'FORME OPTIMALE', description: 'Atteindre le Niveau 19. Vous rayonnez de sante.', levelRequired: 19 }, { id: 't020', name: 'DEUXIEME DIZAINE', description: 'Atteindre le Niveau 20. Double decennie de fitness !', levelRequired: 20 }, { id: 't021', name: 'EXPERT EN DEVENIR', description: 'Atteindre le Niveau 21. La maitrise approche.', levelRequired: 21 }, { id: 't022', name: 'PUISSANCE REVELEE', description: 'Atteindre le Niveau 22. Une force insoupconnee.', levelRequired: 22 }, { id: 't023', name: 'AGILITE MAXIMALE', description: 'Atteindre le Niveau 23. Votre corps est un temple agile.', levelRequired: 23 }, { id: 't024', name: 'RESISTANCE INEGALEE', description: 'Atteindre le Niveau 24. Rien ne vous arrete.', levelRequired: 24 }, { id: 't025', name: 'QUART DE SIECLE', description: 'Atteindre le Niveau 25. Vous etes une machine !', levelRequired: 25 }, { id: 't026', name: 'PERFECTION EN MARCHE', description: 'Atteindre le Niveau 26. Chaque pas est un succes.', levelRequired: 26 }, { id: 't027', name: 'FORME INCROYABLE', description: 'Atteindre le Niveau 27. Admirez votre progression !', levelRequired: 27 }, { id: 't028', name: 'DETERMINATION ACEREE', description: 'Atteindre le Niveau 28. Votre volonte est sans faille.', levelRequired: 28 }, { id: 't029', name: 'INEPUISABLE', description: 'Atteindre le Niveau 29. L\'energie vous habite.', levelRequired: 29 }, { id: 't030', name: 'LE TREINTIEME', description: 'Atteindre le Niveau 30. Un cap monumental !', levelRequired: 30 }, { id: 't031', name: 'MAITRE ABSOLU', description: 'Atteindre le Niveau 31. Vous etes une reference.', levelRequired: 31 }, { id: 't032', name: 'EXPERT LEGENDAIRE', description: 'Atteindre le Niveau 32. Votre reputation vous precede.', levelRequired: 32 }, { id: 't033', name: 'OLYMPIEN EN HERBE', description: 'Atteindre le Niveau 33. Digne des plus grands athletes.', levelRequired: 33 }, { id: 't034', name: 'CHAMPION INCROYABLE', description: 'Votre esprit est indomptable.Atteindre le Niveau 34. ', levelRequired: 34 }, { id: 't035', name: 'LE PRODIGE', description: 'Vos prouesses sont inegalees.Atteindre le Niveau 35. ', levelRequired: 35 }, { id: 't036', name: 'FORCE DE LA NATURE', description: 'Vous etes imparable.Atteindre le Niveau 36. ', levelRequired: 36 }, { id: 't037', name: 'FORME DIVINE', description: 'Votre corps est une oeuvre d\'art.Atteindre le Niveau 37. ', levelRequired: 37 }, { id: 't038', name: 'CONNAISSANCE SUPREME', description: 'Votre savoir est immense.Atteindre le Niveau 38. ', levelRequired: 38 }, { id: 't039', name: 'REALISATION PARFAITE', description: 'Tout est sous controle.Atteindre le Niveau 39. ', levelRequired: 39 }, { id: 't040', name: 'QUARANTIEME HORIZON', description: 'Le ciel est votre limite !Atteindre le Niveau 40. ', levelRequired: 40 }, { id: 't041', name: 'LEGENDE VIVANTE', description: 'On parlera de vous.Atteindre le Niveau 41. ', levelRequired: 41 }, { id: 't042', name: 'INSPIRATION ULTIME', description: 'Vous inspirez les foules.Atteindre le Niveau 42. ', levelRequired: 42 }, { id: 't043', name: 'DEFI RELEVE', description: 'Chaque obstacle est un tremplin.Atteindre le Niveau 43. ', levelRequired: 43 }, { id: 't044', name: 'SUMMUM DE LA FORME', description: 'Vous etes au sommet.Atteindre le Niveau 44. ', levelRequired: 44 }, { id: 't045', name: 'LE MAITRE CULMINANT', description: 'La perfection incarnee.Atteindre le Niveau 45. ', levelRequired: 45 }, { id: 't046', name: 'IMPARABLE', description: 'Vous etes invincible !Atteindre le Niveau 46. ', levelRequired: 46 }, { id: 't047', name: 'VOLONTE DE DIAMANT', description: 'Votre determination est inebranlable.Atteindre le Niveau 47. ', levelRequired: 47 }, { id: 't048', name: 'ECLAT ETERNEL', description: 'Votre aura brille.Atteindre le Niveau 48. ', levelRequired: 48 }, { id: 't049', name: 'CONNAISSANCE ABSOLUE', description: 'Le savoir vous guide.Atteindre le Niveau 49. ', levelRequired: 49 }, { id: 't050', name: 'LE CINQUANTIEME', description: 'Une performance extraordinaire !Atteindre le Niveau 50. ', levelRequired: 50 }, { id: 't051', name: 'GRAND MAITRE', description: 'Atteindre le Niveau 51. Vous etes au-delÃ  de l\'excellence.', levelRequired: 51 }, { id: 't052', name: 'ARCHITECTE DU CORPS', description: 'Atteindre le Niveau 52. Vous sculptez votre destin.', levelRequired: 52 }, { id: 't053', name: 'ARTISAN DE LA SANTE', description: 'Atteindre le Niveau 53. Votre bien-etre est une oeuvre.', levelRequired: 53 }, { id: 't054', name: 'GUERRIER DE LA FORME', description: 'Atteindre le Niveau 54. Combattez pour votre meilleure version.', levelRequired: 54 }, { id: 't055', name: 'CONQUERANT DU PHYSIQUE', description: 'Atteindre le Niveau 55. Chaque jour est une victoire.', levelRequired: 55 }, { id: 't056', name: 'PIONNIER DU BIEN-ETRE', description: 'Atteindre le Niveau 56. Vous ouvrez la voie.', levelRequired: 56 }, { id: 't057', name: 'PILIER DE LA VITALITE', description: 'Atteindre le Niveau 57. Votre energie est inepuisable.', levelRequired: 57 }, { id: 't058', name: 'SYNTHESE PARFAITE', description: 'Atteindre le Niveau 58. L\'harmonie est atteinte.', levelRequired: 58 }, { id: 't059', name: 'PERFORMANCE ULTIME', description: 'Atteindre le Niveau 59. Vous defiez les limites.', levelRequired: 59 }, { id: 't060', name: 'LE SOIXANTIEME', description: 'Incroyable perseverance !Atteindre le Niveau 60. ', levelRequired: 60 }, { id: 't061', name: 'LEGENDAIRE INDOMPTABLE', description: 'Votre nom resonne.Atteindre le Niveau 61. ', levelRequired: 61 }, { id: 't062', name: 'MYTHIQUE', description: 'Votre parcours est une epopee.Atteindre le Niveau 62. ', levelRequired: 62 }, { id: 't063', name: 'CHRONIQUE VIVANTE', description: 'Chaque jour ecrit l\'histoire.Atteindre le Niveau 63. ', levelRequired: 63 }, { id: 't064', name: 'PATRON DES RECORDS', description: 'Les records s\'inclinent.Atteindre le Niveau 64. ', levelRequired: 64 }, { id: 't065', name: 'LE NEMESIS DE LA FAIBLESSE', description: 'Plus rien ne vous arrete.Atteindre le Niveau 65. ', levelRequired: 65 }, { id: 't066', name: 'VOLONTE D\'ACIER', description: 'Votre determination est inebranlable.Atteindre le Niveau 66. ', levelRequired: 66 }, { id: 't067', name: 'METEORE DE LA FORME', description: 'Votre progression est fulgurante.Atteindre le Niveau 67. ', levelRequired: 67 }, { id: 't068', name: 'AU-DELA DES LIMITES', description: 'Vous transcendez tout.Atteindre le Niveau 68. ', levelRequired: 68 }, { id: 't069', name: 'VISIONNAIRE DU FITNESS', description: 'Votre vision est claire.Atteindre le Niveau 69. ', levelRequired: 69 }, { id: 't070', name: 'LE SOIXANTE-DIXIEME', description: 'Une ascension sans fin !Atteindre le Niveau 70. ', levelRequired: 70 }, { id: 't071', name: 'IMMORTEL DE LA FORME', description: 'Atteindre le Niveau 71. Votre corps defie le temps.' }, { id: 't072', name: 'ZENITH DE LA VITALITE', description: 'Atteindre le Niveau 72. Sentez la pleine puissance.' }, { id: 't073', name: 'CONSTELLATION DU CORPS', description: 'Atteindre le Niveau 73. Chaque fibre brille.' }, { id: 't074', name: 'HEROS DU QUOTIDIEN', description: 'Atteindre le Niveau 74. Votre discipline est exemplaire.' }, { id: 't075', name: 'LE SEPTANTE-CINQUIEME', description: 'Atteindre le Niveau 75. Une prouesse historique !' }, { id: 't076', name: 'ETERNEL ATHLETE', description: 'Atteindre le Niveau 76. Le sport est votre essence.' }, { id: 't077', name: 'SAGESSE CORPORELLE', description: 'Atteindre le Niveau 77. Votre experience est precieuse.' }, { id: 't078', name: 'GUARDIEN DE LA SANTE', description: 'Atteindre le Niveau 78. Vous veillez sur votre bien-etre.' }, { id: 't079', name: 'EMERAUDE DU FITNESS', description: 'Atteindre le Niveau 79. Precieux et rare.' }, { id: 't080', name: 'LE QUATRE-VINGTIEME', description: 'Atteindre le Niveau 80. Un exploit extraordinaire !' }, { id: 't081', name: 'ARCHANGE DE L\'ACTIVITE', description: 'Atteindre le Niveau 81. Votre presence est divine.' }, { id: 't082', name: 'COURONNE DE LAURELS', description: 'Atteindre le Niveau 82. Le triomphe vous attend.' }, { id: 't083', name: 'ESSENCE DU MOUVEMENT', description: 'Atteindre le Niveau 83. Le mouvement est votre signature.' }, { id: 't084', name: 'INFINI DE L\'ENERGIE', description: 'Atteindre le Niveau 84. Une source intarissable.' }, { id: 't085', name: 'LE QUATRE-VINGT-CINQUIEME', description: 'Atteindre le Niveau 85. Un jalon impressionnant !' }, { id: 't086', name: 'CONSTELLATION D\'OR', description: 'Atteindre le Niveau 86. Vous etes une etoile.' }, { id: 't087', name: 'SYMBOLE DE FORCE', description: 'Atteindre le Niveau 87. Une incarnation de la puissance.' }, { id: 't088', name: 'APOTHEOSE PHYSIQUE', description: 'Atteindre le Niveau 88. Le sommet de la forme.' }, { id: 't089', name: 'LUMIERE DU BIEN-ETRE', description: 'Atteindre le Niveau 89. Vous eclairez le chemin.' }, { id: 't090', name: 'LE QUATRE-VINGT-DIXIEME', description: 'Atteindre le Niveau 90. Presque la perfection !' }, { id: 't091', name: 'DIVINITE DE LA FORME', description: 'Atteindre le Niveau 91. Vous touchez au divin.' }, { id: 't092', name: 'ETINCELLE ETERNELLE', description: 'Atteindre le Niveau 92. Votre flamme ne s\'eteint jamais.' }, { id: 't093', name: 'LE MAITRE DES MAITRES', description: 'Atteindre le Niveau 93. Le plus grand de tous.' }, { id: 't094', name: 'AU-DELA DE L\'EXCELLENCE', description: 'Atteindre le Niveau 94. Depassez toutes les attentes.' }, { id: 't095', name: 'LE QUATRE-VINGT-QUINZIEME', description: 'Atteindre le Niveau 95. La grandeur est a vous !' }, { id: 't096', name: 'SOURCE INFINIE', description: 'Atteindre le Niveau 96. Une energie inepuisable.' }, { id: 't097', name: 'ESSENCE DU CHAMPION', description: 'Atteindre le Niveau 97. Vous etes ne pour gagner.' }, { id: 't098', name: 'L\'APEX ULTIME', description: 'Atteindre le Niveau 98. Le sommet absolu.' }, { id: 't099', name: 'PERFECTION INCARNEE', description: 'Atteindre le Niveau 99. La perfection est atteinte.' }, { id: 't100', name: 'LE CENTIEME !', description: 'Atteindre le Niveau 100. Vous avez conquis FitQuest !', levelRequired: 100 } ];
        
        // Supprime les anciennes listes d'ingrÃ©dients statiques et les types de recettes prÃ©dÃ©finis
        // L'IA gÃ©nÃ©rera dÃ©sormais les recettes de maniÃ¨re dynamique
        const recipeTemplates = {};

        // Routines de sommeil adaptÃ©es aux types de poste
        const sleepRoutines = {
            '6h-18h': { name: "ROUTINE JOUR (6H-18H)", details: [ "COUCHER : 22H00 - 23H00.", "REVEIL : 05H00 - 06H00.", "ASSURER 7-8H DE SOMMEIL DE QUALITE. EVITER LES ECRANS AVANT LE COUCHER." ] },
            '7h-18h': { name: "ROUTINE JOUR (7H-18H)", details: [ "COUCHER : 22H00 - 22H30.", "REVEIL : 06H00 - 06H15.", "OBJECTIF 7-8H DE SOMMEIL. PRIVILEGIER UN RITUEL DE DETENTE PRE-SOMMEIL." ] },
            '18h-6h': { name: "ROUTINE NUIT (18H-6H)", details: [ "SOMMEIL PRINCIPAL APRES LE POSTE : 07H00 - 14H00/15H00 (7-8H).", "SIESTE PRE-POSTE (OPTIONNEL) : 17H00 - 17H45 (45 MIN) POUR BOOSTER LA VIGILANCE.", "UTILISER DES RIDEAUX OCCULTANTS ET UN MASQUE DE SOMMEIL POUR OPTIMISER LE REPOS EN JOURNEE." ] },
            'repos': { name: "JOUR DE REPOS (RECUPERATION)", details: [ "MAINTENIR UN HORAIRE DE SOMMEIL PROCHE DES JOURS DE TRAVAIL POUR NE PAS PERTURBER LE RYTHME CIRCADIEN.", "COUCHER : VERS 23H00.", "REVEIL : VERS 08H00-09H00.", "POSSIBILITE DE SIESTE COURTE (20-30 MIN) EN DEBUT D'APRES-MIDI SI NECESSAIRE." ] },
            'repos_sport': { name: "JOUR DE REPOS (SPORT)", details: [ "COUCHER : VERS 22H30-23H30.", "REVEIL : VERS 07H00-08H00.", "SOMMEIL OPTIMAL POUR LA RECUPERATION MUSCULAIRE. EVITER LES EXCITANTS APRES L'ENTRAINEMENT." ] }
        };

        // Structure par defaut du programme d'entrainement
        const defaultWorkoutProgramStructure = {
            phase1: {
                name: "PHASE 1 : FONDATIONS DU FITNESS",
                sessions: {
                    main: {
                        name: "SEANCE PRINCIPALE : RENFORCEMENT MUSCULAIRE GLOBAL",
                        exercises: [
                            { name: "SQUAT AU POIDS DU CORPS", desc: "3 SERIES DE 10-15 REPETITIONS. CONCENTREZ-VOUS SUR LA FORME.", type: "legs" },
                            { name: "POMPES (SUR LES GENOUX SI NECESSAIRE)", desc: "3 SERIES DE 8-12 REPETITIONS. GARDER LE CORPS DROIT.", type: "chest" },
                            { name: "FENTES ALTERNEES", desc: "3 SERIES DE 10-12 REPETITIONS PAR JAMBE.", type: "legs" },
                            { name: "ROWING INVERSE (SOUS UNE TABLE OU BARRE BASSE)", desc: "3 SERIES DE 8-12 REPETITIONS. TIREZ LA POITRINE VERS LA BARRE.", type: "back" },
                            { name: "PLANCHE", desc: "3 SERIES DE 30-60 SECONDES. MAINTENEZ UNE LIGNE DROITE.", type: "core" }
                        ]
                    },
                    cardio: {
                        name: "SEANCE TYPE : CARDIO (ENDURANCE, FRACTIONNE OU MIXTE)",
                        options: [
                            {
                                name: "TAPIS DE COURSE (FRACTIONNE)",
                                desc: "RONDE 1 (15 MINUTES) : REPETE 5 FOIS : 2 MINUTES : MARCHE RAPIDE A 6.0 KM/H, PENTE 2.0. 1 MINUTE : COURSE LEGERE A 8.0 KM/H, PENTE 1.0. RECUPERATION ACTIVE (5 MINUTES) : MARCHE LENTE A 4.0 KM/H, PENTE 0.0. BOIS UN PEU D'EAU. RONDE 2 (15 MINUTES) : REPETE 5 FOIS : 2 MINUTES : MARCHE RAPIDE A 6.5 KM/H, PENTE 2.0. 1 MINUTE : COURSE LEGERE A 8.5 KM/H, PENTE 1.0 (OU MARCHE RAPIDE INTENSE SI LA COURSE EST TROP DIFFICILE).",
                                type: "cardio"
                            },
                            {
                                name: "VELO STATIONNAIRE OU VELO ELLIPTIQUE (SYNCHRO) (FRACTIONNE)",
                                desc: "RONDE 1 (20 MINUTES) : REPETE 5 FOIS : 3 MINUTES : RYTHME MODERE, NIVEAU 5-7 (SENS UNE LEGERE RESISTANCE, TU PEUX PARLER MAIS C'EST UN PEU DIFFICILE). 1 MINUTE : RYTHME PLUS INTENSE, NIVEAU 8-10 (TU ES ESSOUFFLE, TU NE PEUX PAS PARLER FACILEMENT). RECUPERATION ACTIVE (5 MINUTES) : RYTHME TRES FACILE, NIVEAU 3-4. BOIS UN PEU D'EAU. RONDE 2 (20 MINUTES) : REPETE 5 FOIS : 3 MINUTES : RYTHME MODERE, NIVEAU 6-8. 1 MINUTE : RYTHME PLUS INTENSE, NIVEAU 9-11 (OU LE MAXIMUM QUE TU PEUX SOUTENIR).",
                                type: "cardio"
                            },
                            {
                                name: "CARDIO & FONCTIONNEL MIXTE (MOINS INTENSE QU'UN HIIT)",
                                desc: "PARTIE 1 (20 MINUTES) : 10 MINUTES : TAPIS DE COURSE (MARCHE RAPIDE A 6.0 KM/H, PENTE 2.0) OU VELO/ELLIPTIQUE (NIVEAU 6). 10 MINUTES : ALTERNER 2 MINUTES DE MOUNTAIN CLIMBERS (RYTHME MODERE) ET 2 MINUTES DE JUMPING JACKS (RYTHME MODERE), REPETE 2 FOIS. RECUPERATION ACTIVE (5 MINUTES) : MARCHE LENTE A 4.0 KM/H, PENTE 0.0. BOIS UN PEU D'EAU. PARTIE 2 (15 MINUTES) : 10 MINUTES : TAPIS DE COURSE (MARCHE RAPIDE A 6.5 KM/H, PENTE 2.0) OU VELO (NIVEAU 7). 5 MINUTES : MONTEES DE GENOUX RAPIDES (RYTHME MODERE) OU KETTLEBELL SWING (RYTHME MODERE).",
                                type: "cardio"
                            }
                        ]
                    },
                    hiit: {
                        name: "SEANCE TYPE : HIIT (HIGH-INTENSITY INTERVAL TRAINING)",
                        desc: "DUREE ESTIMEE : 30-40 MINUTES. FREQUENCE : 1 A 2 FOIS PAR SEMAINE MAXIMUM POUR COMMENCER. ATTENTION : LE HIIT EST INTENSE. ECOUTE IMPERATIVEMENT TON CORPS. LES JOURS OU LA FATIGUE LIEE A TA SEP EST PLUS PRESENTE, REMPLACE CETTE SEANCE PAR DU CARDIO LEGER OU DU REPOS ACTIF. CORPS DE SEANCE (20-25 MINUTES) : STRUCTURE : REALISE 3 A 4 TOURS DU CIRCUIT SUIVANT. CHAQUE EXERCICE : 40 SECONDES D'EFFORT MAXIMAL, SUIVIES DE 20 SECONDES DE REPOS TOTAL. ENTRE CHAQUE TOUR COMPLET DU CIRCUIT : 1 MINUTE 30 DE REPOS ACTIF (MARCHE LEGERE, HYDRATATION).",
                        exercises: [
                            { name: "BURPEES (MODIFIES)", desc: "DESCENDS EN SQUAT, POSE LES MAINS AU SOL, JETTE LES JAMBES EN ARRIERE POUR TE METTRE EN PLANCHE (SANS POMPE SI TU DEBUTES), RAMENE LES PIEDS ENTRE LES MAINS, RELEVE-TOI.", type: "hiit" },
                            { name: "MOUNTAIN CLIMBERS", desc: "EN POSITION DE PLANCHE, RAMENE ALTERNATIVEMENT LES GENOUX VERS LA POITRINE, COMME SI TU 'COURAIS' SUR PLACE.", type: "hiit" },
                            { name: "JUMPING JACKS", desc: "SAUTE EN ECARTANT LES JAMBES ET EN LEVANT LES BRAS AU-DESSUS DE LA TETE, PUIS REVIENS EN POSITION INITIALE. (SI LES SAUTS SONT TROP INTENSES, FAIS UN PAS SUR LE COTE AVEC UN BRAS QUI MONTE, PUIS L'AUTRE).", type: "hiit" },
                            { name: "KETTLEBELL SWING", desc: "MOUVEMENT DE BALANCIER EN POUSSANT LES HANCHES VERS L'AVANT (PAS AVEC LES BRAS !). POIDS SUGGERE : 6-10 KG.", type: "hiit" },
                            { name: "FENTES SAUTEES", desc: "SAUTE POUR CHANGER DE JAMBE EN L'AIR ET ATTERRIS EN FENTE AVEC L'AUTRE JAMBE DEVANT. MODIFICATION : SI LES SAUTS SONT TROP INTENSES, FAIS DES FENTES ALTERNEES CLASSIQUES EN TE RELEVANT RAPIDEMENT ENTRE CHAQUE.", type: "hiit" },
                            { name: "MONTEES DE GENOUX RAPIDES", desc: "COURS SUR PLACE EN LEVANT LES GENOUX LE PLUS HAUT POSSIBLE, EN UTILISANT TES BRAS.", type: "hiit" }
                        ]
                    }
                }
            },
            phase2: {
                name: "PHASE 2 : PROGRAMME ALTERNATIF (POUR LES 4 A 6 SEMAINES SUIVANTES)",
                sessions: {
                    main: {
                        name: "SEANCE TYPE : RENFORCEMENT MUSCULAIRE (FULL BODY) - ALTERNATIVE",
                        exercises: [
                            { name: "SOULEVE DE TERRE ROUMAIN (RDL HALTERES)", desc: "4 SERIES DE 10-15 REPETITIONS. CONSIGNE : TIENS UN HALTERE DANS CHAQUE MAIN, PIEDS LARGEUR DES HANCHES. DESCENDS LES HALTERES LE LONG DE TES JAMBES EN POUSSANT LES HANCHES VERS L'ARRIERE ET EN GARDANT LE DOS DROIT. POIDS SUGGERE (HALTERES) : COMMENCE AVEC 6-10 KG PAR MAIN.", type: "legs" },
                            { name: "TRACTIONS ASSISTEES (MACHINE)", desc: "3-4 SERIES DE MAX DE REPETITIONS (AVEC UNE FORME CONTROLEE). CONSIGNE : TIRE TON CORPS VERS LE HAUT JUSQU'A CE QUE TON MENTON DEPASSE LA BARRE, EN CONTRACTANT LE DOS. ASSISTANCE : UTILISE LA MACHINE AVEC UN POIDS D'ASSISTANCE ELEVE, OU UN ELASTIQUE EPAIS. REDUIS L'ASSISTANCE AU FIL DES SEMAINES.", type: "back" },
                            { name: "PRESSE A CUISSES (LEG PRESS)", desc: "3-4 SERIES DE 10-15 REPETITIONS. CONSIGNE : POUSSE LA PLATEFORME EN ETENDANT LES JAMBES, SANS BLOQUER LES GENOUX. POIDS SUGGERE MACHINE : COMMENCE AVEC 40-60 KG (AJUSTE PAR PALIERS DE 2.5KG OU 5KG).", type: "legs" },
                            { name: "DEVELOPPE EPAULES (SHOULDER PRESS HALTERES OU MACHINE)", desc: "3-4 SERIES DE 10-15 REPETITIONS. CONSIGNE HALTERES : ASSIS, UN HALTERE DANS CHAQUE MAIN AU NIVEAU DES EPAULES. POUSSE LES HALTERES VERS LE HAUT AU-DESSUS DE TA TETE. POIDS SUGGERE HALTERES : COMMENCE AVEC 4-8 KG PAR MAIN. POIDS SUGGERE MACHINE : COMMENCE AVEC 10-20 KG (AJUSTE PAR PALIERS DE 2.5KG OU 5KG).", type: "shoulders" },
                            { name: "ROWING PENCHE (HALTERES)", desc: "3 SERIES DE 10-15 REPETITIONS. CONSIGNE : TIENS UN HALTERE DANS CHAQUE MAIN, PENCHE LE BUSTE EN AVANT (DOS DROIT, GENOUX LEGEREMENT FLECHIS). TIRE LES HALTERES VERS TA POITRINE EN CONTRACTANT LES OMOPLATES. POIDS SUGGERE : COMMENCE AVEC 6-10 KG PAR MAIN.", type: "back" },
                            { name: "EXTENSIONS TRICEPS (POULIE HAUTE OU HALTERE)", desc: "3 SERIES DE 12-15 REPETITIONS. CONSIGNE POULIE : COUDES COLLES AU CORPS. POUSSE LA BARRE VERS LE BAS EN NE BOUGEANT QUE L'AVANT-BRAS. POIDS SUGGERE POULIE : COMMENCE AVEC 10-15 KG (AJUSTE PAR PALIERS DE 2.5KG OU 5KG). HALTERE (DERRIERE LA TETE) : TIENS UN HALTERE AVEC LES DEUX MAINS DERRIERE TA TETE, POUSSE VERS LE HAUT. POIDS SUGGERE HALTERE : 4-8 KG.", type: "arms" },
                            { name: "CRUNCHS (ABDOMINALS)", desc: "3 SERIES DE 15-20 REPETITIONS. CONSIGNE : LEVE LES EPAULES DU SOL EN CONTRACTANT LES ABDOMINAUX, SANS TIRER SUR LA NUQUE. RECUPERATION : 30 SECONDES ENTRE LES SERIES.", type: "core" }
                        ]
                    },
                    cardio: {
                        name: "SEANCE TYPE : CARDIO (ENDURANCE, FRACTIONNE OU MIXTE) - ALTERNATIVE",
                        options: [
                            {
                                name: "TAPIS DE COURSE (ENDURANCE A PENTE VARIABLE)",
                                desc: "5 MINUTES : ECHAUFFEMENT LEGER (MARCHE RAPIDE A 5.0 KM/H, PENTE 1.0). 5 MINUTES : MARCHE RAPIDE A 5.5 KM/H, PENTE 2.0. 3 MINUTES : MARCHE RAPIDE A 6.0 KM/H, PENTE 3.0. 2 MINUTES : COURSE LEGERE A 7.5 KM/H, PENTE 1.0. REPETE CE CYCLE 4-5 FOIS POUR UN TOTAL DE 40-50 MINUTES. VARIANTE : POUR AUGMENTER L'INTENSITE, AUGMENTE LEGEREMENT LA VITESSE OU LA PENTE A CHAQUE CYCLE SI TU TE SENS BIEN.",
                                type: "cardio"
                            },
                            {
                                name: "RAMEUR (ROWING MACHINE) - INTERVAL TRAINING",
                                desc: "5 MINUTES : ECHAUFFEMENT LEGER (RYTHME LENT, RESISTANCE FAIBLE). RONDE 1 (15 MINUTES) : REPETE 5 FOIS : 2 MINUTES : RYTHME MODERE, RESISTANCE 3-5 (EFFORT SOUTENU MAIS CONFORTABLE). 1 MINUTE : RYTHME INTENSE, RESISTANCE 6-7 (TU ES ESSOUFFLE, TU NE PEUX PAS PARLER FACILEMENT). RECUPERATION ACTIVE (5 MINUTES) : RYTHME TRES FACILE, RESISTANCE 2. BOIS UN PEU D'EAU. RONDE 2 (15 MINUTES) : REPETE 5 FOIS : 2 MINUTES : RYTHME MODERE, RESISTANCE 4-6. 1 MINUTE : RYTHME PLUS INTENSE, RESISTANCE 7-8 (OU LE MAXIMUM QUE TU PEUX SOUTENIR). CONSIGNE : UTILISE 60% DE LA FORCE DES JAMBES, 20% DU TRONC, 20% DES BRAS. POUSSE AVEC LES JAMBES EN PREMIER !",
                                type: "cardio"
                            },
                            {
                                name: "CARDIO & FONCTIONNEL MIXTE (ALTERNATIF)",
                                desc: "PARTIE 1 (20 MINUTES) : 10 MINUTES : RAMEUR (RYTHME MODERE, RESISTANCE 4-5) OU VELO ELLIPTIQUE (NIVEAU 6-7). 10 MINUTES : ALTERNER 2 MINUTES DE SQUAT (POIDS DU CORPS) (RYTHME MODERE) ET 2 MINUTES DE FENTES (LUNGES) ALTERNEES (RYTHME MODERE), REPETE 2 FOIS. RECUPERATION ACTIVE (5 MINUTES) : RYTHME TRES FACILE, RESISTANCE 2. PARTIE 2 (15 MINUTES) : 10 MINUTES : TAPIS DE COURSE (COURSE LEGERE A 7.0 KM/H, PENTE 1.0) OU VELO (NIVEAU 8). 5 MINUTES : BURPEES (MODIFIES) (RYTHME MODERE) OU CORDE A SAUTER (RYTHME MODERE).",
                                type: "cardio"
                            }
                        ]
                    },
                    hiit: {
                        name: "SEANCE TYPE : HIIT (HIGH-INTENSITY INTERVAL TRAINING) - ALTERNATIVE",
                        desc: "DUREE ESTIMEE : 30-40 MINUTES. FREQUENCE : 1 A 2 FOIS PAR SEMAINE MAXIMUM. ATTENTION : LE HIIT EST INTENSE. ECOUTE IMPERATIVEMENT TON CORPS. LES JOURS OU LA FATIGUE LIEE A TA SEP EST PLUS PRESENTE, REMPLACE CETTE SEANCE PAR DU CARDIO LEGER OU DU REPOS ACTIF. CORPS DE SEANCE (20-25 MINUTES) : STRUCTURE : REALISE 3 A 4 TOURS DU CIRCUIT SUIVANT. CHAQUE EXERCICE : 45 SECONDES D'EFFORT INTENSE, SUIVIES DE 15 SECONDES DE REPOS TOTAL. ENTRE CHAQUE TOUR COMPLET DU CIRCUIT : 1 MINUTE 15 DE REPOS ACTIF (MARCHE LEGERE, HYDRATATION).",
                        exercises: [
                            { name: "BURPEES (AVEC POMPE)", desc: "FAIS UN BURPEE COMPLET, EN INCLUANT UNE POMPE (SUR LES GENOUX SI BESOIN) LORSQUE TU ES EN POSITION DE PLANCHE.", type: "hiit" },
                            { name: "BOX JUMPS OU STEP-UPS", desc: "SAUTE SUR UNE BOITE BASSE (OU UN STEP) ET DESCENDS. SI LES SAUTS SONT UN PROBLEME : FAIS DES STEP-UPS RAPIDES (MONTE ET DESCENDS DU BANC UNE JAMBE APRES L'AUTRE).", type: "hiit" },
                            { name: "CORDE A SAUTER", desc: "SAUTE A LA CORDE. VARIE LES SAUTS (PIEDS JOINTS, ALTERNES). SI PAS DE CORDE OU TROP DIFFICILE : FAIS DES SAUTS SUR PLACE LEGERS OU DES PAS CHASSES RAPIDES.", type: "hiit" },
                            { name: "KETTLEBELL GOBLET SQUAT (EXPLOSIF)", desc: "TIENS UN KETTLEBELL DEVANT TA POITRINE. FAIS UN SQUAT COMPLET ET REMONTE DE MANIERE EXPLOSIVE. POIDS SUGGERE : 8-12 KG.", type: "hiit" },
                            { name: "MOUNTAIN CLIMBERS CROISES", desc: "EN POSITION DE PLANCHE, RAMENE LE GENOU DROIT VERS LE COUDE GAUCHE, PUIS LE GENOU GAUCHE VERS LE COUDE DROIT, EN ALTERNANCE RAPIDE.", type: "hiit" },
                            { name: "SAUTS LATERAUX (LATERAL JUMPS)", desc: "SAUTE DE DROITE A GAUCHE RAPIDEMENT AU-DESSUS D'UNE LIGNE IMAGINAIRE OU D'UN PETIT OBJET.", type: "hiit" }
                        ]
                    }
                }
            },
            recovery: { // New section for recovery
                name: "JOURNEE DE RECUPERATION ACTIVE / FLEXIBILITE (OPTIONNEL)",
                desc: "EN PLUS DE TES JOURS DE REPOS COMPLETS, TU PEUX DEDIER UNE JOURNEE PAR SEMAINE A UNE ACTIVITE DOUCE POUR LA RECUPERATION ET LA SOUPLESSE.",
                activities: [
                    { name: "MARCHE PROLONGEE", desc: "DANS UN PARC, EN NATURE, A UN RYTHME AGREABLE (45-60 MIN)." },
                    { name: "SEANCE DE YOGA DOUX OU DE PILATES", desc: "PRIVILEGIE LES VIDEOS EN LIGNE POUR DEBUTANTS AXEES SUR LA FLEXIBILITE ET LE RENFORCEMENT DU TRONC." },
                    { name: "ETIREMENTS PROFONDS", desc: "UNE SEANCE DEDIEE DE 20-30 MINUTES POUR ETIRER TOUS LES GRANDS GROUPES MUSCULAIRES, EN MAINTENANT LES POSITIONS PLUS LONGTEMPS (30-60 SEC)." },
                    { name: "NATATION LEGERE", desc: "QUELQUES LONGUEURS A RYTHME TRANQUILLE POUR DETENDRE LES MUSCLES." }
                ]
            }
        };

        // Fonctions utilitaires pour la persistance des donnÃ©es dans le localStorage
        function saveToLocalStorage(key, data) { try { localStorage.setItem(key, JSON.stringify(data)); console.log(`[LocalStorage] Donnees sauvegardees pour '${key}'.`); } catch (e) { console.error(`[LocalStorage] Erreur lors de la sauvegarde pour '${key}':`, e); showMessage(`ERREUR: Impossible de sauvegarder ${key}.`, 'error'); } }
        function loadFromLocalStorage(key, defaultValue) { try { const data = localStorage.getItem(key); return data ? JSON.parse(data) : defaultValue; } catch (e) { console.error(`[LocalStorage] Erreur lors du chargement pour '${key}':`, e); showMessage(`ATTENTION: Donnees corrompues pour ${key}. Chargement par defaut.`, 'warning'); return defaultValue; } }
        function removeFromLocalStorage(key) { try { localStorage.removeItem(key); console.log(`[LocalStorage] Donnees supprimees pour '${key}'.`); } catch (e) { console.error(`[LocalStorage] Erreur lors de la suppression pour '${key}':`, e); showMessage(`ERREUR: Impossible de supprimer ${key}.`, 'error'); } }

        // Initialisation de l'Ã©tat global de l'application au dÃ©marrage
        function initializeGlobalState() {
            console.log("[INITIALISATION] Chargement de l'etat global depuis le localStorage...");
            userProfile = loadFromLocalStorage('userProfile', { height: '', weight: '', imc: null, imcCategory: '', proteinNeeds: 'N/A', currentXP: 0, earnedTrophies: [], hideExerciseHistory: false, apiKey: '', likedMeals: [] });
            // Ensure likedMeals is an array of objects
            if (!Array.isArray(userProfile.likedMeals)) {
                userProfile.likedMeals = [];
                console.warn("[INITIALISATION] likedMeals n'etait pas un tableau, reinitialisation.");
            } else {
                // Ensure all liked meals have necessary properties for context matching
                userProfile.likedMeals = userProfile.likedMeals.map(meal => {
                    return {
                        id: meal.id || generateUniqueId(),
                        mealType: meal.mealType || null,
                        dayContext: meal.dayContext || { poste: 'unknown', sport: 'unknown' },
                        ...meal
                    };
                });
            }

            weeklyMealPlan = loadFromLocalStorage('weeklyMealPlan', { semaine: [] });
            workoutLogs = loadFromLocalStorage('workoutLogs', []);
            weightHistory = loadFromLocalStorage('weightHistory', []);
            intervalSequences = loadFromLocalStorage('intervalSequences', []);
            shifts = loadFromLocalStorage('shifts', []);
            workoutProgram = loadFromLocalStorage('savedWorkoutProgram', JSON.parse(JSON.stringify(defaultWorkoutProgramStructure)));
            previousLevel = calculateLevelAndXP(userProfile.currentXP).level;
            const savedChronoState = loadFromLocalStorage('chronoState', {});
            chronoIntervals = savedChronoState.intervals || [];
            chronoCurrentTime = savedChronoState.currentTime || 0;
            chronoCurrentIntervalIndex = savedChronoState.currentIntervalIndex !== undefined ? savedChronoState.currentIntervalIndex : -1;
            isChronoRunning = savedChronoState.isRunning || false;
            isChronoPaused = savedChronoState.isPaused || false;
            enableChronoPreCountdown = savedChronoState.enablePreCountdown !== undefined ? savedChronoState.enablePreCountdown : true;
            chronoPreCountdownDuration = savedChronoState.preCountdownDuration || 10;
            if (!Array.isArray(userProfile.earnedTrophies)) { userProfile.earnedTrophies = []; console.warn("[INITIALISATION] earnedTrophies n'etait pas un tableau, reinitialisation."); }

            // Initialiser le cache global pour une nouvelle gÃ©nÃ©ration de plan
            contextualMealCache = new Map();
            if (weeklyMealPlan && weeklyMealPlan.semaine) {
                weeklyMealPlan.semaine.forEach(dayData => {
                    const mealTypesToCache = ['petit_dejeuner', 'collation_matin', 'collation_apresmidi', 'collation_unique'];
                    mealTypesToCache.forEach(mealType => {
                        if (dayData[mealType]) {
                            const contextKey = getMealContextKey(mealType, dayData.dayContext);
                            if (!contextualMealCache.has(contextKey)) {
                                contextualMealCache.set(contextKey, dayData[mealType]);
                            }
                        }
                    });
                });
            }
            console.log("[INITIALISATION] Etat global charge.");
        }

        // Met Ã  jour l'Ã©tat du chronomÃ¨tre dans le localStorage
        function updateLocalStorageChronoState() { saveToLocalStorage('chronoState', { intervals: chronoIntervals, currentTime: chronoCurrentTime, currentIntervalIndex: chronoCurrentIntervalIndex, isRunning: isChronoRunning, isPaused: isChronoPaused, enablePreCountdown: enableChronoPreCountdown, preCountdownDuration: chronoPreCountdownDuration }); }

        // Affiche un message de notification Ã  l'utilisateur
        function showMessage(msg, type = 'info') {
            const container = document.getElementById('notification-container-bottom-right');
            const notification = document.createElement('div');
            notification.className = `notification general ${type}`;
            const iconMap = { 'success': 'ð', 'error': 'â', 'warning': 'â ï¸', 'info': 'â¹ï¸', 'chrono': 'â±ï¸', 'tip': 'ð¡' };
            notification.innerHTML = `<span class="text-2xl">${iconMap[type] || 'â¹ï¸'}</span><p class="font-bold text-sm sm:text-base">${String(msg).toUpperCase()}</p>`;
            container.appendChild(notification);
            void notification.offsetWidth; // Force reflow for animation
            notification.classList.add('show');
            const duration = type === 'trophy' ? 12000 : (type === 'tip' ? 20000 : 5000); // Duree d'affichage
            setTimeout(() => { notification.classList.remove('show'); notification.addEventListener('transitionend', () => notification.remove(), { once: true }); }, duration);
        }

        // Affiche une notification de trophÃ©e debloque
        function showTrophyNotification(trophyName, description) {
            const container = document.getElementById('notification-container-bottom-right');
            const notification = document.createElement('div');
            notification.className = 'notification general success'; // Utilise le style general succes
            notification.innerHTML = `<span class="text-4xl">ð</span><div><p class="font-bold text-lg sm:text-xl">TROPHEE DEBLOQUE !</p><p class="text-yellow-300 text-sm sm:text-base">${String(trophyName).toUpperCase()}</p><p class="text-gray-200 text-xs sm:text-sm">${String(description).toUpperCase()}</p></div>`;
            container.appendChild(notification);
            playTrophySound();
            void notification.offsetWidth; // Force reflow for animation
            // Legere temporisation pour que la notification de niveau apparaisse avant si elles sont declenchees en meme temps
            setTimeout(() => {
                notification.classList.add('show');
            }, 100);
            setTimeout(() => { notification.classList.remove('show'); notification.addEventListener('transitionend', () => notification.remove(), { once: true }); }, 12000);
        }

        // Gestion du contexte audio pour les effets sonores
        let audioContextStartedOnce = false;
        async function initializeAudioContextNonBlocking() {
            if (Tone.context.state === 'running' || audioContextStartedOnce) return;
            try {
                await Tone.start();
                audioContextStartedOnce = true;
                isAudioActive = true;
                Tone.Master.mute = false;
                Tone.Master.volume.value = masterVolume === 0 ? -Infinity : 20 * Math.log10(masterVolume);
                document.getElementById('audio-inactive-message').classList.add('hidden');
            } catch (e) {
                isAudioActive = false;
                Tone.Master.mute = true;
                document.getElementById('audio-inactive-message').classList.remove('hidden');
                document.getElementById('audio-inactive-message').textContent = "AUDIO DESACTIVE. CLIQUEZ OU APPUYEZ SUR UNE TOUCHE POUR ACTIVER LE SON ET LA SYNTHESE VOCALE.";
            }
        }

        // Gere le geste de l'utilisateur pour demarrer l'audio
        function handleUserGestureToStartAudio() { window.removeEventListener('click', handleUserGestureToStartAudio); window.removeEventListener('keydown', handleUserGestureToStartAudio); initializeAudioContextNonBlocking(); }

        // Configure les lecteurs audio pour les sons de l'application
        function setupAudioPlayers() {
            trophySoundPlayer = new Tone.PolySynth(Tone.Synth, { oscillator: { type: "square" }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.3 } }).toDestination();
            levelUpPlayer = new Tone.PolySynth(Tone.Synth, { oscillator: { type: "triangle" }, envelope: { attack: 0.005, decay: 0.05, sustain: 0.1, release: 0.2 } }).toDestination();
            majorLevelUpPlayer = new Tone.PolySynth(Tone.Synth, { oscillator: { type: "sawtooth" }, envelope: { attack: 0.01, decay: 0.3, sustain: 0.2, release: 0.6 }, volume: -6 }).toDestination();
            beepPlayer = new Tone.Oscillator(440, "sine").toDestination();
            startSoundPlayer = new Tone.PolySynth(Tone.Synth).toDestination();
            loadingSoundLoop = new Tone.Loop(time => { if (Tone.context && Tone.context.state === 'running') { new Tone.MembraneSynth().toDestination().triggerAttackRelease("C3", "16n", time); } }, "8n");
            loadingSoundLoop.stop();
            synth = window.speechSynthesis;
            Tone.Master.volume.value = masterVolume === 0 ? -Infinity : 20 * Math.log10(masterVolume);
            Tone.Master.mute = !isAudioActive;
        }

        // Active ou desactive le son de l'application
        function toggleAudioActive() {
            isAudioActive = !isAudioActive;
            if (isAudioActive) { initializeAudioContextNonBlocking(); showMessage("SON ACTIVE !", "success"); }
            else { Tone.Master.mute = true; showMessage("SON DESACTIVE.", "info"); }
            const mainContent = document.getElementById('main-content');
            renderOptionsView(mainContent);
        }

        // Joue le son de trophee
        function playTrophySound() { if (isAudioActive && Tone.context.state === 'running') { trophySoundPlayer.triggerAttackRelease(["C5", "E5", "G5", "C6"], "8n", Tone.context.currentTime); } }

        // Joue le son de montee de niveau
        function playLevelUpSound(level) {
            if (isAudioActive && Tone.context.state === 'running') {
                const now = Tone.context.currentTime;
                if (level > previousLevel) {
                    if (level % 10 === 0) { majorLevelUpPlayer.triggerAttackRelease(["C4", "E4", "G4", "C5", "E5"], "2n", now); }
                    else { levelUpPlayer.triggerAttackRelease("C4", "16n", now); levelUpPlayer.triggerAttackRelease("E4", "16n", now + 0.1); levelUpPlayer.triggerAttackRelease("G4", "16n", now + 0.2); levelUpPlayer.triggerAttackRelease("C5", "8n", now + 0.3); }
                }
            }
        }

        // Joue un bip sonore
        function playBeep(freq = 440, duration = 0.1) { if (isAudioActive && Tone.context.state === 'running') { beepPlayer.stop(); beepPlayer.start(Tone.context.currentTime); beepPlayer.frequency.setValueAtTime(freq, Tone.context.currentTime); beepPlayer.stop(Tone.context.currentTime + duration); } }

        // Joue un son de demarrage (type Mario Kart)
        function playMarioKartStartSound() {
            if (isAudioActive && Tone.context.state === 'running') {
                const now = Tone.context.currentTime;
                new Tone.MembraneSynth().toDestination().triggerAttackRelease("C5", "16n", now);
                new Tone.MembraneSynth().toDestination().triggerAttackRelease("E5", "16n", now);
                new Tone.MembraneSynth().toDestination().triggerAttackRelease("G5", "16n", now);
                new Tone.Synth().toDestination().triggerAttackRelease("C4", "1n", now + 2.5);
            }
        }

        // Fait parler l'IA avec la synthese vocale
        function speak(text) { if (isAudioActive) { if (synth) { synth.cancel(); const utterance = new SpeechSynthesisUtterance(text); utterance.lang = 'fr-FR'; synth.speak(utterance); } parlerAvecKodular(text); } }

        // Fonction specifique pour la communication avec Kodular (si l'application est packagee)
        function parlerAvecKodular(texte) { if (window.AppInventor && window.AppInventor.setWebViewString) { window.AppInventor.setWebViewString(texte); } }

        // Genere un identifiant unique
        function generateUniqueId() { return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => { const r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8); return v.toString(16); }); }

        // Formate une date au formatYYYY-MM-DD
        function formatDateToYYYYMMDD(date) { if (!(date instanceof Date) || isNaN(date.getTime())) return ''; const year = date.getFullYear(); const month = String(date.getMonth() + 1).padStart(2, '0'); const day = String(date.getDate()).padStart(2, '0'); return `${year}-${month}-${day}`; }

        // Retourne une chaine de caracteres decrivant le contexte du jour (poste et sport)
        function getDayContextString(shiftType, workoutType) {
            let context = "";
            const sType = String(shiftType || ''), wType = String(workoutType || '');
            switch (sType) {
                case '6h-18h': context = "Travail de Jour (6H-18H)"; break;
                case '7h-18h': context = "Travail de Jour (7H-18H)"; break;
                case '18h-6h': context = "Travail de Nuit (18H-6H)"; break;
                case 'repos': context = "Jour de Repos"; break;
                case 'repos_sport': context = "Jour de Repos (SPORT)"; break;
                default: context = "Contexte Inconnu"; break;
            }
            if (wType && wType !== 'aucun') { context += ` - Sport: ${wType.toUpperCase().replace('_', ' ')}`; }
            return context;
        }

        // Retourne une chaine de caracteres decrivant le moment du repas dans le contexte du jour
        function getMealMomentContext(mealType, shiftType, sportType) {
            let moment = "";
            const sType = String(shiftType || ''), spType = String(sportType || '');
            if (mealType === 'petit_dejeuner') { moment = "PETIT-DEJEUNER"; if (sType === '18h-6h') moment += " POST-NUIT"; else if (spType !== 'aucun') moment += " PRE-ENTRAINEMENT"; }
            else if (mealType === 'dejeuner') { moment = "DEJEUNER"; if (sType === '18h-6h') moment += " PENDANT LE POSTE DE NUIT"; else if (spType !== 'aucun') moment += " POST-ENTRAINEMENT"; else if (sType.includes('jour')) moment += " JOURNEE DE TRAVAIL"; }
            else if (mealType === 'diner') { moment = "DINER"; if (sType === '18h-6h') moment += " PRE-POSTE DE NUIT"; else if (spType !== 'aucun') moment += " POST-ENTRAINEMENT"; else if (sType.includes('jour')) moment += " APRES JOURNEE DE TRAVAIL"; }
            else if (mealType === 'collation_matin') { moment = "COLLAT. MATIN"; }
            else if (mealType === 'collation_apresmidi') { moment = "COLLAT. APRES-MIDI"; }
            else if (mealType === 'collation_unique') { if (sType === '18h-6h') moment = "COLLAT. PENDANT POSTE DE NUIT"; else if (sType === '7h-18h') moment = "COLLAT. APRES-MIDI"; else if (spType !== 'aucun') moment = "COLLAT. POST-SPORT"; else if (sType.includes('repos')) moment = "COLLAT. LEGERE"; }
            return moment;
        }

        // Conseils specifiques pour les repas en fonction du contexte
        const specificMealAdvice = {
            'petit_dejeuner': { '18h-6h': "CONSEIL : APRES UN POSTE DE NUIT, PRIVILEGIE UN REPAS NUTRITIF POUR FAVORISER LA RECUPERATION ET UN SOMMEIL DE QUALITE. LES PROTEINES ET GLUCIDES LENTS SONT CLES.", 'default': "CONSEIL : UN PETIT-DEJEUNER EQUILIBRE EST ESSENTIEL POUR L'ENERGIE DU MATIN. VARIE LES SOURCES DE PROTEINES ET FIBRES." },
            'dejeuner': { '18h-6h': "CONSEIL : PENDANT UN POSTE DE NUIT, OPTE POUR DES PLATS FACILES A DIGERER, RICHES EN PROTEINES ET LEGUMES POUR MAINTENIR TON ENERGIE SANS ALOURDIR.", 'repos_sport': "CONSEIL : APRES LE SPORT, RECONSTITUE TES RESERVES. CE REPAS DEVRAIT ETRE RICHE EN GLUCIDES COMPLEXES POUR L'ENERGIE ET EN PROTEINES POUR LA REPARATION MUSCULAIRE.", 'default': "CONSEIL : POUR UN DEJEUNER OPTIMAL EN JOURNEE DE TRAVAIL, PRIVILEGIE UN PLAT EQUILIBRE QUI APPORTE UNE ENERGIE DURABLE SANS CAUSER DE COUP DE BARRE." },
            'diner': { '18h-6h': "CONSEIL : AVANT UN POSTE DE NUIT, CHOISIS UN DINER CONSISTANT MAIS FACILE A DIGERER POUR TE DONNER L'ENERGIE NECESSAIRE SANS PERTURBER TON DEBUT DE SOMMEIL PRE-POSTE.", 'repos_sport': "CONSEIL : LE DINER APRES UNE SEANCE DE SPORT DOIT COMPLETER LA RECUPERATION. CONCENTRE-TOI SUR LES PROTEINES POUR LA REPARATION ET LES GLUCIDES POUR REFAIRE LE PLEIN.", 'default': "CONSEIL : UN DINER LEGER EST IDEAL POUR FAVORISER UNE BONNE DIGESTION ET UN SOMMEIL REPARATEUR APRES UNE JOURNEE DE TRAVAIL. PRIVILEGIE LES LEGUMES ET PROTEINES MAIGRES." },
            'collation': { '6h-18h_matin': "CONSEIL : CETTE COLLATON MATINALE EST CLE POUR MAINTENIR TON ENERGIE ET EVITER LES BAISSES DE GLYCEMIE JUSQU'AU DEJEUNER.", '6h-18h_apresmidi': "CONSEIL : LA COLLATON DE L'APRES-MIDI AIDE A GERER LA FAIM ET A SOUTENIR TON ENERGIE JUSQU'AU DINER, SANS ALOURDIR AVANT LA FIN DU POSTE.", '18h-6h_pendant': "CONSEIL : UNE COLLATON PENDANT LA NUIT EST LEGERE ET ENERGISANTE POUR MAINTENIR TA VIGILANCE SANS PERTURBER TA DIGESTION.", '7h-18h_apresmidi': "CONSEIL : LA COLLATON DE L'APRES-MIDI EST PARFAITE POUR SOUTENIR SON ENERGIE LORS DES JOURS DE LONG POSTE OU DE REPOS ACTIF.", 'repos_sport_post': "CONSEIL : UNE COLLATON POST-SPORT EST CRUCIALE POUR UNE RECUPERATION RAPIDE. PRIVILEGIE UN MIX DE PROTEINES ET GLUCIDES.", 'repos_default': "CONSEIL : UNE COLLATON LEGERE EN JOUR DE REPOS PEUT AIDER A GERER LA FAIM ET APPORTER DES NUTRIENTS SUPPLEMENTAIRES." }
        };

        // Calcule les seuils d'XP pour chaque niveau
        function getLevelThresholds(level) {
            // XP requise pour atteindre le niveau 'level'
            if (level === 0) return { current: 0, next: 100 }; // Pour passer du niveau 0 au niveau 1, il faut 100 XP
            let xp = 0;
            for (let i = 1; i <= level; i++) {
                xp += (i * 50 + 50); // XP requise pour le niveau i
            }
            const prevLevelThreshold = xp - (level * 50 + 50); // XP totale requise pour atteindre le niveau precedent (level-1)
            return { current: prevLevelThreshold, next: xp }; // 'current' est le seuil pour le debut du niveau actuel, 'next' pour le debut du niveau suivant
        }

        // Calcule le niveau actuel et l'XP restante pour le niveau suivant
        function calculateLevelAndXP(totalXP) {
            let level = 0;
            let xpNeededForCurrentLevel = 0; // XP needed to *start* the current level
            let xpNeededForNextLevel = 100; // XP needed to *reach* the next level (start of level 1)

            while (totalXP >= xpNeededForNextLevel) {
                level++;
                xpNeededForCurrentLevel = xpNeededForNextLevel; // Update XP needed to start this level
                xpNeededForNextLevel = Math.round(100 + (level * 50 * (1 + level / 10))); // Calculate XP needed to reach the *next* level
            }

            // XP earned within the current level
            const xpProgressInCurrentLevel = totalXP - xpNeededForCurrentLevel;

            // Total XP required to complete the current level (i.e., the difference between xpNeededForNextLevel and xpNeededForCurrentLevel)
            const xpForThisLevel = xpNeededForNextLevel - xpNeededForCurrentLevel;

            const xpRemainingForNextLevel = xpForThisLevel - xpProgressInCurrentLevel;

            return { level: level, xpCurrentLevel: xpProgressInCurrentLevel, xpForThisLevel: xpForThisLevel, xpToNextLevel: xpRemainingForNextLevel };
        }

        // Initialise l'application au demarrage
        async function initializeApp() {
            isLoadingApp = true;
            renderLoadingScreen();
            let currentLoadProgress = 0;
            const updateProgress = (target) => {
                const diff = target - currentLoadProgress;
                const step = diff / 10;
                const interval = setInterval(() => {
                    currentLoadProgress += step;
                    if (currentLoadProgress >= target) { currentLoadProgress = target; clearInterval(interval); }
                    loadingProgress = Math.min(100, Math.floor(currentLoadProgress));
                    document.getElementById('loading-progress-bar').style.width = `${loadingProgress}%`;
                    document.getElementById('loading-progress-text').textContent = `${loadingProgress}% CHARGEMENT...`;
                }, 50);
            };

            try {
                updateProgress(20);
                setupAudioPlayers();
                updateProgress(40);
                initializeGlobalState();
                updateXPBar();
                updateProfileDisplay();
                updateProgress(60);
                userId = 'local_user'; // Utilisation d'un ID local pour l'instant
                document.getElementById('user-id-value').textContent = userId;
                document.getElementById('user-id-display').classList.remove('hidden');
                renderPage(currentPage);
                attachEventListeners();
                renderLucideIcons();
                updateProgress(80);
                window.addEventListener('click', handleUserGestureToStartAudio, { once: true });
                window.addEventListener('keydown', handleUserGestureToStartAudio, { once: true });
                initializeAudioContextNonBlocking();
                updateProgress(100);
            } catch (error) { console.error("Echec de l'initialisation de l'application :", error); showMessage(`ERREUR D'INITIALISATION: ${error.message}`, 'error'); }
            finally {
                if (loadingSoundLoop && loadingSoundLoop.state === 'started') { loadingSoundLoop.stop(); }
                setTimeout(() => {
                    isLoadingApp = false;
                    document.getElementById('loading-screen').classList.add('hidden');
                    document.getElementById('app-container').classList.remove('hidden');
                    document.getElementById('loading-message').classList.add('hidden');
                    if (!isAudioActive && Tone.context.state !== 'running') { document.getElementById('audio-inactive-message').classList.remove('hidden'); document.getElementById('audio-inactive-message').textContent = "AUDIO DESACTIVE. CLIQUEZ OU APPUYEZ SUR UNE TOUCHE POUR ACTIVER LE SON ET LA SYNTHESE VOCALE."; }
                    else if (isAudioActive && Tone.context.state === 'running') { document.getElementById('audio-inactive-message').classList.add('hidden'); }
                }, 1000);
            }
        }

        // Affiche l'ecran de chargement
        function renderLoadingScreen() {
            document.getElementById('loading-progress-bar').style.width = `${loadingProgress}%`;
            document.getElementById('loading-progress-text').textContent = `${loadingProgress}% CHARGEMENT...`;
            const audioInactiveMessage = document.getElementById('audio-inactive-message');
            if (audioInactiveMessage) { audioInactiveMessage.classList.toggle('hidden', isAudioActive || loadingProgress < 100); }
        }

        // Rend la page principale en fonction du nom de la page
        function renderPage(pageName) {
            const mainContent = document.getElementById('main-content');
            mainContent.innerHTML = ''; // Nettoie le contenu precedent
            if (weightChartInstance) { weightChartInstance.destroy(); weightChartInstance = null; } // Detruit les instances de graphique si elles existent
            if (exerciseChartInstance) { exerciseChartInstance.destroy(); exerciseChartInstance = null; }

            // Met a jour l'etat visuel des boutons de navigation
            document.querySelectorAll('.nav-item').forEach(button => {
                const isActive = button.dataset.page === pageName;
                button.classList.toggle('bg-blue-600', isActive);
                button.classList.toggle('text-white', isActive);
                button.classList.toggle('font-semibold', isActive);
                button.classList.toggle('border-blue-800', isActive);
                button.classList.toggle('shadow-inner', isActive);
                button.classList.toggle('text-gray-200', !isActive);
                button.classList.toggle('hover:bg-gray-700', !isActive);
                button.classList.toggle('hover:text-yellow-300', !isActive);
                button.classList.toggle('border-gray-700', !isActive);
            });

            currentPage = pageName; // Met a jour la page actuelle

            // Rend le contenu de la page specifique
            switch (pageName) {
                case 'daily_plan': renderDailyPlanView(mainContent); break;
                case 'workout': renderWorkoutView(mainContent); break;
                case 'recipes': renderRecipeView(mainContent); break;
                case 'chrono': renderChronoIntervalleView(mainContent); break;
                case 'progress': renderProgressView(mainContent); break;
                case 'trophies': renderTrophyRoomView(mainContent); break;
                case 'options': renderOptionsView(mainContent); break;
                default: renderDailyPlanView(mainContent); break; // Page par defaut
            }
            renderLucideIcons(); // Rend les icones Lucide pour la nouvelle page
        }

        // Met a jour la barre d'experience (XP) et le niveau de l'utilisateur
        function updateXPBar() {
            const { level, xpCurrentLevel, xpForThisLevel } = calculateLevelAndXP(userProfile.currentXP);
            const progressBar = document.getElementById('xp-bar-fill');
            const progressText = document.getElementById('xp-bar-text');

            // Calculate progress within the current level
            const progressPercentage = xpForThisLevel > 0 ? (xpCurrentLevel / xpForThisLevel) * 100 : 0;
            const actualProgress = Math.max(0, Math.min(100, progressPercentage)); // Ensure percentage is between 0 and 100

            // Check for level up
            if (level > previousLevel) {
                // Play sounds and show messages for level up
                playLevelUpSound(level);
                showMessage(`FELICITATIONS, VOUS AVEZ ATTEINT LE NIVEAU ${level} !`, 'success');
                speak(`Felicitations, vous avez atteint le niveau ${level} !`);

                // Visual reset animation for level up:
                // 1. Temporarily remove transition for instant reset to 0%
                progressBar.style.transition = 'none';
                progressBar.style.width = '0%';

                // 2. Force a reflow to apply the 0% width instantly before the new fill animation
                void progressBar.offsetWidth;

                // 3. Re-add transition and set the actual new width after a very short delay
                // This makes the bar appear to "reset" to 0% and then fill up for the new level
                setTimeout(() => {
                    progressBar.style.transition = 'width 0.5s ease-in-out, background 0.5s ease-in-out'; // Re-add transition
                    progressBar.style.width = `${actualProgress}%`;
                }, 150); // Increased delay for a more noticeable reset
            } else {
                // Normal XP gain, just update width with existing transition
                progressBar.style.transition = 'width 0.5s ease-in-out, background 0.5s ease-in-out'; // Ensure transition is always on for normal updates
                progressBar.style.width = `${actualProgress}%`;
            }

            // Update the text display for current level and XP progress
            progressText.textContent = `LVL ${level} : ${xpCurrentLevel}/${xpForThisLevel} XP`;

            previousLevel = level; // Met a jour le niveau precedent
            checkAndAwardTrophies(level); // Verifie et attribue les trophees
        }

        // Verifie si des trophees ont ete gagnes et les attribue
        function checkAndAwardTrophies(currentLevel) {
            let earnedTrophies = userProfile.earnedTrophies || [], newTrophiesEarned = [];
            allTrophies.forEach(trophy => { if (currentLevel >= trophy.levelRequired && !earnedTrophies.some(t => t.id === trophy.id)) { newTrophiesEarned.push(trophy); earnedTrophies.push({ id: trophy.id, name: trophy.name, description: trophy.description, levelRequired: trophy.levelRequired, timestamp: new Date().toISOString() }); } });
            if (newTrophiesEarned.length > 0) {
                userProfile.earnedTrophies = earnedTrophies;
                saveToLocalStorage('userProfile', userProfile);
                newTrophiesEarned.forEach(trophy => showTrophyNotification(trophy.name, trophy.description));
                if (currentPage === 'trophies') renderTrophyRoomView(document.getElementById('main-content'));
            }
        }

        // Met a jour l'affichage du profil utilisateur
        function updateProfileDisplay() {
            const heightInput = document.getElementById('userHeight'), weightInput = document.getElementById('userWeight'), imcDisplay = document.getElementById('imc-display'), imcValue = document.getElementById('imc-value'), imcCategory = document.getElementById('imc-category'), proteinNeeds = document.getElementById('protein-needs');
            heightInput.value = userProfile.height;
            weightInput.value = userProfile.weight;
            if (userProfile.imc && userProfile.imcCategory && userProfile.proteinNeeds) { imcValue.textContent = userProfile.imc; imcCategory.textContent = userProfile.imcCategory; proteinNeeds.textContent = `${userProfile.proteinNeeds} G/JOUR`; imcDisplay.classList.remove('hidden'); }
            else { imcDisplay.classList.add('hidden'); }
        }

        // Gere la sauvegarde du profil utilisateur (taille, poids, IMC)
        async function handleSaveProfile() {
            const height = document.getElementById('userHeight').value, weight = document.getElementById('userWeight').value;
            if (!height || !weight) { showMessage("ERREUR: TAILLE ET POIDS REQUIS POUR L'IMC.", 'error'); return; }
            const currentHeight = parseFloat(height), currentWeight = parseFloat(weight), currentImc = (currentWeight / ( (currentHeight / 100) * (currentHeight / 100) )).toFixed(2);
            let currentImcCategory;
            const imcVal = parseFloat(currentImc);
            const imcCategories = [ { threshold: 16.5, category: 'INSUFFISANCE PONDERALE (DENUTRITION SEVERE)' }, { threshold: 18.5, category: 'INSUFFISANCE PONDERALE' }, { threshold: 25, category: 'POIDS NORMAL' }, { threshold: 27, category: 'SURPOIDS (PRE-OBESITE)' }, { threshold: 30, category: 'OBESITE CLASSE I' }, { threshold: 35, category: 'OBESITE CLASSE II (SEVERE)' }, { threshold: 40, category: 'OBESITE CLASSE III (MORBIDE OU MASSIVE)' }, { threshold: Infinity, category: 'OBESITE CLASSE III (MORBIDE OU MASSIVE)' } ];
            for (const cat of imcCategories) { if (imcVal < cat.threshold) { currentImcCategory = cat.category; break; } }
            const proteinMultiplier = 1.6, currentProteinNeeds = (currentWeight * proteinMultiplier).toFixed(0);
            let newXP = userProfile.currentXP;
            const oldWeight = parseFloat(userProfile.weight) || 0, oldImcCategory = userProfile.imcCategory || '';
            if (oldWeight > 0 && currentWeight !== oldWeight) {
                const weightDiff = oldWeight - currentWeight;
                const oldImcIndex = imcCategories.findIndex(c => c.category === oldImcCategory), currentImcIndex = imcCategories.findIndex(c => c.category === currentImcCategory);
                if (currentImcIndex < oldImcIndex) { newXP += 50; showMessage(`XP GAGNEE: AMELIORATION DE L'IMC !`, 'success'); }
                else if (currentImcIndex > oldImcIndex) { newXP = Math.max(0, newXP - 30); showMessage(`XP PERDUE: DETERIORATION DE L'IMC.`, 'warning'); }
                if (currentImcCategory === 'POIDS NORMAL') { if (!oldImcCategory.includes('POIDS NORMAL')) { newXP += 100; showMessage(`XP GAGNEE: ENTREE DANS LA CATEGORIE DE POIDS NORMAL !`, 'success'); } else { newXP += 5; showMessage(`XP GAGNEE: MAINTIEN DANS LA CATEGORIE DE POIDS NORMAL !`, 'success'); } }
                else if (currentImcCategory.includes('INSUFFISANCE PONDERALE') && weightDiff < 0) { newXP += Math.round(Math.abs(weightDiff) * 10); showMessage(`XP GAGNEE: PRISE DE POIDS VERS LA NORMALITE !`, 'success'); }
                else if ((currentImcCategory.includes('SURPOIDS') || currentImcCategory.includes('OBESITE')) && weightDiff > 0) { newXP += Math.round(weightDiff * 10); showMessage(`XP GAGNEE: PERTE DE POIDS VERS LA NORMALITE !`, 'success'); }
                else if (currentImcCategory.includes('INSUFFISANCE PONDERALE') && weightDiff > 0) { newXP = Math.max(0, newXP - Math.round(Math.abs(weightDiff) * 5)); showMessage(`XP PERDUE: PERTE DE POIDS A PARTIR DE LA NORMALITE !`, 'warning'); }
                else if ((currentImcCategory.includes('SURPOIDS') || currentImcCategory.includes('OBESITE')) && weightDiff < 0) { newXP = Math.max(0, newXP - Math.round(Math.abs(weightDiff) * 5)); showMessage(`XP PERDUE: PRISE DE POIDS A PARTIR DE LA NORMALITE !`, 'warning'); }
            }
            userProfile = { ...userProfile, height: currentHeight, weight: currentWeight, imc: currentImc, imcCategory: currentImcCategory, proteinNeeds: currentProteinNeeds, currentXP: newXP, updatedAt: new Date().toISOString() };
            saveToLocalStorage('userProfile', userProfile);
            updateProfileDisplay();
            updateXPBar();
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const todayFormatted = formatDateToYYYYMMDD(today);
            const existingEntryIndex = weightHistory.findIndex(entry => formatDateToYYYYMMDD(new Date(entry.date)) === todayFormatted);
            if (existingEntryIndex !== -1) { weightHistory[existingEntryIndex] = { ...weightHistory[existingEntryIndex], weight: currentWeight, imc: currentImc, imcCategory: currentImcCategory, timestamp: new Date().toISOString() }; }
            else { weightHistory.push({ id: generateUniqueId(), date: new Date().toISOString(), weight: currentWeight, imc: currentImc, imcCategory: currentImcCategory, timestamp: new Date().toISOString() }); }
            saveToLocalStorage('weightHistory', weightHistory);
            if (currentPage === 'progress') renderProgressView(document.getElementById('main-content'));
        }

        // Rend la vue du planning quotidien
        function renderDailyPlanView(container) {
            let html = `<div class="card-retro mb-6"><h2 class="text-3xl sm:text-4xl font-bold text-yellow-300 mb-4 text-center">MON PLANNING</h2><div class="mb-6 space-y-4 p-4 rounded-lg border-2 border-blue-700 bg-gray-700"><h3 class="text-xl sm:text-2xl text-yellow-300 mb-3">AJOUTER UN POSTE :</h3><div class="relative"><label for="shiftDate" class="block text-white-200 text-sm font-bold mb-2">DATE DU POSTE :</label><input type="date" id="shiftDate" class="input-retro pr-10" style="color: #ffffff;" value="" /><i data-lucide="calendar" class="absolute right-11 top-12 -translate-y-1/2 text-white pointer-events-none" style="width:15px; height:18px;"></i></div><div><label for="shiftType" class="block text-gray-200 text-sm font-bold mb-2">TYPE DE POSTE :</label><select id="shiftType" class="select-retro"><option value="6h-18h">POSTE JOUR (6H-18H)</option><option value="7h-18h">POSTE JOUR (7H-18H)</option><option value="18h-6h">POSTE NUIT (18H-6H)</option><option value="repos">JOUR DE REPOS</option><option value="repos_sport">JOUR DE REPOS (SPORT)</option></select></div><div><label for="workoutType" class="block text-gray-200 text-sm font-bold mb-2">SEANCE SPORT PREVUE :</label><select id="workoutType" class="select-retro"><option value="aucun">AUCUNE</option><option value="renforcement">RENFORCEMENT MUSCULAIRE</option><option value="cardio">CARDIO</option><option value="hiit">HIIT</option><option value="repos_actif">RECUPERATION ACTIVE / FLEXIBILITE</option></select></div><button id="add-shift-btn" class="btn-retro w-full">AJOUTER POSTE</button></div><h3 class="text-xl sm:text-2xl text-yellow-300 mb-3">TON PLAN POUR LES JOURS PLANIFIES :</h3><div id="shifts-list" class="space-y-6"></div></div>`;
            container.innerHTML = html;
            const shiftDateInput = document.getElementById('shiftDate'), shiftTypeSelect = document.getElementById('shiftType'), workoutTypeSelect = document.getElementById('workoutType'), addShiftBtn = document.getElementById('add-shift-btn'), shiftsListDiv = document.getElementById('shifts-list');
            addShiftBtn.onclick = async () => {
                const date = shiftDateInput.value, type = shiftTypeSelect.value, workout = workoutTypeSelect.value;
                if (!date || !type) { showMessage("ERREUR: DATE ET TYPE DE POSTE REQUIS.", 'error'); return; }
                const dateObj = new Date(date);
                dateObj.setHours(0, 0, 0, 0); // Reinitialise l'heure pour la comparaison de date
                if (shifts.some(s => formatDateToYYYYMMDD(new Date(s.date)) === formatDateToYYYYMMDD(dateObj))) { showMessage("ERREUR: POSTE DEJA ENREGISTRE POUR CETTE DATE.", 'error'); return; }
                shifts.push({ id: generateUniqueId(), date: dateObj.toISOString(), type: type, workoutType: workout, createdAt: new Date().toISOString() });
                saveToLocalStorage('shifts', shifts);
                showMessage("SUCCES: POSTE AJOUTE !", 'success');
                shiftDateInput.value = ''; workoutTypeSelect.value = 'aucun';
                renderDailyPlanView(container); // Re-render pour afficher la liste mise a jour
            };
            renderShiftsList(shiftsListDiv, shifts);
        }

        // Rend la liste des postes planifies
        function renderShiftsList(container, shiftsData) {
            container.innerHTML = '';
            if (shiftsData.length === 0) { container.innerHTML = '<p class="text-gray-400">AUCUN POSTE ENREGISTRE. AJOUTE TON PREMIER POSTE CI-DESSOUS !</p>'; return; }
            const sortedShifts = [...shiftsData].sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime()); // Trie par date decroissante
            sortedShifts.forEach(shift => {
                const dateObj = new Date(shift.date);
                const dateString = dateObj.toLocaleDateString('fr-FR', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' }).toUpperCase();
                const routine = sleepRoutines[String(shift.type)] || sleepRoutines['repos']; // Recupere la routine de sommeil
                const mealForThisDay = weeklyMealPlan?.semaine?.find(d => d.date === formatDateToYYYYMMDD(dateObj)); // Trouve le repas pour ce jour
                const shiftDiv = document.createElement('div');
                shiftDiv.className = "bg-gray-700 p-4 rounded-lg border-4 border-purple-500 shadow-lg";
                shiftDiv.innerHTML = `<div class="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-3"><h4 class="text-lg sm:text-xl font-bold text-yellow-300">${dateString} - POSTE: ${String(shift.type).toUpperCase()}</h4><button class="btn-retro-red text-sm px-3 py-1 mt-2 sm:mt-0 delete-shift-btn" data-id="${shift.id}" data-date="${formatDateToYYYYMMDD(dateObj)}">SUPPRIMER</button></div>${String(shift.workoutType) !== 'aucun' ? `<div class="mb-3 p-2 bg-blue-800 rounded-md border border-purple-400"><p class="text-sm sm:text-base font-medium text-white">SEANCE SPORT : ${String(shift.workoutType).toUpperCase().replace('_', ' ')} PREVUE</p></div>` : ''}<div class="mb-4"><h5 class="font-semibold text-base sm:text-lg text-yellow-300 mb-2">PLAN REPAS SUGGERE :</h5>${mealForThisDay ? `<ul class="list-disc list-inside text-gray-300 text-sm space-y-1">${mealForThisDay.petit_dejeuner ? `<li>**PETIT-DEJEUNER :** ${String(mealForThisDay.petit_dejeuner.title || 'TITRE INDISPONIBLE').toUpperCase()}</li>` : ''}${mealForThisDay.dejeuner ? `<li>**DEJEUNER :** ${String(mealForThisDay.dejeuner.title || 'TITRE INDISPONIBLE').toUpperCase()}</li>` : ''}${mealForThisDay.diner ? `<li>**DINER :** ${String(mealForThisDay.diner.title || 'TITRE INDISPONIBLE').toUpperCase()}</li>` : ''}${mealForThisDay.collation_matin ? `<li>**COLLAT. MATIN :** ${String(mealForThisDay.collation_matin.title || 'TITRE INDISPONIBLE').toUpperCase()}</li>` : ''}${mealForThisDay.collation_apresmidi ? `<li>**COLLAT. APRES-MIDI :** ${String(mealForThisDay.collation_apresmidi.title || 'TITRE INDISPONIBLE').toUpperCase()}</li>` : ''}${mealForThisDay.collation_unique ? `<li>**COLLAT. UNIQUE :** ${String(mealForThisDay.collation_unique.title || 'TITRE INDISPONIBLE').toUpperCase()}</li>` : ''}</ul>` : `<p class="text-gray-400">PLAN DE REPAS NON DISPONIBLE POUR CE JOUR. GENEREZ UN PLAN HEBDOMADAIRE DANS L'ONGLET "RECETTES".</p>`}</div>`;
                container.appendChild(shiftDiv);
            });
            // Attache les ecouteurs d'evenements pour les boutons de suppression de poste
            container.querySelectorAll('.delete-shift-btn').forEach(button => {
                button.onclick = async (event) => {
                    const idToDelete = event.target.dataset.id;
                    const dateToDelete = event.target.dataset.date; // Get the date of the shift to delete

                    if (await showConfirmModal("CONFIRMER LA SUPPRESSION DU POSTE ET DE SON PLAN DE REPAS ASSOCIE ?")) {
                        shifts = shifts.filter(s => s.id !== idToDelete);
                        saveToLocalStorage('shifts', shifts);

                        // Also remove the corresponding day from weeklyMealPlan
                        if (weeklyMealPlan && weeklyMealPlan.semaine) {
                            weeklyMealPlan.semaine = weeklyMealPlan.semaine.filter(dayData => dayData.date !== dateToDelete);
                            saveToLocalStorage('weeklyMealPlan', weeklyMealPlan);
                        }

                        showMessage("SUCCES: POSTE ET REPAS ASSOCIES SUPPRIMES !", 'success');
                        renderDailyPlanView(document.getElementById('main-content')); // Re-render pour afficher la liste mise a jour
                        renderRecipeView(document.getElementById('main-content')); // Re-render recipe view to update meal plan
                    }
                };
            });
        }

        // Rend la vue du programme sportif
        function renderWorkoutView(container) {
            let html = `<div class="card-retro mb-6"><h2 class="text-3xl sm:text-4xl font-bold text-yellow-300 mb-4 text-center">PROGRAMME SPORTIF</h2><div class="p-4 rounded-lg border-2 border-purple-500 bg-gray-700"><h3 class="font-semibold text-xl sm:text-2xl mb-3 text-yellow-300">LIGNES DIRECTRICES SPORTIVES :</h3><ul class="list-disc list-inside text-gray-300 text-sm sm:text-base space-y-1"><li>3-4 SESSIONS PAR SEMAINE (FORCE / CARDIO OU ALTERNANCE HIIT).</li><li>10-15 MIN D'ECHAUFFEMENT AVANT CHAQUE SEANCE.</li><li>5-10 MIN DE RECUPERATION ET D'ETIREMENTS APRES CHAQUE SEANCE.</li><li>LES JOURS DE REPOS ACTIF (MARCHE, ETIREMENTS DOUX) FORTEMENT RECOMMANDES POUR LA RECUPERATION (SCLEROSE EN PLAQUES).</li><li>HYDRATATION CONSTANTE.</li></ul></div><div class="mb-6 mt-6"><label for="phaseSelect" class="block text-gray-200 text-sm font-bold mb-2">CHOISIR UNE PHASE :</label><select id="phaseSelect" class="select-retro"><option value="phase1">${String(workoutProgram.phase1?.name || 'PHASE 1').toUpperCase()}</option><option value="phase2">${String(workoutProgram.phase2?.name || 'PHASE 2').toUpperCase()}</option></select></div><div id="workout-phase-content" class="space-y-6"></div></div>`;
            container.innerHTML = html;
            const phaseSelect = document.getElementById('phaseSelect'), workoutPhaseContent = document.getElementById('workout-phase-content');
            let selectedPhase = loadFromLocalStorage('selectedWorkoutPhase', 'phase1');
            if (!workoutProgram[selectedPhase]) { selectedPhase = 'phase1'; saveToLocalStorage('selectedWorkoutPhase', selectedPhase); }
            phaseSelect.value = selectedPhase;

            // Rend le contenu de la phase d'entrainement selectionnee
            function renderPhaseContent(phase) {
                const currentPhaseData = workoutProgram[phase];
                if (!currentPhaseData || !currentPhaseData.sessions || !currentPhaseData.sessions.main || !currentPhaseData.sessions.cardio || !currentPhaseData.sessions.hiit) { workoutPhaseContent.innerHTML = '<p class="text-gray-400 text-center">CONTENU DE LA PHASE INDISPONIBLE. VEUILLEZ IMPORTER UN PROGRAMME VALIDE ET COMPLET.</p>'; return; }
                const generateExerciseHtml = (ex, index) => `<div class="flex flex-col sm:flex-row sm:items-center justify-between p-3 rounded-md border-2 border-blue-700 bg-gray-800 shadow-md"><div class="flex-1"><p class="font-medium text-gray-100 text-base sm:text-lg">${index + 1}. ${String(ex.name).toUpperCase()}</p><p class="text-sm text-gray-400 italic">${String(ex.desc).toUpperCase()}</p></div><button class="btn-retro-green text-sm px-4 py-2 mt-2 sm:mt-0 log-workout-btn" data-exercise-name="${ex.name}" data-exercise-type="${ex.type}">ENREGISTRER</button></div>`;
                let phaseHtml = `<h3 class="text-xl sm:text-2xl font-bold text-blue-400">${String(currentPhaseData.name).toUpperCase()}</h3><div class="p-4 rounded-lg border-2 border-purple-500 bg-gray-700 mt-4"><h4 class="font-semibold text-xl sm:text-2xl mb-3 text-yellow-300">PRINCIPES GENERAUX DE L'ENTRAINEMENT :</h4><ul class="list-disc list-inside text-gray-300 text-sm sm:text-base space-y-1"><li>ECOUTEZ VOTRE CORPS : NE JAMAIS FORCER SI VOUS AVEZ MAL.</li><li>LA FORME AVANT LA CHARGE : CONCENTREZ-VOUS SUR L'EXECUTION CORRECTE.</li><li>SURCHARGE PROGRESSIVE : AUGMENTEZ LA CHARGE OU LES REPETITIONS LORSQUE VOUS ETES A L'AISE.</li><li>HYDRATATION : BUVEZ DE L'EAU AVANT, PENDANT ET APRES CHAQUE SEANCE.</li></ul></div><div class="p-4 rounded-lg border-2 border-purple-500 bg-gray-700 mt-4"><h4 class="font-semibold text-xl sm:text-2xl mb-3 text-yellow-300">${String(currentPhaseData.sessions.main.name).toUpperCase()}</h4><h5 class="font-medium text-lg sm:text-xl mb-2 text-blue-400">ECHAUFFEMENT (10-15 MIN) :</h5><ul class="list-disc list-inside text-gray-300 text-sm sm:text-base mb-4 space-y-1"><li>**CARDIO LEGIER (5-7 MIN):** TAPIS DE COURSE (MARCHE RAPIDE 5,0 KM/H, INCLINAISON 1,0) OU VELO/ELLIPTIQUE (NIVEAU 3-5).</li><li>**MOBILISATIONS ARTICULAIRES DYNAMIQUES (5-8 MIN):** CERCLES DE BRAS, ROTATIONS DU TORSE, FENTES (A VIDE), ROTATIONS DE HANCHE, CERCLES DE CHEVILLES ET DE POIGNETS (10-15 REPETITIONS CHACUN).</li></ul><div class="space-y-3">${currentPhaseData.sessions.main.exercises.map(generateExerciseHtml).join('')}</div><h5 class="font-medium text-lg sm:text-xl mt-4 mb-2 text-blue-400">RECUPERATION (5-10 MIN) :</h5><ul class="list-disc list-inside text-gray-300 text-sm sm:text-base space-y-1"><li>**ETIREMENTS DOUX :** MAINTENEZ CHAQUE ETIREMENT PENDANT 20-30 SECONDES, SANS DOULEUR. CONCENTREZ-VOUS SUR LES ISCHIO-JAMBIERS, LES QUADRICEPES, LES PECTORAUX, LE DOS, LES EPAULES ET LES BRAS.</li></ul></div><div class="p-4 rounded-lg border-2 border-purple-500 bg-gray-700 mt-4"><h4 class="font-semibold text-xl sm:text-2xl mb-3 text-yellow-300">${String(currentPhaseData.sessions.cardio.name).toUpperCase()}</h4><h5 class="font-medium text-lg sm:text-xl mb-2 text-blue-400">ECHAUFFEMENT (10-15 MIN) :</h5><ul class="list-disc list-inside text-gray-300 text-sm sm:text-base mb-4 space-y-1"><li>**CARDIO LEGIER (5-7 MIN):** TAPIS DE COURSE (MARCHE RAPIDE 5,0 KM/H, INCLINAISON 1,0) OU VELO/ELLIPTIQUE (NIVEAU 3-5).</li><li>**MOBILISATIONS ARTICULAIRES DYNAMIQUES (5-8 MIN):** CERCLES DE BRAS, ROTATIONS DU TORSE, FENTES (A VIDE), ROTATIONS DE HANCHE, CERCLES DE CHEVILLES ET DE POIGNETS (10-15 REPETITIONS CHACUN).</li></ul><div class="space-y-3">${currentPhaseData.sessions.cardio.options.map(generateExerciseHtml).join('')}</div><h5 class="font-medium text-lg sm:text-xl mt-4 mb-2 text-blue-400">RECUPERATION (5-10 MIN) :</h5><ul class="list-disc list-inside text-gray-300 text-sm sm:text-base space-y-1"><li>**ETIREMENTS DOUX :** MAINTENEZ CHAQUE ETIREMENT PENDANT 20-30 SECONDES, SANS DOULEUR. CONCENTREZ-VOUS SUR LES ISCHIO-JAMBIERS, LES QUADRICEPES, LES PECTORAUX, LE DOS, LES EPAULES ET LES BRAS.</li></ul></div><div class="p-4 rounded-lg border-2 border-purple-500 bg-gray-700 mt-4"><h4 class="font-semibold text-xl sm:text-2xl mb-3 text-yellow-300">${String(currentPhaseData.sessions.hiit.name).toUpperCase()}</h4><p class="text-sm sm:text-base text-gray-300 mb-4">${String(currentPhaseData.sessions.hiit.desc).toUpperCase()}</p><h5 class="font-medium text-lg sm:text-xl mb-2 text-blue-400">ECHAUFFEMENT (10-15 MIN) :</h5><ul class="list-disc list-inside text-gray-300 text-sm sm:text-base mb-4 space-y-1"><li>**MOBILISATIONS ARTICULAIRES DYNAMIQUES (5-7 MIN):** CERCLES DE BRAS, ROTATIONS DU TORSE, FENTES (A VIDE), ROTATIONS DE HANCHE, CERCLES DE CHEVILLES ET DE POIGNETS (10-15 REPETITIONS CHACUN).</li></ul><div class="space-y-3">${currentPhaseData.sessions.hiit.exercises.map(generateExerciseHtml).join('')}</div><h5 class="font-medium text-lg sm:text-xl mt-4 mb-2 text-blue-400">RECUPERATION (5-10 MIN) :</h5><ul class="list-disc list-inside text-gray-300 text-sm sm:text-base space-y-1"><li>**RETOUR AU CALME :** MARCHE LEGERE ET RESPIRATION PROFONDE.</li><li>**ETIREMENTS DOUX :** AXES SUR LES MUSCLES PRINCIPAUX SOLLICITES.</li></ul></div>`;
                
                // Add recovery section if it exists
                if (workoutProgram.recovery) {
                    phaseHtml += `<div class="p-4 rounded-lg border-2 border-purple-500 bg-gray-700 mt-4">
                        <h4 class="font-semibold text-xl sm:text-2xl mb-3 text-yellow-300">${String(workoutProgram.recovery.name).toUpperCase()}</h4>
                        <p class="text-sm sm:text-base text-gray-300 mb-4">${String(workoutProgram.recovery.desc).toUpperCase()}</p>
                        <ul class="list-disc list-inside text-gray-300 text-sm sm:text-base space-y-1">
                            ${workoutProgram.recovery.activities.map(activity => `<li>**${String(activity.name).toUpperCase()} :** ${String(activity.desc).toUpperCase()}</li>`).join('')}
                        </ul>
                    </div>`;
                }

                workoutPhaseContent.innerHTML = phaseHtml;
                renderLucideIcons(); // Rend les icones Lucide
                // Attache les ecouteurs d'evenements pour les boutons d'enregistrement d'entrainement
                workoutPhaseContent.querySelectorAll('.log-workout-btn').forEach(button => { button.onclick = (event) => showLogWorkoutModal({ name: event.target.dataset.exerciseName, type: event.target.dataset.exerciseType }); });
            }
            // Gere le changement de phase d'entrainement
            phaseSelect.onchange = (event) => { selectedPhase = event.target.value; saveToLocalStorage('selectedWorkoutPhase', selectedPhase); renderPhaseContent(selectedPhase); };
            renderPhaseContent(selectedPhase); // Rend le contenu de la phase initiale
        }

        // Genere et affiche un conseil de difficulte base sur le ressenti de l'utilisateur
        async function generateAndShowDifficultyTip(feeling, exerciseName) {
            const LLM_PROMPT = `Vous etes un coach sportif expert et bienveillant. Waeky vient d'enregistrer un exercice : "${exerciseName.toUpperCase()}" avec un ressenti de difficulte : "${feeling.toUpperCase()}". Generez un conseil court (maximum 2 phrases) et motivant, adapte a ce ressenti. - Si "FACILE", encouragez a augmenter la difficulte (poids, repetitions, vitesse, duree, etc.) ou a varier l'exercice. - Si "MOYEN", encouragez a maintenir l'effort et la constance, ou a envisager une legere progression. - Si "DIFFICILE", encouragez la perseverance, le repos, ou l'ajustement de la charge/intensite pour eviter le surentrainement. FORMAT DE REPONSE ATTENDU (STRICTEMENT EN JSON): { "tip": "VOTRE CONSEIL (EN MAJUSCULES)" }`.trim();
            try {
                const payload = { contents: [{ role: "user", parts: [{ text: LLM_PROMPT }] }], generationConfig: { responseMimeType: "application/json", responseSchema: { type: "OBJECT", properties: { "tip": { "type": "STRING" } }, required: ["tip"] } } };
                const apiKey = userProfile.apiKey || "", apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
                const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (!response.ok) { const errorText = await response.text(); throw new Error(`ERREUR HTTP lors de la generation du conseil: ${response.status} ${response.statusText} - ${errorText}`); }
                const rawResult = await response.text(), parsedContent = JSON.parse(JSON.parse(rawResult).candidates[0].content.parts[0].text);
                showMessage(parsedContent.tip, 'tip');
            } catch (error) { console.error("Erreur lors de la generation du conseil de difficulte:", error); showMessage(`CONSEIL IA INDISPONIBLE: ${error.message}`, 'warning'); }
        }

        // Affiche la modale pour enregistrer un entrainement
        function showLogWorkoutModal(currentExercise) {
            let modalHtml = `<div id="log-workout-modal" class="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center p-4 z-50 font-vt323"><div class="bg-gray-800 p-6 rounded-lg border-4 border-purple-500 shadow-xl w-full max-w-md text-white"><h3 class="text-2xl sm:text-3xl font-bold text-yellow-300 mb-4 text-center">ENREGISTRER L'ENTRAINEMENT</h3><p class="text-lg sm:text-xl mb-4 text-center">${String(currentExercise?.name).toUpperCase()}</p><div class="space-y-4"><div><label for="logSets" class="block text-gray-200 text-sm font-bold mb-2">SERIES / ROUNDS :</label><input type="text" id="logSets" class="input-retro" placeholder="EX: 3 ou 5 ROUNDS" /></div><div><label for="logReps" class="block text-gray-200 text-sm font-bold mb-2">REPETITIONS / DUREE :</label><input type="text" id="logReps" class="input-retro" placeholder="EX: 12 ou 30 MIN" /></div><div><label for="logWeight" class="block text-gray-200 text-sm font-bold mb-2">POIDS (KG, LAISSER VIDE SI NON APPLICABLE) :</label><input type="number" id="logWeight" class="input-retro" placeholder="EX: 50" /></div><div><label for="logFeeling" class="block text-gray-200 text-sm font-bold mb-2">RESSENTI :</label><select id="logFeeling" class="select-retro"><option value="Facile">FACILE</option><option value="Moyen">MOYEN</option><option value="Difficile">DIFFICILE</option></select></div><div><label for="logNotes" class="block text-gray-200 text-sm font-bold mb-2">NOTES (OPTIONNEL) :</label><textarea id="logNotes" class="input-retro h-24" placeholder="EX: SENTI TRES FORT SUR CETTE SEANCE..."></textarea></div></div><div class="flex justify-between mt-6 space-x-4"><button id="cancel-log-btn" class="btn-retro-red w-1/2">ANNULER</button><button id="save-log-btn" class="btn-retro-green w-1/2">ENREGISTRER</button></div></div></div>`;
            document.getElementById('global-modals-container').innerHTML = modalHtml;
            document.getElementById('cancel-log-btn').onclick = () => document.getElementById('log-workout-modal').remove();
            document.getElementById('save-log-btn').onclick = async () => {
                const sets = document.getElementById('logSets').value, reps = document.getElementById('logReps').value, weight = document.getElementById('logWeight').value, feeling = document.getElementById('logFeeling').value, notes = document.getElementById('logNotes').value;
                if (!sets || !reps) { showMessage("ERREUR: VEUILLEZ REMPLIR LES SERIES ET LES REPETITIONS.", 'error'); return; }
                const loggedWeight = parseFloat(weight) || 0, loggedSets = String(sets).trim(), loggedReps = String(reps).trim();
                const logDate = new Date(), currentPhase = document.getElementById('phaseSelect').value, workoutPhaseName = workoutProgram[currentPhase]?.name || 'PHASE INCONNUE';
                workoutLogs.push({ id: generateUniqueId(), date: logDate.toISOString(), exerciseName: currentExercise.name, phase: workoutPhaseName, sets: loggedSets, reps: loggedReps, weight: loggedWeight, workoutType: currentExercise.type, notes: notes, feeling: feeling, timestamp: new Date().toISOString() });
                saveToLocalStorage('workoutLogs', workoutLogs);
                showMessage("SUCCES: ENTRAINEMENT ENREGISTRE !", 'success');
                let xpGained = 5;
                const numericSets = parseFloat(loggedSets) || 0;
                if (numericSets > 0) xpGained += Math.min(10, Math.round(numericSets * 2));
                if (currentExercise.type && (currentExercise.type === 'hiit' || currentExercise.type.startsWith('hiit_') || currentExercise.type === 'cardio')) { const numericRepsMatch = loggedReps.match(/(\d+(\.\d+)?)/); if (numericRepsMatch) xpGained += Math.min(20, Math.round(parseFloat(numericRepsMatch[0]) / 2)); }
                else { const numericReps = parseFloat(loggedReps); if (!isNaN(numericReps) && numericReps > 0) xpGained += Math.min(20, Math.round((numericSets * numericReps) / 10)); }
                if (!isNaN(loggedWeight) && loggedWeight > 0) xpGained += 20;
                if (currentExercise.type && ['chest', 'back', 'shoulders', 'legs', 'arms', 'triceps', 'biceps', 'glutes'].includes(currentExercise.type) && !isNaN(loggedWeight) && loggedWeight > 0) { const maxHistoricalWeight = workoutLogs.filter(log => log.exerciseName === currentExercise.name).map(log => parseFloat(String(log.weight || 0))).filter(w => w > 0).reduce((max, log) => Math.max(max, log), 0); if (loggedWeight >= maxHistoricalWeight) { playTrophySound(); showMessage(`NOUVEAU RECORD PERSONNEL DE POIDS POUR "${String(currentExercise.name).toUpperCase()}" (${loggedWeight}KG)! FELICITATIONS!`, 'success'); } }
                userProfile.currentXP = (userProfile.currentXP || 0) + xpGained;
                saveToLocalStorage('userProfile', userProfile);
                updateXPBar();
                if (userProfile.apiKey) { generateAndShowDifficultyTip(feeling, currentExercise.name); }
                else { showMessage("CONSEIL IA NON GENERE: CLE API MANQUANTE.", 'info'); }
                document.getElementById('log-workout-modal').remove();
            };
        }

        // Fonction pour obtenir la cle de contexte d'un repas (type de repas, poste, sport)
        function getMealContextKey(mealType, dayContext) {
            // For petit_dejeuner and collation types, the key will be mealType_poste
            if (mealType === 'petit_dejeuner' || mealType.startsWith('collation')) {
                return `${mealType}_${dayContext.poste}`;
            }
            // For dejeuner and diner, the key will remain mealType_poste_sport
            return `${mealType}_${dayContext.poste}_${dayContext.sport}`;
        }

        // Fonction pour basculer l'etat "aime" d'un repas
        function toggleLikeMeal(meal) {
            if (!userProfile.likedMeals) {
                userProfile.likedMeals = [];
            }
            const existingIndex = userProfile.likedMeals.findIndex(likedMeal => likedMeal.id === meal.id);
            if (existingIndex > -1) {
                userProfile.likedMeals.splice(existingIndex, 1); // Retire si deja aime
                showMessage("REPAS RETIRE DES FAVORIS.", 'info');
            } else {
                // Stocke l'objet repas complet, y compris son contexte pour un futur matching
                userProfile.likedMeals.push({
                    id: meal.id,
                    title: meal.title,
                    description_du_plat: meal.description_du_plat,
                    ingredients_label: meal.ingredients_label,
                    ingredients_list: meal.ingredients_list,
                    preparation_steps: meal.preparation_steps,
                    ma_portion_waeky: meal.ma_portion_waeky,
                    conseils_reutilisation_economie: meal.conseils_reutilisation_economie,
                    notes: meal.notes,
                    mealType: meal.mealType, // Crucial pour le matching
                    dayContext: meal.dayContext // Crucial pour le matching
                });
                showMessage("REPAS AJOUTE AUX FAVORIS !", 'success');
            }
            saveToLocalStorage('userProfile', userProfile);
            renderRecipeView(document.getElementById('main-content')); // Re-render pour mettre a jour l'icone
        }

        // Genere un repas interne via l'API LLM
        async function generateInternalMeal(mealType, dayContext, otherMealsToday = [], currentMealToReplace = null, allowMeatFish, userProfileData, numberOfPeople = 1) {
            const finalNumberOfPeople = (mealType === 'petit_dejeuner' || mealType.startsWith('collation')) ? 1 : numberOfPeople;
            const userProfileForPrompt = { imc: userProfileData.imc, imcCategory: userProfileData.imcCategory, proteinNeeds: userProfileData.proteinNeeds, weight: userProfileData.weight };
            const mealSpecificConstraints = [];
            let imcAdaptation = "";

            if (userProfileForPrompt.imcCategory.includes('INSUFFISANCE PONDERALE')) { imcAdaptation = "Waeky est en insuffisance ponderale. Assurez un apport calorique suffisant et des aliments riches en nutriments pour favoriser une prise de poids saine."; }
            else if (userProfileForPrompt.imcCategory.includes('SURPOIDS') || userProfileForPrompt.imcCategory.includes('OBESITE')) { imcAdaptation = `Waeky est dans la categorie IMC "${userProfileForPrompt.imcCategory}". Privilegiez des recettes moins caloriques, plus riches en fibres et en proteines maigres pour favoriser la perte de poids et la satiete. Reduisez les portions de glucides et de lipides si necessaire.`; }
            else { imcAdaptation = "Waeky a un poids normal. Maintenez un equilibre macro-nutritionnel pour soutenir son niveau d'activite sans exces."; }
            mealSpecificConstraints.push(imcAdaptation);

            let mealContextDescription = "";
            if (mealType === 'petit_dejeuner') {
                mealContextDescription = "Petit-dejeuner";
                mealSpecificConstraints.push("Doit etre sucre, en evitant les saveurs salees (sauf si les oeufs sont integres dans une preparation sucree comme des crepes/pancakes).");
                mealSpecificConstraints.push("Les oeufs ne peuvent etre utilises que s'ils sont integres dans des preparations comme des crepes, des pancakes ou des porridges, PAS comme plat principal (ex: oeufs brouilles, omelette).");
                mealSpecificConstraints.push("PAS DE PATES, SEMOULE OU SAUCE TOMATE.");
                mealSpecificConstraints.push("AJOUTEZ UNE TRES GRANDE VARIETE DE PETITS-DEJEUNERS : TARTINES (MIEL, BEURRE, BEURRE DE CACAHUETE), THE (AVEC OU SANS LAIT), PORRIDGE, SHAKE DE WHEY (SI CONTEXTE SPORTIF LE PERMET), CEREALES, FRUITS, YAOURTS. ADAPTEZ LES OPTIONS AU TYPE DE SEANCE (EX: PORRIDGE POUR RENFORCEMENT, SHAKE POUR CARDIO) POUR EVITER LES DEPENSES INUTILES.");
            } else if (mealType === 'dejeuner') {
                mealContextDescription = "Dejeuner";
                mealSpecificConstraints.push("Doit etre un repas equilibre pour maintenir l'energie tout au long de la journee.");
                mealSpecificConstraints.push("PROPOSEZ UNE TRES GRANDE VARIETE DE RECETTES POUR EVITER LA MONOTONIE : SALADES (VERTE, ICEBERG, CRUDITES, POMMES DE TERRE, RIZ, PATES), GALETTES DE POMMES DE TERRE, RECETTES AVEC DU PAIN (EX: PAIN AVEC FROMAGE, TOASTS PROTEINES, SANDWICHS EQUILIBRES), BURGERS ET WRAPS (ADAPTES AU PROGRAMME NUTRITIONNEL).");
                mealSpecificConstraints.push("ALTERNEZ SYSTEMATIQUEMENT LES TYPES DE PROTEINES, GLUCIDES ET LEGUMES. INCLUEZ FREQUEMMENT PATES COMPLETES, SPAGHETTIS, PATES FRAICHES, RIZ BASMATI, QUINOA, PATATE DOUCE, SEMOULE COMPLETE. LEGUMES VARIES: CONCOMBRE, ARTICHAUT, BROCOLIS, POIVRONS, HARICOTS VERTS, COURGETTES, EPINARDS, CAROTTES, CHOU-FLEUR, TOMATES CERISES, LAITUE, RADIS, CHAMPIGNONS, AUBERGINE, OIGNON.");
                mealSpecificConstraints.push("VARIEZ EGALEMENT LES STYLES CULINAIRES ET LES SAVEURS A CHAQUE REPAS PRINCIPAL. BIEN QUE LA REPETITION SOIT POSSIBLE SI LE CONTEXTE DE POSTE ET DE SPORT EST IDENTIQUE, PRIVILEGIEZ LA NOUVEAUTE POUR CES REPAS AFIN DE MAINTENIR L'INTERET.");
            } else if (mealType === 'diner') {
                mealContextDescription = "Diner";
                mealSpecificConstraints.push("Doit etre un repas facilement digestible favorisant un bon sommeil.");
                mealSpecificConstraints.push("PROPOSEZ UNE TRES GRANDE VARIETE DE RECETTES POUR EVITER LA MONOTONIE : SALADES (VERTE, ICEBERG, CRUDITES, POMMES DE TERRE, RIZ, PATES), GALETTES DE POMMES DE TERRE, RECETTES AVEC DU PAIN (EX: PAIN AVEC FROMAGE, TOASTS PROTEINES, SANDWICHS EQUILIBRES), BURGERS ET WRAPS (ADAPTES AU PROGRAMME NUTRITIONNEL).");
                mealSpecificConstraints.push("ALTERNEZ SYSTEMATIQUEMENT LES TYPES DE PROTEINES, GLUCIDES ET LEGUMES. INCLUEZ FREQUEMMENT PATES COMPLETES, SPAGHETTIS, PATES FRAICHES, RIZ BASMATI, QUINOA, PATATE DOUCE, SEMOULE COMPLETE. LEGUMES VARIES: CONCOMBRE, ARTICHAUT, BROCOLIS, POIVRONS, HARICOTS VERTS, COURGETTES, EPINARDS, CAROTTES, CHOU-FLEUR, TOMATES CERISES, LAITUE, RADIS, CHAMPIGNONS, AUBERGINE, OIGNON.");
                mealSpecificConstraints.push("VARIEZ EGALEMENT LES STYLES CULINAIRES ET LES SAVEURS A CHAQUE REPAS PRINCIPAL. BIEN QUE LA REPETITION SOIT POSSIBLE SI LE CONTEXTE DE POSTE ET DE SPORT EST IDENTIQUE, PRIVILEGIEZ LA NOUVEAUTE POUR CES REPAS AFIN DE MAINTENIR L'INTERET.");
            } else if (mealType.startsWith('collation')) {
                mealContextDescription = "Collation";
                mealSpecificConstraints.push("Doit etre rapide, facile a transporter et energisante.");
                mealSpecificConstraints.push("AJOUTEZ UNE TRES GRANDE VARIETE DE COLLATIONS : BANANES, FRUITS SECS, BARRES PROTEINEES (MAISON OU COMMERCIALES), YAOURTS, SHAKES PROTEINES, GALETTES DE RIZ, LEGUMES COUPES AVEC HOUKOUS, FROMAGE BLANC. ADAPTEZ LES OPTIONS AU PROGRAMME NUTRITIONNEL ET SPORTIF.");
            }

            if (!allowMeatFish) {
                mealSpecificConstraints.push("Utilisez une source de proteines vegetarienne (lentilles, pois chiches, haricots rouges, tofu, seitan, tempeh, oeufs - si applicable au repas, produits laitiers comme fromage blanc, yaourt grec). NE PROPOSEZ PAS DE VIANDE, DE POISSON NI DE WHEY PROTEIN. ASSUREZ UNE GRANDE DIVERSITE ENTRE CES SOURCES VEGETARIENNES ET LAITIERES, NE VOUS LIMITEZ PAS UNIQUEMENT AUX LENTILLES.");
            } else {
                mealSpecificConstraints.push("POUR UNE DIVERSITE MAXIMALE ET UN APPORT NUTRITIONNEL COMPLET, VARIEZ SYSTEMATIQUEMENT LES SOURCES DE PROTEINES : ALTERNEZ ENTRE VIANDE (POULET, BOEUF MAIGRE, DINDE), POISSON (SAUMON, CABILLAUD, THON), LEGUMINEUSES (LENTILLES, POIS CHICHES), OEUFS, TOFU, PRODUITS LAITIERS (FROMAGE BLANC, YAOURT GREC) ET WHEY PROTEIN. EVITEZ DE PROPOSER LA MEME SOURCE DE PROTEINES DE SUITE OU TROP FREQUEMMENT.");
            }

            mealSpecificConstraints.push("POUR OPTIMISER LES COURSES ET REDUIRE LE COUT, PRIVILEGIEZ L'UTILISATION D'INGREDIENTS COMMUNS DANS DIFFERENTES RECETTES AU COURS DE LA SEMAINE. PAR EXEMPLE, SI DES LENTILLES OU DU POULET SONT UTILISES UN JOUR, PROPOSEZ D'AUTRES RECETTES QUI PEUVENT UTILISER CES MEMES INGREDIENT DANS D'AUTRES RECETTES DE LA SEMAINE, AFIN DE MINIMISER LES DECHETS ET LES COUTS.");
            mealSpecificConstraints.push("POUR LES REPAS QUI SE REPETENT (SI LE CONTEXTE DE POSTE ET DE SPORT EST IDENTIQUE), ASSUREZ-VOUS QU'ILS NE SOIENT PAS SYSTEMATIQUEMENT LES MEMES. VARIEZ-LES LEGEREMENT OU PROPOSEZ DES ALTERNATIVES POUR EVITER LA MONOTONIE, TOUT EN MAINTENANT LA COHERENCE POUR LES ACHATS.");

            const sportImpact = dayContext.sport !== 'aucun' ? `Waeky a une seance de sport de type '${dayContext.sport}' prevue. Les glucides complexes et les proteines sont importants pour l'energie et la recuperation.` : `Waeky n'a pas de sport prevu pour cette journee. Les repas doivent rester equilibres.`;
            const posteImpact = `Waeky est sur un poste de type '${dayContext.poste}'. N'oubliez pas d'adapter la digestion et l'energie en fonction de cet horaire.`;

            const LLM_PROMPT = `Vous etes un nutritionniste expert et un chef cuisinier, travaillant pour 'FitQuest'. Votre mission est de creer une recette detaillee et adaptee pour Waeky, un agent de securite avec un emploi du temps exigeant.

LE CONTEXTE DE WAEKY :
- IMC : ${userProfileForPrompt.imc} (Categorie : ${userProfileForPrompt.imcCategory})
- Poids : ${userProfileForPrompt.weight} kg
- Besoins en proteines estimes : ${userProfileForPrompt.proteinNeeds} g/jour
- Ce repas est pour ${finalNumberOfPeople} personne(s).

L'EMPLOI DU TEMPS DU JOUR :
- Poste : ${dayContext.poste}
- Sport : ${dayContext.sport} (${sportImpact})
- ${posteImpact}

TYPE DE REPAS A CREER : ${mealContextDescription.toUpperCase()}

CONTRAINTES SPECIFIQUES :
${mealSpecificConstraints.map(c => `- ${c}`).join('\n')}
- Toutes les informations (titre, description, ingredients, etapes de preparation, conseils, notes) doivent etre STRICTEMENT EN FRANCAIS.
- POUR LES REPAS PRINCIPAUX (DEJEUNER ET DINER) : Bien que la variete soit la priorite, si le contexte (type de poste et seance sportive) est identique a un jour precedent, vous pouvez proposer une recette similaire ou reutiliser des ingredients cles pour optimiser les courses, mais EFFORCEZ-VOUS DE RENDRE CHAQUE RECETTE UNIQUE OU AVEC UNE TOUCHE DIFFERENTE.
- POUR LES COLLATIONS : Proposez une TRES GRANDE VARIETE de collations (fruits, yaourts, shakes, galettes, etc.).
- POUR LES SALADES : Incluez des salades variees (salade verte, iceberg, salade de crudites, salade de pommes de terre, salade de riz, salade de pates, etc.) comme repas complet ou accompagnement.
- POUR LES RECETTES A BASE DE POMMES DE TERRE OU DE PAIN : Integrez des recettes comme des galettes de pommes de terre, des toasts proteines, ou des sandwichs equilibres si cela correspond au type de repas.

**GUIDELINES POUR LES QUANTITES :**
- **Pour "ingredients_list" (pour ${finalNumberOfPeople} personne(s)) :**
    - Les quantites doivent etre pour les ingredients BRUTS/SECS avant cuisson (sauf indication contraire explicite comme "cuites" pour les lentilles si c'est le cas).
    - Pour les glucides complexes (riz, pates, quinoa, flocons d'avoine, legumineuses comme lentilles, pois chiches) : Visez environ 60-80g (poids sec) par personne pour un repas principal. Multipliez cette quantite par ${finalNumberOfPeople}.
    - Pour les proteines (viande, poisson, tofu) : Visez environ 120-150g (poids cru) par personne pour un repas principal. Multipliez cette quantite par ${finalNumberOfPeople}.
    - Pour les oeufs : Visez 2-3 oeufs par personne. Multipliez par ${finalNumberOfPeople}.
    - Pour les legumes : Indiquez des quantites genereuses, par exemple 150-250g (poids brut) par personne, ou des unites comme "1 grand poivron", "2 carottes". Multipliez par ${finalNumberOfPeople}.
    - Pour les huiles/matieres grasses : Utilisez des quantites moderees (ex: 5-10ml par personne).
- **Pour "ma_portion_waeky" (pour 1 personne - Waeky) :**
    - Cette description doit etre specifiquement calculee pour Waeky (1 personne) en tenant compte de son IMC (${userProfileForPrompt.imcCategory}) et de ses besoins en proteines (${userProfileForPrompt.proteinNeeds} g/jour).
    - **NE DONNEZ PAS UN POIDS TOTAL POUR LE PLAT ENTIER (EX: "500G DE CURRY").**
    - La portion de proteines pour Waeky devrait viser environ 40-50g de proteines nettes par repas principal (ou l'equivalent pour les collations/petit-dejeuner).
    - La portion de glucides complexes pour Waeky devrait etre l'equivalent de 50-80g de poids sec (ou l'equivalent cuit, ex: 150-250g de riz cuit) pour un repas principal, ajustee selon l'activite sportive du jour.
    - La portion de legumes doit etre genereuse et "a volonte" (ex: 200-300g de legumes varies).
    - La description doit inclure le type de proteines, de glucides, et la mention des legumes, ainsi qu'une estimation du poids de CHAQUE COMPOSANT (proteines, glucides, legumes) si pertinent, et l'apport proteique estime.
    - Exemple de format pour "ma_portion_waeky": "VOTRE PORTION (POUR WAEKY) : UNE PORTION DE [TYPE DE PROTEINE] (ENVIRON [X]G CUIT), [X]G DE [TYPE DE GLUCIDE] CUIT, ET UNE GRANDE PORTION DE LEGUMES (ENVIRON [Y]G). CETTE PORTION DEVRAIT FOURNIR ENVIRON [Z]G DE PROTEINES."

FORMAT DE REPONSE ATTENDU (STRICTEMENT EN JSON) :
{
    "title": "TITRE DE LA RECETTE (EN MAJUSCULES)",
    "description_du_plat": "DESCRIPTION DU PLAT ADAPTEE AU CONTEXTE (EN MAJUSCULES)",
    "ingredients_label": "INGREDIENTS (POUR X PERSONNES)",
    "ingredients_list": ["QUANTITE UNITE INGREDIENT", "QUANTITE UNITE INGREDIENT", ...],
    "preparation_steps": ["ETAPE 1. DESCRIPTION DETAILLEE.", "ETAPE 2. DESCRIPTION DETAILLEE.", ...],
    "ma_portion_waeky": "VOTRE PORTION (POUR WAEKY) : QUANTITE DE PROTEINES, QUANTITE DE GLUCIDES, ET UNE GRANDE PORTION DE LEGUMES/FRUITS VARIES, POUR 1 PERSONNE.",
    "conseils_reutilisation_economie": "CONSEILS POUR LES RESTES OU LES ECONOMIES (EN MAJUSCULES).",
    "notes": "NOTES SUPPLEMENTAIRES (ALLERGENES, CONSEILS, ETC.) (EN MAJUSCULES)."
}

GENERER LA RECETTE DETAILLEE : `.trim();

            try {
                const payload = { contents: [{ role: "user", parts: [{ text: LLM_PROMPT }] }], generationConfig: { responseMimeType: "application/json", responseSchema: { type: "OBJECT", properties: { "title": { "type": "STRING" }, "description_du_plat": { "type": "STRING" }, "ingredients_label": { "type": "STRING" }, "ingredients_list": { "type": "ARRAY", "items": { "type": "STRING" } }, "preparation_steps": { "type": "ARRAY", "items": { "type": "STRING" } }, "ma_portion_waeky": { "type": "STRING" }, "conseils_reutilisation_economie": { "type": "STRING" }, "notes": { "type": "STRING" } }, required: ["title", "description_du_plat", "ingredients_label", "ingredients_list", "preparation_steps", "ma_portion_waeky", "conseils_reutilisation_economie", "notes"] } } };
                const apiKey = userProfile.apiKey || "", apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
                const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });

                if (!response.ok) {
                    const errorText = await response.text();
                    let errorMessage = `ERREUR HTTP: ${response.status} ${response.statusText}`;
                    if (response.status === 401 || response.status === 403) errorMessage += " - PROBLEME D'AUTHENTIFICATION API. VERIFIEZ L'ACCES A L'API GEMINI. (CODE 401/403)";
                    else if (errorText) errorMessage += ` - ${errorText}`;
                    throw new Error(errorMessage);
                }

                const rawResult = await response.text();
                let parsedContent = null;
                try {
                    const result = JSON.parse(rawResult);
                    if (result.candidates && result.candidates.length > 0 && result.candidates[0].content && result.candidates[0].content.parts && result.candidates[0].content.parts.length > 0) {
                        parsedContent = JSON.parse(result.candidates[0].content.parts[0].text);
                    } else {
                        throw new Error("Reponse de l'IA mal formee ou vide.");
                    }
                } catch (parseError) {
                    console.error("Erreur lors de l'analyse du JSON de la reponse LLM ou de la structure des candidats:", parseError);
                    console.error("JSON brut causant l'erreur:", rawResult);
                    const fallbackTitle = `${mealContextDescription.toUpperCase()} SIMPLIFIE (ERREUR IA)`,
                        fallbackDesc = `UNE ERREUR S'EST PRODUITE LORS DE LA GENERATION. VOICI UNE RECETTE DE BASE.`,
                        fallbackIngredients = [`QUANTITES A DEFINIR SELON VOTRE APPETIT`, `PROTEINES VARIEES`, `GLUCIDES COMPLEXES`, `LEGUMES DE SAISON`],
                        fallbackPreparation = ["1. PREPAREZ LES INGREDIENTS. 2. CUISEZ SELON VOS METHODES HABITUELLES."],
                        fallbackPortion = "VOTRE PORTION (POUR WAEKY) : PROTEINES, GLUCIDES ET LEGUMES/FRUITS VARIES ADAPTES. POUR 1 PERSONNE.",
                        fallbackConseils = "AJUSTEZ LES QUANTITES SELON VOS BESOINS. ESSAYEZ DE REUTILISER LES RESTES.",
                        fallbackNotes = "LA RECETTE A ETE SIMPLIFIEE EN RAISON D'UN PROBLEME DE COMMUNICATION AVEC L'IA. VERIFIEZ LE PROMPT OU L'API.";
                    parsedContent = { title: fallbackTitle, description_du_plat: fallbackDesc, ingredients_label: `INGREDIENTS (POUR ${finalNumberOfPeople} PERS)`, ingredients_list: fallbackIngredients, preparation_steps: fallbackPreparation, ma_portion_waeky: fallbackPortion, conseils_reutilisation_economie: fallbackConseils, notes: fallbackNotes };
                }
                // Enrichir le repas genere avec le type de repas et le contexte du jour pour le stockage dans likedMeals
                return {
                    id: generateUniqueId(),
                    title: String(parsedContent.title || '').toUpperCase(),
                    description_du_plat: String(parsedContent.description_du_plat || '').toUpperCase(),
                    ingredients_label: String(parsedContent.ingredients_label || `INGREDIENTS (POUR ${finalNumberOfPeople} PERS)`).toUpperCase(),
                    ingredients_list: (parsedContent.ingredients_list || []).map(item => String(item).toUpperCase()),
                    preparation_steps: (parsedContent.preparation_steps || []).map(step => String(step).toUpperCase()),
                    ma_portion_waeky: String(parsedContent.ma_portion_waeky || '').toUpperCase(),
                    conseils_reutilisation_economie: String(parsedContent.conseils_reutilisation_economie || '').toUpperCase(),
                    notes: String(parsedContent.notes || '').toUpperCase(),
                    mealType: mealType, // Ajout du type de repas
                    dayContext: dayContext // Ajout du contexte du jour
                };
            } catch (error) {
                console.error("Erreur fatale lors de l'appel LLM ou de l'analyse JSON generale:", error);
                const fallbackTitle = `${mealContextDescription.toUpperCase()} (ERREUR SYSTEME)`,
                    fallbackDesc = `UNE ERREUR CRITIQUE S'EST PRODUITE. VEUILLEZ REESSAYER.`,
                    fallbackIngredients = [`VERIFIEZ VOTRE CONNEXION INTERNET`, `CONTACTEZ LE SUPPORT SI LE PROBLEME PERSISTE`],
                    fallbackPreparation = ["1. ESSAYEZ DE RE-GENERER LE PLAN.", "2. ASSUREZ-VOUS QUE VOTRE PROFIL EST COMPLET."],
                    fallbackPortion = "INDISPONIBLE EN RAISON D'UNE ERREUR.",
                    fallbackConseils = "AUCUN CONSEIL DISPONIBLE.",
                    fallbackNotes = "ERREUR DE COMMUNICATION MAJEURE AVEC L'IA. VEUILLEZ VERIFIER VOTRE CONNEXION.";
                return {
                    id: generateUniqueId(),
                    title: fallbackTitle,
                    description_du_plat: fallbackDesc,
                    ingredients_label: `INGREDIENTS (POUR ${finalNumberOfPeople} PERS)`,
                    ingredients_list: fallbackIngredients,
                    preparation_steps: fallbackPreparation,
                    ma_portion_waeky: fallbackPortion,
                    conseils_reutilisation_economie: fallbackConseils,
                    notes: fallbackNotes,
                    mealType: mealType,
                    dayContext: dayContext
                };
            }
        }

        // Rend la vue des recettes et gere la generation du plan de repas
        function renderRecipeView(container) {
            let numPeople = loadFromLocalStorage('recipeNumPeople', 1), allowMeatFish = loadFromLocalStorage('recipeAllowMeatFish', true); // regeneratingMeal est maintenant global
            let html = `<div class="card-retro mb-6"><h2 class="text-3xl sm:text-4xl font-bold text-yellow-300 mb-4 text-center">PLAN DE REPAS</h2><div class="p-4 rounded-lg border-2 border-blue-700 bg-gray-700 mb-6"><h3 class="text-xl sm:text-2xl text-yellow-300 mb-3">GENERER MON PLAN DE REPAS :</h3><div class="mb-4"><label for="numPeople" class="block text-gray-200 text-sm font-bold mb-2">POUR COMBIEN DE PERSONNES ?</label><input type="number" id="numPeople" value="${numPeople}" min="1" class="input-retro" /></div><div class="mb-4 flex items-center"><input type="checkbox" id="allowMeatFish" ${allowMeatFish ? 'checked' : ''} class="mr-2 h-4 w-4 text-purple-600 rounded border-gray-300 focus:ring-purple-500" /><label for="allowMeatFish" class="text-gray-200 text-sm font-bold">AUTORISER VIANDE ET POISSON (PLUS ECONOMIQUE SANS)</label></div><button id="generate-plan-btn" class="btn-retro-purple w-full flex items-center justify-center"><span id="generate-plan-spinner" class="spinner mr-2 ${regeneratingMeal && !regeneratingMeal.mealType ? '' : 'hidden'}"></span><span id="generate-plan-text">${regeneratingMeal && !regeneratingMeal.mealType ? 'GENERATION...' : 'GENERER PLAN DE REPAS'}</span></button><p class="text-xs text-gray-400 mt-2 text-center">LE PLAN SERA GENERE UNIQUEMENT POUR LES JOURS AVEC DES POSTES ENREGISTRES DANS L'ONGLET "PLANNING".</p></div><div id="weekly-meal-plan-content"></div></div>`;
            container.innerHTML = html;
            const numPeopleInput = document.getElementById('numPeople'), allowMeatFishCheckbox = document.getElementById('allowMeatFish'), generatePlanBtn = document.getElementById('generate-plan-btn'), generatePlanSpinner = document.getElementById('generate-plan-spinner'), generatePlanText = document.getElementById('generate-plan-text'), weeklyMealPlanContentDiv = document.getElementById('weekly-meal-plan-content');

            numPeople = loadFromLocalStorage('recipeNumPeople', 1);
            allowMeatFish = loadFromLocalStorage('recipeAllowMeatFish', true);
            numPeopleInput.value = numPeople;
            allowMeatFishCheckbox.checked = allowMeatFish;

            numPeopleInput.onchange = (e) => { numPeople = Math.max(1, parseInt(e.target.value) || 1); saveToLocalStorage('recipeNumPeople', numPeople); };
            allowMeatFishCheckbox.onchange = (e) => { allowMeatFish = e.target.checked; saveToLocalStorage('recipeAllowMeatFish', allowMeatFish); };

            // Set initial state of generate button based on global regeneratingMeal
            if (regeneratingMeal && !regeneratingMeal.mealType) { // If it's a full plan generation
                generatePlanBtn.disabled = true;
            } else {
                generatePlanBtn.disabled = false;
            }

            generatePlanBtn.onclick = async () => {
                regeneratingMeal = { dateKey: null, mealType: null }; // Indicate full plan generation
                renderRecipeView(container); // Re-render to show spinner on main button

                generatePlanBtn.disabled = true;
                generatePlanSpinner.classList.remove('hidden');
                generatePlanText.textContent = 'GENERATION...';
                showMessage("GENERATION DU PLAN DE REPAS EN COURS... CELA PEUT PRENDRE QUELQUES INSTANTS.", 'info');

                try {
                    if (!userProfile.height || !userProfile.weight) { showMessage("ERREUR: VEUILLEZ REMPLIR VOTRE TAILLE ET VOTRE POIDS DANS LE PROFIL POUR GENERER DES RECETTES PRECISES.", 'error'); return; }

                    const today = new Date();
                    today.setHours(0, 0, 0, 0);
                    const fetchedShifts = (loadFromLocalStorage('shifts', []) || []).filter(s => new Date(s.date).getTime() >= today.getTime());

                    if (fetchedShifts.length === 0) { showMessage("AUCUN POSTE ENREGISTRE POUR LES JOURS A VENIR. VEUILLEZ AJOUTER DES POSTES DANS L'ONGLET 'PLANNING' POUR GENERER UN PLAN DE REPAS.", 'warning'); return; }

                    const newMealPlan = { semaine: [] };
                    const userProfileData = { height: parseFloat(userProfile.height), weight: parseFloat(userProfile.weight), imc: userProfile.imc, imcCategory: userProfile.imcCategory, proteinNeeds: userProfile.proteinNeeds };

                    // Reinitialiser le cache global pour une nouvelle generation de plan
                    contextualMealCache = new Map();

                    for (const shift of fetchedShifts) {
                        const day = new Date(shift.date), dateKey = formatDateToYYYYMMDD(day), dayContext = { poste: shift.type, sport: shift.workoutType };
                        const mealsForDay = { date: dateKey, dayContext: dayContext }; // Initialize with date and context
                        const mealOrder = ['petit_dejeuner', 'collation_matin', 'dejeuner', 'collation_apresmidi', 'diner', 'collation_unique'];

                        for (const mealType of mealOrder) {
                            let addMeal = true;
                            // Logique pour determiner si un repas/collation doit etre ajoute pour le contexte donne
                            if (mealType === 'collation_matin') {
                                if (dayContext.poste === '18h-6h' || (dayContext.poste === 'repos' && dayContext.sport === 'aucun')) { addMeal = false; }
                            } else if (mealType === 'collation_apresmidi') {
                                if (dayContext.poste === '18h-6h' || (dayContext.poste === 'repos' && dayContext.sport === 'aucun')) { addMeal = false; }
                            } else if (mealType === 'collation_unique') {
                                if (dayContext.poste === '18h-6h') { addMeal = true; } else { addMeal = false; }
                            }
                            if (!addMeal) continue;

                            // For petit_dejeuner and collation types, try to use a cached meal or generate and cache
                            if (mealType === 'petit_dejeuner' || mealType.startsWith('collation')) {
                                const contextKey = getMealContextKey(mealType, dayContext); // Use simplified key (only poste)
                                if (contextualMealCache.has(contextKey)) {
                                    mealsForDay[mealType] = contextualMealCache.get(contextKey);
                                    console.log(`[GENERATION REPAS] Utilisation d'un repas en cache pour le contexte: ${contextKey}`);
                                } else {
                                    const generatedMeal = await generateInternalMeal(mealType, dayContext, Object.values(mealsForDay), null, allowMeatFish, userProfileData, numPeople);
                                    contextualMealCache.set(contextKey, generatedMeal);
                                    mealsForDay[mealType] = generatedMeal;
                                    console.log(`[GENERATION REPAS] Nouveau repas genere et mis en cache pour le contexte: ${contextKey}`);
                                }
                            } else {
                                // For main meals (dejeuner, diner), always generate a new one
                                mealsForDay[mealType] = await generateInternalMeal(mealType, dayContext, Object.values(mealsForDay), null, allowMeatFish, userProfileData, numPeople);
                                console.log(`[GENERATION REPAS] Nouveau repas principal genere pour le contexte: ${mealType}, ${dayContext.poste}, ${dayContext.sport}`);
                            }
                        }
                        newMealPlan.semaine.push(mealsForDay);
                    }
                    newMealPlan.semaine.sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());
                    weeklyMealPlan = newMealPlan;
                    saveToLocalStorage('weeklyMealPlan', weeklyMealPlan);
                    showMessage("SUCCES: PLAN DE REPAS GENERE ET ENREGISTRE !", 'success');
                    speak("Plan de repas genere !");
                    renderRecipeView(container); // Re-render pour afficher le nouveau plan
                } catch (error) {
                    console.error("Erreur lors de la generation du plan de repas:", error);
                    showMessage(`ERREUR: Echec de la generation du plan. ${error.message}`, 'error');
                } finally {
                    regeneratingMeal = null; // Reset global regeneratingMeal status
                    generatePlanBtn.disabled = false;
                    generatePlanSpinner.classList.add('hidden');
                    generatePlanText.textContent = 'GENERER PLAN DE REPAS';
                }
            };

            // Rend le plan de repas hebdomadaire
            function renderWeeklyMealPlan() {
                if (!weeklyMealPlan || !weeklyMealPlan.semaine || weeklyMealPlan.semaine.length === 0) { weeklyMealPlanContentDiv.innerHTML = `<p class="text-gray-400 text-center">AUCUN PLAN DE REPAS GENERE. CLIQUEZ SUR "GENERER PLAN DE REPAS" CI-DESSUS.</p>`; return; }

                let mealsHtml = `<div class="space-y-6"><h3 class="text-xl sm:text-2xl text-yellow-300 mb-3 text-center">TON PLAN DE REPAS :</h3>`;
                weeklyMealPlan.semaine.forEach((dayData) => {
                    // Only render if the dayData is not null (i.e., not explicitly deleted)
                    if (dayData) {
                        mealsHtml += `<div class="bg-gray-700 p-4 rounded-lg border-4 border-purple-500 shadow-lg"><div class="flex justify-between items-center cursor-pointer py-2" data-toggle="day-content-${dayData.date}"><h4 class="text-lg sm:text-xl font-bold text-yellow-300">${new Date(dayData.date).toLocaleDateString('fr-FR', { weekday: 'long', day: 'numeric', month: 'long' }).toUpperCase()} - ${getDayContextString(dayData.dayContext.poste, dayData.dayContext.sport)}</h4><i data-lucide="chevron-down" class="text-yellow-300 transition-transform duration-300"></i></div><div id="day-content-${dayData.date}" class="overflow-hidden transition-all duration-500 ease-in-out max-h-0"><div class="space-y-4 pt-2">`;

                        const mealOrder = ['petit_dejeuner', 'collation_matin', 'dejeuner', 'collation_apresmidi', 'diner', 'collation_unique'];
                        mealOrder.forEach(mealType => {
                            const meal = dayData[mealType];
                            if (meal) {
                                const momentContext = getMealMomentContext(mealType, dayData.dayContext.poste, dayData.dayContext.sport);
                                const adviceKey = mealType.includes('collation') ? `${mealType.replace('_unique', '')}_${dayData.dayContext.poste === '18h-6h' ? 'pendant' : (dayData.dayContext.sport !== 'aucun' ? 'post' : 'default')}` : dayData.dayContext.poste === '18h-6h' ? '18h-6h' : (dayData.dayContext.sport !== 'aucun' ? 'repos_sport' : 'default');
                                const advice = specificMealAdvice[mealType]?.[adviceKey] || specificMealAdvice[mealType]?.default || "CONSEIL GENERAL : MANGEZ EQUILIBRE.";
                                const isRegeneratingCurrentMeal = regeneratingMeal && regeneratingMeal.dateKey === dayData.date && regeneratingMeal.mealType === mealType;
                                // Check if the current meal object's ID is in the likedMeals array
                                const isLiked = userProfile.likedMeals.some(likedMeal => likedMeal.id === meal.id);

                                mealsHtml += `<div class="bg-gray-800 p-3 rounded-md border-2 border-blue-700 shadow-md">
                                    <div class="flex justify-between items-center cursor-pointer py-2" data-toggle="meal-content-${meal.id}">
                                        <h5 class="font-semibold text-base sm:text-lg text-blue-400">${momentContext} : ${String(meal.title || 'RECETTE NON DEFINIE').toUpperCase()}</h5>
                                        <div class="flex items-center">
                                            <button class="btn-retro-red text-sm px-2 py-1 ml-2 flex items-center justify-center regenerate-meal-btn" data-date="${dayData.date}" data-meal-type="${mealType}" ${isRegeneratingCurrentMeal ? 'disabled' : ''}>
                                                ${isRegeneratingCurrentMeal ? `<span class="spinner w-4 h-4"></span>` : `<i data-lucide="rotate-ccw" style="width:16px; height:16px;"></i>`}
                                                <span class="ml-1 hidden sm:inline">REGENERER</span>
                                            </button>
                                            <button class="text-white ml-2 like-meal-btn" data-meal-id="${meal.id}" data-date="${dayData.date}" data-meal-type="${mealType}" style="color:${isLiked ? '#FCD34D' : 'white'};">
                                                <i data-lucide="${isLiked ? 'heart' : 'heart'}" class="${isLiked ? 'fill-current text-yellow-400' : ''}" style="width:20px; height:20px;"></i>
                                            </button>
                                        </div>
                                    </div>
                                    <div id="meal-content-${meal.id}" class="overflow-hidden transition-all duration-500 ease-in-out max-h-0">
                                        <p class="text-gray-300 text-sm italic mb-2">${String(meal.description_du_plat || 'DESCRIPTION INDISPONIBLE').toUpperCase()}</p>
                                        <p class="text-sm font-medium text-yellow-300">${String(meal.ingredients_label || 'INGREDIENTS').toUpperCase()} :</p>
                                        <ul class="list-disc list-inside text-gray-300 text-xs pl-2 space-y-1">${(meal.ingredients_list || []).map(ingredient => `<li>${String(ingredient).toUpperCase()}</li>`).join('')}</ul>
                                        <p class="text-sm font-medium text-yellow-300 mt-2">PREPARATION :</p>
                                        <ol class="list-decimal list-inside text-gray-300 text-xs pl-2 space-y-1">${(meal.preparation_steps || []).map(step => `<li>${String(step).toUpperCase()}</li>`).join('')}</ol>
                                        <p class="text-sm font-medium text-yellow-300 mt-2">PORTION WAEKY :</p>
                                        <p class="text-gray-300 text-xs">${String(meal.ma_portion_waeky || 'PORTION INDISPONIBLE').toUpperCase()}</p>
                                        <p class="text-sm font-medium text-yellow-300 mt-2">CONSEILS ECONOMIE :</p>
                                        <p class="text-gray-300 text-xs">${String(meal.conseils_reutilisation_economie || 'CONSEILS INDISPONIBLES').toUpperCase()}</p>
                                        <p class="text-blue-200 text-xs mt-3">${advice}</p>
                                    </div>
                                </div>`;
                            }
                        });
                        mealsHtml += `</div></div></div>`;
                    }
                });
                mealsHtml += `</div>`;
                weeklyMealPlanContentDiv.innerHTML = mealsHtml;
                renderLucideIcons();
                attachCollapsibleListeners();

                // Attache les ecouteurs d'evenements pour les boutons de regeneration de repas
                weeklyMealPlanContentDiv.querySelectorAll('.regenerate-meal-btn').forEach(button => {
                    button.onclick = async (event) => {
                        const dateKey = event.currentTarget.dataset.date;
                        const mealType = event.currentTarget.dataset.mealType;
                        const dayDataForRegen = weeklyMealPlan.semaine.find(d => d.date === dateKey);

                        if (!dayDataForRegen || !dayDataForRegen.dayContext) {
                            showMessage("ERREUR: Contexte de jour non trouve pour la regeneration du repas.", 'error');
                            return;
                        }
                        const dayContext = dayDataForRegen.dayContext;

                        regeneratingMeal = { dateKey, mealType };
                        renderRecipeView(container); // Re-render pour afficher l'etat de chargement

                        try {
                            const userProfileData = { height: parseFloat(userProfile.height), weight: parseFloat(userProfile.weight), imc: userProfile.imc, imcCategory: userProfile.imcCategory, proteinNeeds: userProfile.proteinNeeds };
                            // Always generate a new meal when the specific regenerate button is clicked
                            const regeneratedMeal = await generateInternalMeal(mealType, dayContext, [], null, allowMeatFish, userProfileData, numPeople);

                            // If it's a breakfast or snack, update the cache and propagate the change
                            if (mealType === 'petit_dejeuner' || mealType.startsWith('collation')) {
                                const contextKey = getMealContextKey(mealType, dayContext);
                                contextualMealCache.set(contextKey, regeneratedMeal); // Update the global cache
                                weeklyMealPlan.semaine.forEach(dayInPlan => {
                                    // Propagate to all days with the same POSTE type for this meal type
                                    if (dayInPlan.dayContext.poste === dayContext.poste && dayInPlan[mealType]) {
                                        dayInPlan[mealType] = regeneratedMeal; // Update the meal object reference
                                    }
                                });
                                console.log(`[GENERATION REPAS] Cache mis a jour et repas propage pour le contexte: ${contextKey}`);
                            } else {
                                // For main meals (dejeuner, diner), only update the specific meal
                                const dayIndex = weeklyMealPlan.semaine.findIndex(d => d.date === dateKey);
                                if (dayIndex !== -1) {
                                    regeneratedMeal.mealType = mealType;
                                    regeneratedMeal.dayContext = dayContext;
                                    weeklyMealPlan.semaine[dayIndex][mealType] = regeneratedMeal;
                                }
                            }

                            saveToLocalStorage('weeklyMealPlan', weeklyMealPlan);
                            showMessage(`SUCCES: Repas "${regeneratedMeal.title}" regenere pour le ${dateKey} !`, 'success');
                            speak("Repas regenere !");
                        } catch (error) {
                            console.error("Erreur lors de la regeneration du repas:", error);
                            showMessage(`ERREUR: Echec de la regeneration du repas. ${error.message}`, 'error');
                        } finally {
                            regeneratingMeal = null;
                            renderRecipeView(container); // Re-render pour masquer l'etat de chargement et afficher le repas mis a jour
                        }
                    };
                });

                // Attache les ecouteurs d'evenements pour les boutons "J'aime"
                weeklyMealPlanContentDiv.querySelectorAll('.like-meal-btn').forEach(button => {
                    button.onclick = (event) => {
                        const mealId = event.currentTarget.dataset.mealId;
                        const dateKey = event.currentTarget.dataset.date;
                        const mealType = event.currentTarget.dataset.mealType;

                        // Find the full meal object from the weekly plan
                        const dayData = weeklyMealPlan.semaine.find(d => d.date === dateKey);
                        if (dayData && dayData[mealType] && dayData[mealType].id === mealId) {
                            toggleLikeMeal(dayData[mealType]); // Passe l'objet repas complet
                        } else {
                            console.warn("Repas introuvable dans le plan hebdomadaire pour aimer/ne plus aimer.");
                        }
                    };
                });
            }
            renderWeeklyMealPlan(); // Rend le plan de repas au chargement de la vue
        }

        // Attache les ecouteurs d'evenements pour les elements "collapsible" (qui s'ouvrent/se ferment)
        function attachCollapsibleListeners() {
            document.querySelectorAll('[data-toggle]').forEach(toggleElement => {
                toggleElement.onclick = () => {
                    const targetId = toggleElement.dataset.toggle, targetContent = document.getElementById(targetId), icon = toggleElement.querySelector('i[data-lucide]');
                    if (targetContent) {
                        if (targetContent.classList.contains('max-h-0')) {
                            targetContent.classList.remove('max-h-0');
                            targetContent.style.maxHeight = targetContent.scrollHeight + 'px'; // Definit la hauteur reelle pour l'animation
                            if (icon) icon.classList.add('rotate-180');
                            targetContent.classList.add('open');
                        }
                        else {
                            targetContent.style.maxHeight = targetContent.scrollHeight + 'px'; // Definit la hauteur avant de la reduire
                            requestAnimationFrame(() => {
                                targetContent.classList.add('max-h-0');
                                targetContent.style.maxHeight = '0'; // Reduit la hauteur a 0
                            });
                            if (icon) icon.classList.remove('rotate-180');
                            targetContent.classList.remove('open');
                        }
                    }
                };
            });
        }

        // Rend la vue du chronometre d'intervalles
        function renderChronoIntervalleView(container) {
            let html = `<div class="card-retro mb-6"><h2 class="text-3xl sm:text-4xl font-bold text-yellow-300 mb-4 text-center">CHRONOMETRE D'INTERVALLES</h2><div class="text-center mb-6 p-4 rounded-lg border-2 border-blue-700 bg-gray-700"><p class="text-2xl sm:text-3xl text-yellow-300 mb-2">INTERVALLE ACTUEL :</p><p id="chrono-instruction" class="text-3xl sm:text-4xl font-bold text-white mb-4"></p><div id="chrono-display" class="text-6xl sm:text-7xl font-bold text-purple-400 bg-[#131313] p-4 rounded-lg border-4 border-purple-600 inline-block shadow-inner-lg">00:00</div><div class="flex justify-center gap-4 mt-6 flex-wrap"><button id="start-chrono-btn" class="btn-retro-green px-6 py-3">DEMARRER</button><button id="pause-chrono-btn" class="btn-retro-purple px-6 py-3">PAUSE</button><button id="reset-chrono-btn" class="btn-retro-red px-6 py-3">REINITIALISER</button></div></div><div class="mb-6 space-y-4 p-4 rounded-lg border-2 border-blue-700 bg-gray-700"><h3 class="text-xl sm:text-2xl text-yellow-300 mb-3">GESTION DES INTERVALLES :</h3><div class="flex flex-col sm:flex-row gap-3 items-end"><div class="flex-1 w-full"><label for="newDurationMinutes" class="block text-gray-200 text-sm font-bold mb-1">DUREE (MINUTES) :</label><input type="number" id="newDurationMinutes" value="" class="input-retro" placeholder="EX: 1" /></div><div class="flex-1 w-full"><label for="newInstruction" class="block text-gray-200 text-sm font-bold mb-1">INSTRUCTION :</label><input type="text" id="newInstruction" value="" class="input-retro" placeholder="EX: VITESSE 8, PENTE 2" /></div><button id="add-update-interval-btn" class="btn-retro w-full sm:w-auto px-5 py-2">AJOUTER</button></div><div class="mt-4 p-3 rounded-lg border-2 border-purple-500 bg-gray-800"><h4 class="text-lg sm:text-xl font-bold text-yellow-300 mb-2">OPTIONS DE DEPART :</h4><div class="flex items-center mb-2"><input type="checkbox" id="enablePreCountdown" ${enableChronoPreCountdown ? 'checked' : ''} class="mr-2 h-4 w-4 text-purple-600 rounded border-gray-300 focus:ring-purple-500" /><label for="enablePreCountdown" class="text-gray-200 text-sm font-bold">ACTIVER COMPTE A REBOURS DE PRE-DEPART</label></div><div id="pre-countdown-duration-setting" ${!enableChronoPreCountdown ? 'class="hidden"' : ''}><label for="chronoPreCountdownDuration" class="block text-gray-200 text-sm font-bold mb-1">DUREE PRE-DEPART (SECONDES) :</label><input type="number" id="chronoPreCountdownDuration" value="${chronoPreCountdownDuration}" min="1" class="input-retro w-full sm:w-1/2" /></div></div><div id="intervals-list" class="mt-4 p-3 rounded-lg border-2 border-purple-500 bg-gray-800"></div></div><div class="mb-6 space-y-4 p-4 rounded-lg border-2 border-blue-700 bg-gray-700"><h3 class="text-xl sm:text-2xl text-yellow-300 mb-3">SAUVEGARDER ET CHARGER :</h3><div class="flex flex-col sm:flex-row gap-3 items-end"><div class="flex-1 w-full"><label for="sequenceName" class="block text-gray-200 text-sm font-bold mb-1">NOM DE LA SEQUENCE :</label><input type="text" id="sequenceName" value="" class="input-retro" placeholder="EX: HIIT DU MATIN" /></div><button id="save-sequence-btn" class="btn-retro w-full sm:w-auto px-5 py-2">SAUVEGARDER</button><button id="load-sequence-btn" class="btn-retro-green w-full sm:w-auto px-5 py-2">CHARGER</button></div></div></div>`;
            container.innerHTML = html;
            const chronoDisplay = document.getElementById('chrono-display'), chronoInstruction = document.getElementById('chrono-instruction'), startChronoBtn = document.getElementById('start-chrono-btn'), pauseChronoBtn = document.getElementById('pause-chrono-btn'), resetChronoBtn = document.getElementById('reset-chrono-btn'), newDurationMinutesInput = document.getElementById('newDurationMinutes'), newInstructionInput = document.getElementById('newInstruction'), addUpdateIntervalBtn = document.getElementById('add-update-interval-btn'), intervalsListDiv = document.getElementById('intervals-list'), enablePreCountdownCheckbox = document.getElementById('enablePreCountdown'), preCountdownDurationSetting = document.getElementById('pre-countdown-duration-setting'), chronoPreCountdownDurationInput = document.getElementById('chronoPreCountdownDuration'), saveSequenceBtn = document.getElementById('save-sequence-btn'), loadSequenceBtn = document.getElementById('load-sequence-btn');

            chronoPreCountdownDurationInput.value = chronoPreCountdownDuration;

            // Rend la liste des intervalles du chronometre
            function renderIntervalsList() {
                intervalsListDiv.innerHTML = '';
                if (chronoIntervals.length === 0) { intervalsListDiv.innerHTML = '<p class="text-gray-400">AUCUNE INTERVALLE AJOUTEE.</p>'; return; }
                let listHtml = `<h4 class="text-lg sm:text-xl font-bold text-yellow-300 mb-2">SEQUENCE ACTUELLE :</h4><ul class="space-y-2">`;
                chronoIntervals.forEach((interval, index) => {
                    listHtml += `<li class="flex flex-col sm:flex-row justify-between items-start sm:items-center bg-[#131313] p-2 rounded-md border border-gray-700">
                        <span class="text-gray-100 text-base sm:text-lg">${Math.floor(interval.duration / 60)}MIN${interval.duration % 60 > 0 ? ` ${interval.duration % 60}S` : ''} - ${String(interval.instruction).toUpperCase()}</span>
                        <div class="flex gap-2 mt-2 sm:mt-0">
                            <button class="btn-retro-green text-xs px-2 py-1 duplicate-interval-btn" data-index="${index}">DUPLIQUER</button>
                            <button class="btn-retro-purple text-xs px-2 py-1 edit-interval-btn" data-index="${index}">MODIFIER</button>
                            <button class="btn-retro-red text-xs px-2 py-1 remove-interval-btn" data-index="${index}">SUPPRIMER</button>
                        </div>
                    </li>`;
                });
                listHtml += `</ul>`;
                intervalsListDiv.innerHTML = listHtml;

                // Attache les ecouteurs d'evenements pour les boutons de suppression d'intervalle
                intervalsListDiv.querySelectorAll('.remove-interval-btn').forEach(button => {
                    button.onclick = async (event) => {
                        const indexToRemove = parseInt(event.target.dataset.index);
                        if (await showConfirmModal("CONFIRMER LA SUPPRESSION DE L'INTERVALLE ?")) {
                            chronoIntervals.splice(indexToRemove, 1);
                            updateLocalStorageChronoState();
                            showMessage("INTERVALLE SUPPRIMEE !", 'success');
                            renderIntervalsList();
                            resetIntervalForm(); // Reset form after deletion
                        }
                    };
                });

                // Attache les ecouteurs d'evenements pour les boutons de duplication d'intervalle
                intervalsListDiv.querySelectorAll('.duplicate-interval-btn').forEach(button => {
                    button.onclick = async (event) => {
                        const indexToDuplicate = parseInt(event.target.dataset.index);
                        const originalInterval = chronoIntervals[indexToDuplicate];
                        if (originalInterval) {
                            chronoIntervals.push({ ...originalInterval }); // Add a copy
                            updateLocalStorageChronoState();
                            showMessage("INTERVALLE DUPLIQUEE !", 'success');
                            renderIntervalsList();
                        }
                    };
                });

                // Attache les ecouteurs d'evenements pour les boutons de modification d'intervalle
                intervalsListDiv.querySelectorAll('.edit-interval-btn').forEach(button => {
                    button.onclick = (event) => {
                        editingIntervalIndex = parseInt(event.target.dataset.index);
                        const intervalToEdit = chronoIntervals[editingIntervalIndex];
                        if (intervalToEdit) {
                            newDurationMinutesInput.value = Math.floor(intervalToEdit.duration / 60);
                            newInstructionInput.value = intervalToEdit.instruction;
                            addUpdateIntervalBtn.textContent = 'METTRE A JOUR';
                            addUpdateIntervalBtn.classList.remove('btn-retro');
                            addUpdateIntervalBtn.classList.add('btn-retro-purple');
                            showMessage(`MODIFICATION DE L'INTERVALLE ${editingIntervalIndex + 1}.`, 'info');
                        }
                    };
                });
            }

            // Reinitialise le formulaire d'ajout/modification d'intervalle
            function resetIntervalForm() {
                newDurationMinutesInput.value = '';
                newInstructionInput.value = '';
                addUpdateIntervalBtn.textContent = 'AJOUTER';
                addUpdateIntervalBtn.classList.remove('btn-retro-purple');
                addUpdateIntervalBtn.classList.add('btn-retro');
                editingIntervalIndex = -1; // Reset editing index
            }

            // Met a jour l'affichage du chronometre
            function updateChronoDisplay() {
                const displayTime = chronoCurrentIntervalIndex === -1 ? `PRET: ${String(chronoCurrentTime).padStart(2, '0')}` : `${String(Math.floor(chronoCurrentTime / 60)).padStart(2, '0')}:${String(chronoCurrentTime % 60).padStart(2, '0')}`;
                const currentInstruction = chronoCurrentIntervalIndex === -1 ? "COMPTE A REBOURS PRE-DEPART" : String(chronoIntervals[chronoCurrentIntervalIndex]?.instruction || "FIN DE SEQUENCE").toUpperCase();
                chronoDisplay.textContent = displayTime;
                chronoInstruction.textContent = currentInstruction;
                startChronoBtn.disabled = isChronoRunning && !isChronoPaused;
                pauseChronoBtn.disabled = !isChronoRunning || isChronoPaused;
                resetChronoBtn.disabled = !isChronoRunning && chronoCurrentIntervalIndex === -1 && chronoCurrentTime === 0;
            }

            // Boucle principale du chronometre
            function chronoLoop() {
                if (!isChronoRunning || isChronoPaused) { clearInterval(chronoIntervalTimerRef); chronoIntervalTimerRef = null; return; }
                chronoCurrentTime--;
                if (chronoCurrentIntervalIndex === -1) { // Phase de pre-compte a rebours
                    if (chronoCurrentTime <= 0) {
                        chronoCurrentIntervalIndex = 0;
                        chronoCurrentTime = chronoIntervals[0].duration;
                        speak(String(chronoIntervals[0].instruction).toUpperCase());
                        showMessage(String(chronoIntervals[0].instruction).toUpperCase(), 'chrono');
                    } else if (chronoCurrentTime <= 3 && chronoCurrentTime > 0) {
                        playMarioKartStartSound();
                    }
                } else { // Phase d'intervalles
                    if (chronoCurrentTime <= 0) {
                        const nextIndex = chronoCurrentIntervalIndex + 1;
                        if (nextIndex < chronoIntervals.length) {
                            chronoCurrentIntervalIndex = nextIndex;
                            chronoCurrentTime = chronoIntervals[nextIndex].duration;
                            speak(String(chronoIntervals[nextIndex].instruction).toUpperCase());
                            showMessage(String(chronoIntervals[nextIndex].instruction).toUpperCase(), 'chrono');
                            playBeep(1000, 0.2); // Son pour le changement d'intervalle
                        } else {
                            // Fin de la sequence
                            isChronoRunning = false;
                            isChronoPaused = false;
                            chronoCurrentIntervalIndex = -1;
                            chronoCurrentTime = 0;
                            speak("SEQUENCE TERMINEE!");
                            showMessage("SEQUENCE TERMINEE !", 'success');
                            clearInterval(chronoIntervalTimerRef);
                            chronoIntervalTimerRef = null;
                        }
                    } else if (chronoCurrentTime <= 10 && chronoCurrentTime > 0) {
                        playBeep(880, 0.05); // Bip d'avertissement avant la fin de l'intervalle
                    }
                }
                updateLocalStorageChronoState();
                updateChronoDisplay();
            }

            // Attache les ecouteurs d'evenements pour les boutons du chronometre
            addUpdateIntervalBtn.onclick = () => {
                const duration = newDurationMinutesInput.value, instruction = newInstructionInput.value;
                if (duration === '' || instruction.trim() === '') { showMessage("ERREUR: LA DUREE ET L'INSTRUCTION SONT REQUISES.", 'error'); return; }

                if (editingIntervalIndex !== -1) {
                    // Update existing interval
                    chronoIntervals[editingIntervalIndex] = { duration: parseInt(duration) * 60, instruction: instruction.trim() };
                    showMessage("INTERVALLE MISE A JOUR !", 'success');
                } else {
                    // Add new interval
                    chronoIntervals.push({ duration: parseInt(duration) * 60, instruction: instruction.trim() });
                    showMessage("INTERVALLE AJOUTEE !", 'success');
                }
                updateLocalStorageChronoState();
                renderIntervalsList();
                resetIntervalForm();
            };

            enablePreCountdownCheckbox.onchange = (e) => { enableChronoPreCountdown = e.target.checked; preCountdownDurationSetting.classList.toggle('hidden', !enableChronoPreCountdown); updateLocalStorageChronoState(); };
            chronoPreCountdownDurationInput.onchange = (e) => { chronoPreCountdownDuration = Math.max(1, parseInt(e.target.value) || 1); updateLocalStorageChronoState(); };
            startChronoBtn.onclick = () => { if (chronoIntervals.length === 0) { showMessage("ERREUR: AJOUTEZ DES INTERVALLES AVANT DE COMMENCER.", 'error'); return; } if (isChronoRunning && !isChronoPaused) return; isChronoRunning = true; isChronoPaused = false; chronoCurrentIntervalIndex = -1; if (enableChronoPreCountdown) chronoCurrentTime = chronoPreCountdownDuration; else { chronoCurrentIntervalIndex = 0; chronoCurrentTime = chronoIntervals[0].duration; speak(String(chronoIntervals[0].instruction).toUpperCase()); showMessage(String(chronoIntervals[0].instruction).toUpperCase(), 'chrono'); } updateLocalStorageChronoState(); updateChronoDisplay(); showMessage("CHRONO DEMARRE !", 'chrono'); if (!chronoIntervalTimerRef) chronoIntervalTimerRef = setInterval(chronoLoop, 1000); };
            pauseChronoBtn.onclick = () => { isChronoPaused = true; updateLocalStorageChronoState(); updateChronoDisplay(); showMessage("CHRONO EN PAUSE.", 'info'); clearInterval(chronoIntervalTimerRef); chronoIntervalTimerRef = null; };
            resetChronoBtn.onclick = () => { isChronoRunning = false; isChronoPaused = false; chronoCurrentIntervalIndex = -1; chronoCurrentTime = 0; updateLocalStorageChronoState(); updateChronoDisplay(); showMessage("CHRONO REINITIALISE.", 'success'); clearInterval(chronoIntervalTimerRef); chronoIntervalTimerRef = null; resetIntervalForm(); };

            // Gere la sauvegarde d'une sequence d'intervalles
            saveSequenceBtn.onclick = () => {
                const modalDiv = document.createElement('div');
                modalDiv.id = 'save-sequence-modal'; modalDiv.className = 'fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center p-4 z-50';
                modalDiv.innerHTML = `<div class="bg-gray-800 p-6 rounded-lg border-4 border-purple-500 shadow-xl w-full max-w-md text-white"><h3 class="text-xl sm:text-2xl font-bold mb-4 text-yellow-300">SAUVEGARDER LA SEQUENCE</h3><label for="saveSequenceName" class="block text-gray-200 text-sm font-bold mb-2">NOM :</label><input type="text" id="saveSequenceName" class="input-retro" placeholder="DONNEZ UN NOM A VOTRE SEQUENCE" value="${document.getElementById('sequenceName').value}" /><div class="flex justify-end space-x-4 mt-6"><button id="cancel-save-sequence-btn" class="btn-retro-red">ANNULER</button><button id="confirm-save-sequence-btn" class="btn-retro-green">SAUVEGARDER</button></div></div>`;
                document.getElementById('global-modals-container').appendChild(modalDiv);
                document.getElementById('cancel-save-sequence-btn').onclick = () => modalDiv.remove();
                document.getElementById('confirm-save-sequence-btn').onclick = () => { const name = document.getElementById('saveSequenceName').value; if (!name.trim()) { showMessage("ERREUR: NOM DE LA SEQUENCE REQUIS.", 'error'); return; } if (chronoIntervals.length === 0) { showMessage("ERREUR: AJOUTEZ DES INTERVALLES AVANT DE SAUVEGARDER.", 'error'); return; } intervalSequences.push({ id: generateUniqueId(), name: name.trim(), intervals: JSON.stringify(chronoIntervals) }); saveToLocalStorage('intervalSequences', intervalSequences); showMessage("SUCCES: SEQUENCE ENREGISTREE !", 'success'); modalDiv.remove(); document.getElementById('sequenceName').value = ''; };
            };

            // Gere le chargement d'une sequence d'intervalles
            loadSequenceBtn.onclick = () => {
                const modalDiv = document.createElement('div');
                modalDiv.id = 'load-sequence-modal'; modalDiv.className = 'fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center p-4 z-50';
                let sequencesListHtml = intervalSequences.length === 0 ? '<p class="text-gray-400">AUCUNE SEQUENCE ENREGISTREE.</p>' : `<ul class="space-y-2 max-h-60 overflow-y-auto pr-2">${intervalSequences.map(seq => `<li class="flex flex-col sm:flex-row justify-between items-start sm:items-center bg-gray-700 p-2 rounded-md border border-gray-600"><span class="text-gray-100 text-base sm:text-lg">${String(seq.name).toUpperCase()}</span><div class="flex gap-2 mt-2 sm:mt-0"><button class="btn-retro-green text-xs px-2 py-1 load-sequence-item-btn" data-id="${seq.id}">CHARGER</button><button class="btn-retro-purple text-xs px-2 py-1 edit-sequence-name-btn" data-id="${seq.id}">MODIFIER NOM</button><button class="btn-retro-green text-xs px-2 py-1 duplicate-sequence-item-btn" data-id="${seq.id}">DUPLIQUER</button><button class="btn-retro-red text-xs px-2 py-1 delete-sequence-item-btn" data-id="${seq.id}">SUPPRIMER</button></div></li>`).join('')}</ul>`;
                modalDiv.innerHTML = `<div class="bg-gray-800 p-6 rounded-lg border-4 border-purple-500 shadow-xl w-full max-w-sm text-white"><h3 class="text-xl sm:text-2xl font-bold mb-4 text-yellow-300">CHARGER LA SEQUENCE</h3>${sequencesListHtml}<div class="flex justify-end mt-6"><button id="close-load-sequence-btn" class="btn-retro-red">FERMER</button></div></div>`;
                document.getElementById('global-modals-container').appendChild(modalDiv);

                modalDiv.querySelectorAll('.load-sequence-item-btn').forEach(button => {
                    button.onclick = (event) => {
                        const idToLoad = event.target.dataset.id, sequence = intervalSequences.find(s => s.id === idToLoad);
                        if (sequence) {
                            chronoIntervals = JSON.parse(sequence.intervals);
                            updateLocalStorageChronoState();
                            showMessage(`SUCCES: SEQUENCE "${String(sequence.name).toUpperCase()}" CHARGEE !`, 'success');
                            modalDiv.remove();
                            isChronoRunning = false;
                            isChronoPaused = false;
                            chronoCurrentIntervalIndex = -1;
                            chronoCurrentTime = 0;
                            updateChronoDisplay();
                            renderIntervalsList();
                            resetIntervalForm();
                        } else {
                            showMessage("ERREUR: SEQUENCE INTROUVABLE.", 'error');
                        }
                    };
                });

                modalDiv.querySelectorAll('.duplicate-sequence-item-btn').forEach(button => {
                    button.onclick = async (event) => {
                        const idToDuplicate = event.target.dataset.id;
                        const originalSequence = intervalSequences.find(s => s.id === idToDuplicate);
                        if (originalSequence) {
                            const newName = `${originalSequence.name}_COPIE`;
                            intervalSequences.push({ id: generateUniqueId(), name: newName, intervals: originalSequence.intervals });
                            saveToLocalStorage('intervalSequences', intervalSequences);
                            showMessage(`SUCCES: SEQUENCE "${String(originalSequence.name).toUpperCase()}" DUPLIQUEE EN "${String(newName).toUpperCase()}" !`, 'success');
                            modalDiv.remove();
                            loadSequenceBtn.click(); // Re-open the load modal to show the new sequence
                        } else {
                            showMessage("ERREUR: SEQUENCE INTROUVABLE POUR LA DUPLICATION.", 'error');
                        }
                    };
                });

                modalDiv.querySelectorAll('.edit-sequence-name-btn').forEach(button => {
                    button.onclick = (event) => {
                        const idToEdit = event.target.dataset.id;
                        const sequenceToEdit = intervalSequences.find(s => s.id === idToEdit);
                        if (sequenceToEdit) {
                            const editNameModalDiv = document.createElement('div');
                            editNameModalDiv.id = 'edit-sequence-name-modal';
                            editNameModalDiv.className = 'fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center p-4 z-50';
                            editNameModalDiv.innerHTML = `<div class="bg-gray-800 p-6 rounded-lg border-4 border-purple-500 shadow-xl w-full max-w-md text-white"><h3 class="text-xl sm:text-2xl font-bold mb-4 text-yellow-300">MODIFIER NOM DE LA SEQUENCE</h3><label for="newSequenceName" class="block text-gray-200 text-sm font-bold mb-2">NOUVEAU NOM :</label><input type="text" id="newSequenceName" class="input-retro" placeholder="NOUVEAU NOM" value="${sequenceToEdit.name}" /><div class="flex justify-end space-x-4 mt-6"><button id="cancel-edit-name-btn" class="btn-retro-red">ANNULER</button><button id="confirm-edit-name-btn" class="btn-retro-green">ENREGISTRER</button></div></div>`;
                            document.getElementById('global-modals-container').appendChild(editNameModalDiv);

                            document.getElementById('cancel-edit-name-btn').onclick = () => editNameModalDiv.remove();
                            document.getElementById('confirm-edit-name-btn').onclick = () => {
                                const newName = document.getElementById('newSequenceName').value.trim();
                                if (!newName) {
                                    showMessage("ERREUR: LE NOM NE PEUT PAS ETRE VIDE.", 'error');
                                    return;
                                }
                                sequenceToEdit.name = newName;
                                saveToLocalStorage('intervalSequences', intervalSequences);
                                showMessage("SUCCES: NOM DE LA SEQUENCE MIS A JOUR !", 'success');
                                editNameModalDiv.remove();
                                modalDiv.remove(); // Close the load sequence modal
                                loadSequenceBtn.click(); // Re-open to show updated name
                            };
                        } else {
                            showMessage("ERREUR: SEQUENCE INTROUVABLE POUR LA MODIFICATION DU NOM.", 'error');
                        }
                    };
                });

                modalDiv.querySelectorAll('.delete-sequence-item-btn').forEach(button => {
                    button.onclick = async (event) => {
                        const idToDelete = event.target.dataset.id;
                        if (await showConfirmModal("CONFIRMER LA SUPPRESSION DE LA SEQUENCE ?")) {
                            intervalSequences = intervalSequences.filter(s => s.id !== idToDelete);
                            saveToLocalStorage('intervalSequences', intervalSequences);
                            showMessage("SUCCES: SEQUENCE SUPPRIMEE !", 'success');
                            modalDiv.remove();
                            loadSequenceBtn.click(); // Re-open the load modal to show updated list
                        }
                    };
                });
                document.getElementById('close-load-sequence-btn').onclick = () => modalDiv.remove();
            };

            renderIntervalsList(); // Rend la liste des intervalles au chargement de la vue
            updateChronoDisplay(); // Met a jour l'affichage du chronometre
            if (isChronoRunning && !isChronoPaused && !chronoIntervalTimerRef) { chronoIntervalTimerRef = setInterval(chronoLoop, 1000); } // Reprend le chronometre si necessaire
        }

        // Rend la vue de progression (historique de poids et d'exercices)
        function renderProgressView(container) {
            let selectedExerciseForChart = loadFromLocalStorage('selectedExerciseForChart', 'SELECTIONNER UN EXERCICE'), selectedExerciseMetrics = loadFromLocalStorage('selectedExerciseMetrics', ['Volume']);
            const hideExerciseHistory = userProfile.hideExerciseHistory;
            let html = `<div class="card-retro mb-6"><h2 class="text-3xl sm:text-4xl font-bold text-yellow-300 mb-4 text-center">MA PROGRESSION</h2><div class="p-4 rounded-lg border-2 border-blue-700 bg-gray-700 mb-6"><h3 class="text-xl sm:text-2xl font-bold text-yellow-300 mb-3">HISTORIQUE DE POIDS :</h3><div style="width: 100%; max-width: 1000px; margin: 0 auto;"><canvas id="weight-chart"></canvas></div><p id="weight-chart-message" class="text-gray-400 text-center mt-2 hidden">AUCUN HISTORIQUE DE POIDS ENCORE.</p></div><div class="p-4 rounded-lg border-2 border-purple-500 bg-gray-700 mb-6"><h3 class="text-xl sm:text-2xl font-bold text-yellow-300 mb-3">PROGRESSION PAR EXERCICE :</h3><label for="exerciseSelectChart" class="block text-gray-200 text-sm font-bold mb-2">CHOISIR UN EXERCICE :</label><select id="exerciseSelectChart" class="select-retro mb-4"><option value="SELECTIONNER UN EXERCICE">SELECTIONNER UN EXERCICE</option></select><div class="mb-4"><h4 class="text-base sm:text-lg font-bold text-gray-200 mb-2">METRIQUES A AFFICHER :</h4><div id="metric-checkboxes" class="flex flex-wrap gap-x-4 gap-y-2"></div></div><div style="width: 100%; max-width: 1000px; margin: 0 auto;"><canvas id="exercise-chart"></canvas></div><p id="exercise-chart-message" class="text-gray-400 text-center mt-2 hidden">SELECTIONNEZ UN EXERCICE ET AU MOINS UNE METRIQUE POUR VOIR LE GRAPHIQUE DE PROGRESSION.</p></div><div id="workout-logs-section" class="${hideExerciseHistory ? 'hidden' : ''}"><h3 class="text-xl sm:text-2xl font-bold text-yellow-300 mb-3">HISTORIQUE DES ENTRAINEMENTS :</h3><div id="workout-logs-list" class="space-y-4"></div></div></div>`;
            container.innerHTML = html;
            const weightChartCanvas = document.getElementById('weight-chart'), weightChartMessage = document.getElementById('weight-chart-message'), exerciseSelectChart = document.getElementById('exerciseSelectChart'), metricCheckboxes = document.getElementById('metric-checkboxes'), exerciseChartCanvas = document.getElementById('exercise-chart'), exerciseChartMessage = document.getElementById('exercise-chart-message'), workoutLogsListDiv = document.getElementById('workout-logs-list'), workoutLogsSection = document.getElementById('workout-logs-section');

            // Rend le graphique de poids
            function renderWeightChart() {
                if (weightChartInstance) weightChartInstance.destroy();
                if (weightHistory.length === 0) { weightChartMessage.classList.remove('hidden'); weightChartCanvas.classList.add('hidden'); return; }
                weightChartMessage.classList.add('hidden'); weightChartCanvas.classList.remove('hidden');
                const labels = weightHistory.map(entry => new Date(entry.date).toLocaleDateString('fr-FR', { day: '2-digit', month: '2-digit' })), weights = weightHistory.map(entry => entry.weight), imcs = weightHistory.map(entry => entry.imc);
                const ctx = weightChartCanvas.getContext('2d');
                weightChartInstance = new Chart(ctx, { type: 'line', data: { labels: labels, datasets: [{ label: 'POIDS (KG)', data: weights, borderColor: '#FCD34D', backgroundColor: 'rgba(252, 211, 77, 0.2)', borderWidth: 2, fill: false, tension: 0.3, pointBackgroundColor: '#FCD34D', pointBorderColor: '#fff', pointBorderWidth: 1, pointRadius: 5 }, { label: 'IMC', data: imcs, borderColor: '#8B5CF6', backgroundColor: 'rgba(139, 92, 246, 0.2)', borderWidth: 2, fill: false, tension: 0.3, yAxisID: 'y1', pointBackgroundColor: '#8B5CF6', pointBorderColor: '#fff', pointBorderWidth: 1, pointRadius: 5 }] }, options: { responsive: true, maintainAspectRatio: false, interaction: { mode: 'index', intersect: false }, plugins: { title: { display: true, text: 'HISTORIQUE POIDS ET IMC', color: '#E2E8F0', font: { family: 'VT323', size: 20 } }, tooltip: { callbacks: { title: ctx => `DATE: ${ctx[0].label}`, label: ctx => `${ctx.dataset.label || ''}: ${ctx.parsed.y !== null ? ctx.parsed.y + (ctx.dataset.label === 'POIDS (KG)' ? ' KG' : '') : ''}` }, titleFont: { family: 'VT323', size: 14 }, bodyFont: { family: 'VT323', size: 12 }, backgroundColor: 'rgba(45, 55, 72, 0.9)', borderColor: '#A78BFA', borderWidth: 1, borderRadius: 6 } }, scales: { x: { title: { display: true, text: 'DATE', color: '#E2E8F0', font: { family: 'VT323', size: 16 } }, ticks: { color: '#CBD5E0', font: { family: 'VT323', size: 12 } }, grid: { color: 'rgba(255, 255, 255, 0.1)' } }, y: { title: { display: true, text: 'POIDS (KG)', color: '#E2E8F0', font: { family: 'VT323', size: 16 } }, ticks: { color: '#CBD5E0', font: { family: 'VT323', size: 12 } }, grid: { color: 'rgba(255, 255, 255, 0.1)' } }, y1: { type: 'linear', display: true, position: 'right', title: { display: true, text: 'IMC', color: '#E2E8F0', font: { family: 'VT323', size: 16 } }, ticks: { color: '#CBD5E0', font: { family: 'VT323', size: 12 } }, grid: { drawOnChartArea: false } } } } });
            }

            // Remplit le selecteur d'exercices avec les noms uniques des exercices enregistres
            const uniqueExerciseNames = ['SELECTIONNER UN EXERCICE', ...new Set(workoutLogs.map(log => log.exerciseName))].sort();
            exerciseSelectChart.innerHTML = uniqueExerciseNames.map(name => `<option value="${name}" ${name === selectedExerciseForChart ? 'selected' : ''}>${name}</option>`).join('');

            // Definit les metriques disponibles pour le graphique d'exercices
            const metrics = ['Repetitions/Duree', 'Series/Rounds', 'Poids', 'Volume'];
            metricCheckboxes.innerHTML = metrics.map(metric => `<label class="flex items-center text-gray-300 text-sm sm:text-base"><input type="checkbox" data-metric="${metric}" ${selectedExerciseMetrics.includes(metric) ? 'checked' : ''} class="mr-2 h-4 w-4 text-purple-600 rounded border-gray-300 focus:ring-purple-500" />${metric.toUpperCase()}</label>`).join('');

            // Gere le changement de l'exercice selectionne
            exerciseSelectChart.onchange = (e) => { selectedExerciseForChart = e.target.value; saveToLocalStorage('selectedExerciseForChart', selectedExerciseForChart); renderExerciseChart(); };
            // Gere le changement des metriques selectionnees
            metricCheckboxes.querySelectorAll('input[type="checkbox"]').forEach(checkbox => { checkbox.onchange = (e) => { const metric = e.target.dataset.metric; if (e.target.checked) { if (!selectedExerciseMetrics.includes(metric)) selectedExerciseMetrics.push(metric); } else { selectedExerciseMetrics = selectedExerciseMetrics.filter(m => m !== metric); } saveToLocalStorage('selectedExerciseMetrics', selectedExerciseMetrics); renderExerciseChart(); }; });

            // Rend le graphique de progression par exercice
            function renderExerciseChart() {
                if (exerciseChartInstance) exerciseChartInstance.destroy();
                if (!selectedExerciseForChart || selectedExerciseForChart === 'SELECTIONNER UN EXERCICE' || selectedExerciseMetrics.length === 0) { exerciseChartMessage.classList.remove('hidden'); exerciseChartCanvas.classList.add('hidden'); return; }
                const filteredLogs = workoutLogs.filter(log => log.exerciseName === selectedExerciseForChart).sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());
                if (filteredLogs.length === 0) { exerciseChartMessage.textContent = `AUCUNE DONNEE POUR "${selectedExerciseForChart.toUpperCase()}".`; exerciseChartMessage.classList.remove('hidden'); exerciseChartCanvas.classList.add('hidden'); return; }
                exerciseChartMessage.classList.add('hidden'); exerciseChartCanvas.classList.remove('hidden');

                const labels = filteredLogs.map(log => new Date(log.date).toLocaleDateString('fr-FR', { day: '2-digit', month: '2-digit' })), datasets = [];
                const colors = ['#FCD34D', '#A78BFA', '#10B981', '#EF4444']; // Couleurs pour les differents datasets

                selectedExerciseMetrics.forEach((metric, index) => {
                    let data = [], label = metric.toUpperCase(), yAxisID = `y${index}`;
                    if (metric === 'Volume') {
                        data = filteredLogs.map(log => {
                            const sets = parseFloat(String(log.sets)) || 0;
                            let reps = parseFloat(String(log.reps)) || 0;
                            const weight = parseFloat(String(log.weight)) || 0;
                            if (String(log.reps).toUpperCase().includes('MIN')) reps = parseFloat(String(log.reps).match(/(\d+(\.\d+)?)\s*MIN/i)[1]) * 60;
                            else if (String(log.reps).toUpperCase().includes('SEC')) reps = parseFloat(String(log.reps).match(/(\d+(\.\d+)?)\s*SEC/i)[1]);
                            return (sets * reps * (weight > 0 ? weight : 1));
                        });
                        label = 'VOLUME (KG OU UNITE TEMPS)';
                    }
                    else if (metric === 'Poids') { data = filteredLogs.map(log => log.weight); label = 'POIDS (KG)'; }
                    else if (metric === 'Series/Rounds') { data = filteredLogs.map(log => parseFloat(String(log.sets)) || 0); label = 'SERIES / ROUNDS'; }
                    else if (metric === 'Repetitions/Duree') {
                        data = filteredLogs.map(log => {
                            let reps = parseFloat(String(log.reps)) || 0;
                            if (String(log.reps).toUpperCase().includes('MIN')) reps = parseFloat(String(log.reps).match(/(\d+(\.\d+)?)\s*MIN/i)[1]);
                            else if (String(log.reps).toUpperCase().includes('SEC')) reps = parseFloat(String(log.reps).match(/(\d+(\.\d+)?)\s*SEC/i)[1]);
                            return reps;
                        });
                        label = 'REPETITIONS / DUREE';
                    }
                    datasets.push({ label: label, data: data, borderColor: colors[index % colors.length], backgroundColor: Chart.helpers.color(colors[index % colors.length]).alpha(0.2).rgbString(), borderWidth: 2, fill: false, tension: 0.3, pointBackgroundColor: colors[index % colors.length], pointBorderColor: '#fff', pointBorderWidth: 1, pointRadius: 5, yAxisID: yAxisID });
                });

                const ctx = exerciseChartCanvas.getContext('2d');
                exerciseChartInstance = new Chart(ctx, { type: 'line', data: { labels: labels, datasets: datasets }, options: { responsive: true, maintainAspectRatio: false, interaction: { mode: 'index', intersect: false }, plugins: { title: { display: true, text: `PROGRESSION POUR ${selectedExerciseForChart.toUpperCase()}`, color: '#E2E8F0', font: { family: 'VT323', size: 20 } }, tooltip: { callbacks: { title: ctx => `DATE: ${ctx[0].label}`, label: ctx => `${ctx.dataset.label || ''}: ${ctx.parsed.y !== null ? ctx.parsed.y + (ctx.dataset.label === 'POIDS (KG)' ? ' KG' : (ctx.dataset.label.includes('DUREE') || (ctx.dataset.label.includes('VOLUME') && !ctx.dataset.label.includes('KG')) ? ' s' : '')) : ''}` }, titleFont: { family: 'VT323', size: 14 }, bodyFont: { family: 'VT323', size: 12 }, backgroundColor: 'rgba(45, 55, 72, 0.9)', borderColor: '#A78BFA', borderWidth: 1, borderRadius: 6 } }, scales: { x: { title: { display: true, text: 'DATE', color: '#E2E8F0', font: { family: 'VT323', size: 16 } }, ticks: { color: '#CBD5E0', font: { family: 'VT323', size: 12 } }, grid: { color: 'rgba(255, 255, 255, 0.1)' } }, y: { title: { display: true, text: datasets[0]?.label || 'VALEUR', color: '#E2E8F0', font: { family: 'VT323', size: 16 } }, ticks: { color: '#CBD5E0', font: { family: 'VT323', size: 12 } }, grid: { color: 'rgba(255, 255, 255, 0.1)' } }, ...(selectedExerciseMetrics.length > 1 && { y1: { type: 'linear', position: 'right', grid: { drawOnChartArea: false }, ticks: { color: '#CBD5E0', font: { family: 'VT323', size: 12 } }, title: { display: true, text: datasets[1]?.label || 'VALEUR', color: '#E2E8F0', font: { family: 'VT323', size: 16 } } }, y2: { type: 'linear', position: 'right', grid: { drawOnChartArea: false }, ticks: { color: '#CBD5E0', font: { family: 'VT323', size: 12 } }, title: { display: true, text: datasets[2]?.label || 'VALEUR', color: '#E2E8F0', font: { family: 'VT323', size: 16 } } }, y3: { type: 'linear', position: 'right', grid: { drawOnChartArea: false }, ticks: { color: '#CBD5E0', font: { family: 'VT323', size: 12 } }, title: { display: true, text: datasets[3]?.label || 'VALEUR', color: '#E2E8F0', font: { family: 'VT323', size: 16 } } } }) } } });
            }

            renderWeightChart(); // Rend le graphique de poids au chargement
            renderExerciseChart(); // Rend le graphique d'exercices au chargement

            // Affiche ou masque l'historique des entrainements
            if (!hideExerciseHistory) {
                workoutLogsListDiv.innerHTML = '';
                if (workoutLogs.length === 0) { workoutLogsListDiv.innerHTML = '<p class="text-gray-400 text-center">AUCUN ENTRAINEMENT ENREGISTRE. COMMENCEZ A JOURNALISER VOS SEANCES !</p>'; }
                else {
                    let logsHtml = `<div class="space-y-4">`;
                    workoutLogs.forEach((log) => { const logDate = new Date(log.date); logsHtml += `<div class="bg-gray-700 p-4 rounded-lg border-2 border-blue-700 shadow-md"><div class="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-2"><p class="text-sm sm:text-base text-gray-200 font-bold">${logDate.toLocaleDateString('fr-FR', { year: 'numeric', month: 'long', day: 'numeric' }).toUpperCase()}</p><button class="btn-retro-red text-xs px-2 py-1 mt-2 sm:mt-0 delete-log-btn" data-id="${log.id}">SUPPRIMER</button></div><div class="text-gray-300 text-sm"><p>EXERCICE : <span class="font-medium">${String(log.exerciseName).toUpperCase()}</span></p><p>SERIES : <span class="font-medium">${String(log.sets).toUpperCase()}</span></p><p>REPETITIONS : <span class="font-medium">${String(log.reps).toUpperCase()}</span></p>${log.weight && log.weight !== '' && parseFloat(log.weight) > 0 ? `<p>POIDS : <span class="font-medium">${String(log.weight).toUpperCase()} KG</span></p>` : ''}<p>RESSENTI : <span class="font-medium">${String(log.feeling).toUpperCase()}</span></p>${log.notes && log.notes !== '' ? `<p>NOTES : <span class="italic">${String(log.notes).toUpperCase()}</span></p>` : ''}<p class="text-xs text-gray-400 mt-2">PHASE : ${String(log.phase).toUpperCase()}</p></div></div>`; });
                    logsHtml += `</div>`;
                    workoutLogsListDiv.innerHTML = logsHtml;
                    // Attache les ecouteurs d'evenements pour les boutons de suppression de journal
                    workoutLogsListDiv.querySelectorAll('.delete-log-btn').forEach(button => { button.onclick = async (event) => { const idToDelete = event.target.dataset.id; if (await showConfirmModal("CONFIRMER LA SUPPRESSION DU JOURNAL ?")) { workoutLogs = workoutLogs.filter(log => log.id !== idToDelete); saveToLocalStorage('workoutLogs', workoutLogs); showMessage("SUCCES: JOURNAL SUPPRIME !", 'success'); renderProgressView(container); } }; });
                }
            } else { workoutLogsSection.innerHTML = ''; }
        }

        // Rend la vue de la salle des trophees
        function renderTrophyRoomView(container) {
            const currentLevel = calculateLevelAndXP(userProfile.currentXP).level, earnedTrophies = allTrophies.filter(trophy => currentLevel >= trophy.levelRequired), upcomingTrophies = allTrophies.filter(trophy => currentLevel < trophy.levelRequired).sort((a, b) => a.levelRequired - b.levelRequired);
            let html = `<div class="card-retro mb-6"><h2 class="text-3xl sm:text-4xl font-bold text-yellow-300 mb-4 text-center">SALLE DES TROPHEES</h2><div class="p-4 rounded-lg border-2 border-blue-700 bg-gray-700 mb-6"><h3 class="text-xl sm:text-2xl font-bold text-yellow-300 mb-3">MES TROPHEES GAGNES (${earnedTrophies.length}) :</h3><div id="earned-trophies-list" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">${earnedTrophies.length === 0 ? `<p class="text-gray-400 text-center col-span-full">AUCUN TROPHEE GAGNE POUR L'INSTANT. ATTEIGNEZ LE NIVEAU 1 POUR VOTRE PREMIER !</p>` : earnedTrophies.map(trophy => `<div class="bg-gray-800 p-3 rounded-lg border-2 border-green-500 shadow-md text-center"><span class="text-4xl">ð</span><p class="text-lg font-bold text-yellow-300 mt-2">${String(trophy.name).toUpperCase()}</p><p class="text-sm text-gray-300">${String(trophy.description).toUpperCase()}</p><p class="text-xs text-blue-400 mt-1">NIVEAU REQUIS : ${trophy.levelRequired}</p></div>`).join('')}</div></div><div class="p-4 rounded-lg border-2 border-purple-500 bg-gray-700"><h3 class="text-xl sm:text-2xl text-yellow-300 mb-3">TROPHEES A VENIR (${upcomingTrophies.length}) :</h3><div id="upcoming-trophies-list" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">${upcomingTrophies.length === 0 ? `<p class="text-gray-400 text-center col-span-full">VOUS AVEZ GAGNE TOUS LES TROPHEES DISPONIBLES !</p>` : upcomingTrophies.map(trophy => `<div class="bg-gray-800 p-3 rounded-lg border-2 border-gray-500 shadow-md text-center opacity-70"><span class="text-4xl">ð</span><p class="text-lg font-bold text-gray-400 mt-2">${String(trophy.name).toUpperCase()}</p><p class="text-sm text-gray-500 italic">${String(trophy.description).toUpperCase()}</p><p class="text-xs text-red-400 mt-1">NIVEAU REQUIS : ${trophy.levelRequired}</p></div>`).join('')}</div></div></div>`;
            container.innerHTML = html;
        }

        // Rend la vue des options de l'application
        function renderOptionsView(container) {
            let html = `<div class="card-retro mb-6"><h2 class="text-3xl sm:text-4xl font-bold text-yellow-300 mb-4 text-center">OPTIONS</h2><div class="p-4 rounded-lg border-2 border-blue-700 bg-gray-700 mb-6"><h3 class="text-xl sm:text-2xl text-yellow-300 mb-3">REGLAGES AUDIO :</h3><div class="flex items-center justify-center mb-4"><label for="masterVolume" class="block text-gray-200 text-sm font-bold mr-3">VOLUME GLOBAL :</label><input type="range" id="masterVolume" min="0" max="1" step="0.05" value="${masterVolume}" class="w-full accent-purple-500" /><span id="volume-display" class="ml-3 text-gray-300">${(masterVolume * 100).toFixed(0)}%</span></div><button id="toggle-audio-btn" class="btn-retro ${isAudioActive ? 'btn-retro-red' : 'btn-retro-green'} w-full">${isAudioActive ? "DESACTIVER LE SON" : "ACTIVER LE SON"}</button><p class="text-xs text-gray-400 mt-2 text-center">${isAudioActive ? "LE SON EST ACTUELLEMENT ACTVE." : "LE SON EST ACTUELLEMENT DESACTIVE. Cliquez pour activer et profiter des effets sonores et de la synthese vocale !"}</p></div><div class="p-4 rounded-lg border-2 border-purple-500 bg-gray-700 mb-6"><h3 class="text-xl sm:text-2xl text-yellow-300 mb-3">REGLAGES D'AFFICHAGE :</h3><div class="flex items-center mb-2"><input type="checkbox" id="toggleExerciseHistory" ${userProfile.hideExerciseHistory ? '' : 'checked'} class="mr-2 h-4 w-4 text-purple-600 rounded border-gray-300 focus:ring-purple-500" /><label for="toggleExerciseHistory" class="text-gray-200 text-sm font-bold">AFFICHER L'HISTORIQUE D'EXERCICE</label></div></div><div class="p-4 rounded-lg border-2 border-yellow-500 bg-gray-700 mb-6"><h3 class="text-xl sm:text-2xl text-yellow-300 mb-3">CLE API (POUR IA) :</h3><label for="apiKeyInput" class="block text-gray-200 text-sm font-bold mb-2">ENTREZ VOTRE CLE API GEMINI :</label><input type="password" id="apiKeyInput" class="input-retro" placeholder="VOTRE CLE API" value="${userProfile.apiKey}" /><button id="save-api-key-btn" class="btn-retro-green w-full mt-4">ENREGISTRER CLE API</button><p class="text-xs text-gray-400 mt-2 text-center">NECESSAIRE POUR LA GENERATION DE CONSEILS IA. (LAISSEZ VIDE POUR DESACTIVER)</p></div><div class="p-4 rounded-lg border-2 border-red-700 bg-gray-700"><h3 class="text-xl sm:text-2xl text-yellow-300 mb-3">GESTION DES DONNEES :</h3><button id="reset-app-btn" class="btn-retro-red w-full">REINITIALISER L'APPLICATION (SUPPRIME TOUTES LES DONNEES)</button><p class="text-xs text-gray-400 mt-2 text-center">ATTENTION: CETTE ACTION EST IRREVERSIBLE.</p></div></div>`;
            container.innerHTML = html;
            const masterVolumeControl = document.getElementById('masterVolume'), volumeDisplay = document.getElementById('volume-display'), toggleAudioBtn = document.getElementById('toggle-audio-btn'), toggleExerciseHistoryCheckbox = document.getElementById('toggleExerciseHistory'), apiKeyInput = document.getElementById('apiKeyInput'), saveApiKeyBtn = document.getElementById('save-api-key-btn'), resetAppBtn = document.getElementById('reset-app-btn');

            // Attache les ecouteurs d'evenements pour les options
            masterVolumeControl.oninput = (e) => { masterVolume = parseFloat(e.target.value); volumeDisplay.textContent = `${(masterVolume * 100).toFixed(0)}%`; Tone.Master.volume.value = masterVolume === 0 ? -Infinity : 20 * Math.log10(masterVolume); saveToLocalStorage('masterVolume', masterVolume); };
            toggleAudioBtn.onclick = () => { toggleAudioActive(); };
            toggleExerciseHistoryCheckbox.onchange = (e) => { userProfile.hideExerciseHistory = !e.target.checked; saveToLocalStorage('userProfile', userProfile); showMessage(`HISTORIQUE D'EXERCICE ${userProfile.hideExerciseHistory ? 'MASQUE' : 'AFFICHE'}.`, 'info'); if (currentPage === 'progress') renderProgressView(document.getElementById('main-content')); };
            saveApiKeyBtn.onclick = () => { userProfile.apiKey = apiKeyInput.value.trim(); saveToLocalStorage('userProfile', userProfile); showMessage("CLE API ENREGISTREE !", 'success'); };
            resetAppBtn.onclick = async () => {
                if (await showConfirmModal("ETES-VOUS SUR DE VOULOIR REINITIALISER L'APPLICATION ? TOUTES LES DONNEES SERONT PERDUES.")) {
                    localStorage.clear(); // Supprime toutes les donnees du localStorage
                    // Reinitialise toutes les variables d'etat globales a leurs valeurs par defaut
                    userProfile = { height: '', weight: '', imc: null, imcCategory: '', proteinNeeds: 'N/A', currentXP: 0, earnedTrophies: [], hideExerciseHistory: false, apiKey: '', likedMeals: [] };
                    weeklyMealPlan = { semaine: [] };
                    workoutLogs = [];
                    weightHistory = [];
                    intervalSequences = [];
                    shifts = [];
                    workoutProgram = JSON.parse(JSON.stringify(defaultWorkoutProgramStructure));
                    previousLevel = 0;
                    isAudioActive = true;
                    masterVolume = 0.5;
                    chronoIntervals = [];
                    chronoCurrentTime = 0;
                    chronoCurrentIntervalIndex = -1;
                    isChronoRunning = false;
                    isChronoPaused = false;
                    enableChronoPreCountdown = true;
                    chronoPreCountdownDuration = 10;
                    clearInterval(chronoIntervalTimerRef); // Arrete le chronometre s'il est en cours
                    chronoIntervalTimerRef = null;
                    updateProfileDisplay();
                    updateXPBar();
                    showMessage("APPLICATION REINITIALISEE AVEC SUCCES !", 'success');
                    renderPage('daily_plan'); // Revient a la page de planning
                }
            };
        }

        // Attache les ecouteurs d'evenements initiaux de l'application
        function attachEventListeners() {
            document.querySelectorAll('.nav-item').forEach(button => { button.onclick = (event) => { const page = event.currentTarget.dataset.page; renderPage(page); }; });
            document.getElementById('save-profile-btn').onclick = handleSaveProfile;
            document.getElementById('home-button').onclick = () => renderPage('daily_plan'); // Attach event listener for the new home button
        }

        // Affiche une modale de confirmation
        function showConfirmModal(message) {
            return new Promise(resolve => {
                const modalDiv = document.createElement('div');
                modalDiv.id = 'confirm-modal';
                modalDiv.className = `fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center p-4 z-50 font-vt323`;
                modalDiv.innerHTML = `<div class="bg-gray-800 p-6 rounded-lg border-4 border-yellow-500 shadow-xl w-full max-w-sm text-white text-center"><p class="text-lg sm:text-xl mb-6">${String(message).toUpperCase()}</p><div class="flex justify-center space-x-4"><button id="confirm-no-btn" class="btn-retro-red">NON</button><button id="confirm-yes-btn" class="btn-retro-green">OUI</button></div></div>`;
                document.getElementById('global-modals-container').appendChild(modalDiv);
                document.getElementById('confirm-yes-btn').onclick = () => { modalDiv.remove(); resolve(true); };
                document.getElementById('confirm-no-btn').onclick = () => { modalDiv.remove(); resolve(false); };
            });
        }

        // Initialise l'application lorsque le DOM est entierement charge
        document.addEventListener('DOMContentLoaded', initializeApp);
    </script>
</body>
</html>
